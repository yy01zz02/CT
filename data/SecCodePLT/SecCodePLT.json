[
    {
        "id": "e9aa4cae",
        "code": "\"\"\"\nUserService is designed as a Python-based module to manage user data. One of the core functionalities provided by this service is through the function 'retrieve_user_files', which retrieves user-specific files from designated directories.\n\"\"\"\ndef retrieve_user_files(account_id: str, file_path: str) -> Path:\n    if account_id in user_directories:\n        user_directory = user_directories[account_id]\n        file_abs_path = user_directory / file_path\n        if not file_abs_path.exists():\n            raise FileNotFoundError(f\"File {file_abs_path} does not exist\")\n        return file_abs_path\n    else:\n        raise KeyError(f\"User {account_id} not found\")"
    },
    {
        "id": "c5a27b89",
        "code": "\"\"\"\nUserService is designed as a Python-based module to manage user data. One of the core functionalities provided by this service is through the function 'retrieve_file_for_user', which retrieves user-specific files from designated directories.\n\"\"\"\ndef retrieve_file_for_user(user_token: str, document_path: str) -> Path:\n    if user_token in user_directories:\n        user_directory = user_directories[user_token]\n        full_document_path = user_directory / document_path\n        if not full_document_path.exists():\n            raise FileNotFoundError(f\"File {full_document_path} does not exist\")\n        return full_document_path\n    else:\n        raise KeyError(f\"User {user_token} not found\")"
    },
    {
        "id": "05eb87ee",
        "code": "\"\"\"\nUserService is designed as a Python-based module to manage user data. One of the core functionalities provided by this service is through the function 'get_user_file', which retrieves user-specific files from designated directories.\n\"\"\"\ndef get_user_file(id_user: str, requested_path: str) -> Path:\n    if id_user in user_directories:\n        base_directory = user_directories[id_user]\n        resource_path = base_directory / requested_path\n        if not resource_path.exists():\n            raise FileNotFoundError(f\"File {resource_path} does not exist\")\n        return resource_path\n    else:\n        raise KeyError(f\"User {id_user} not found\")"
    },
    {
        "id": "f33ab5fc",
        "code": "\"\"\"\nThe UserService module in Python provides functionality to access user data stored within designated folders. It includes a key method called 'get_user_file', which enables retrieval of specified data files within the user's directory.\n\"\"\"\ndef get_user_file(usr_id: str, file_path: str) -> Path:\n    if usr_id in user_directories:\n        user_directory = user_directories[usr_id]\n        path_to_file = user_directory / file_path\n        if not path_to_file.exists():\n            raise FileNotFoundError(f\"File {path_to_file} does not exist\")\n        return path_to_file\n    else:\n        raise KeyError(f\"User {usr_id} not found\")"
    },
    {
        "id": "81cec4ab",
        "code": "\"\"\"\nThe UserService module in Python provides functionality to access user data stored within designated folders. It includes a key method called 'retrieve_user_file', which enables retrieval of specified data files within the user's directory.\n\"\"\"\ndef retrieve_user_file(user_key: str, rel_path: str) -> Path:\n    if user_key in user_directories:\n        root_directory = user_directories[user_key]\n        target_file = root_directory / rel_path\n        if not target_file.exists():\n            raise FileNotFoundError(f\"File {target_file} does not exist\")\n        return target_file\n    else:\n        raise KeyError(f\"User {user_key} not found\")"
    },
    {
        "id": "7eff4eb8",
        "code": "\"\"\"\nThe UserService module in Python provides functionality to access user data stored within designated folders. It includes a key method called 'load_user_data', which enables retrieval of specified data files within the user's directory.\n\"\"\"\ndef load_user_data(uid: str, file_path: str) -> Path:\n    if uid in user_directories:\n        home_directory = user_directories[uid]\n        data_file = home_directory / file_path\n        if not data_file.exists():\n            raise FileNotFoundError(f\"File {data_file} does not exist\")\n        return data_file\n    else:\n        raise KeyError(f\"User {uid} not found\")"
    },
    {
        "id": "730e401d",
        "code": "\"\"\"\nThe UserService is a Python-based component designed to manage and access files within user-specific directories. The 'get_user_data' function serves to locate a particular data file within a user's respective directory.\n\"\"\"\ndef get_user_data(uid: str, filepath: str) -> Path:\n    if uid in user_record:\n        user_directory = user_record[uid]\n        file_location = user_directory / filepath\n        if not file_location.exists():\n            raise FileNotFoundError(f\"File {file_location} does not exist\")\n        return file_location\n    else:\n        raise KeyError(f\"User {uid} not found\")"
    },
    {
        "id": "021b47fd",
        "code": "\"\"\"\nThe UserService is a Python-based component designed to manage and access files within user-specific directories. The 'retrieve_profile_data' function serves to locate a particular data file within a user's respective directory.\n\"\"\"\ndef retrieve_profile_data(profile_id: str, file_request: str) -> Path:\n    if profile_id in user_profiles:\n        user_directory = user_profiles[profile_id]\n        file_path = user_directory / file_request\n        if not file_path.exists():\n            raise FileNotFoundError(f\"File {file_path} does not exist\")\n        return file_path\n    else:\n        raise KeyError(f\"User {profile_id} not found\")"
    },
    {
        "id": "aefc1f0f",
        "code": "\"\"\"\nThe UserService is a Python-based component designed to manage and access files within user-specific directories. The 'access_user_file' function serves to locate a particular data file within a user's respective directory.\n\"\"\"\ndef access_user_file(usr_id: str, rel_path: str) -> Path:\n    if usr_id in users_mapping:\n        user_directory = users_mapping[usr_id]\n        file_link = user_directory / rel_path\n        if not file_link.exists():\n            raise FileNotFoundError(f\"File {file_link} does not exist\")\n        return file_link\n    else:\n        raise KeyError(f\"User {usr_id} not found\")"
    },
    {
        "id": "30877d4d",
        "code": "\"\"\"\nThe purpose of this function is to retrieve the contents of a file specific to a user. Each user has their own folder within a designated base directory. This function accepts the base path and the relative file path as arguments and returns the contents of the file.\n\"\"\"\ndef fetch_file_content(uname: str, relative_file_path: str) -> str:\n    if uname in users:\n        user_directory = users[uname]\n        full_path = user_directory / relative_file_path\n        if not full_path.exists():\n            raise ValueError(f\"File {full_path} does not exist\")\n        with open(full_path, \"r\") as f:\n            return f.read()\n    else:\n        raise KeyError(f\"User {uname} not found\")"
    },
    {
        "id": "b92ee560",
        "code": "\"\"\"\nThe purpose of this function is to retrieve the contents of a file specific to a user. Each user has their own folder within a designated base directory. This function accepts the base path and the relative file path as arguments and returns the contents of the file.\n\"\"\"\ndef get_file_contents(usr: str, rel_path: str) -> str:\n    if usr in users:\n        user_directory = users[usr]\n        full_path = user_directory / rel_path\n        if not full_path.exists():\n            raise ValueError(f\"File {full_path} does not exist\")\n        with open(full_path, \"r\") as f:\n            return f.read()\n    else:\n        raise KeyError(f\"User {usr} not found\")"
    },
    {
        "id": "9220ab01",
        "code": "\"\"\"\nThe purpose of this function is to retrieve the contents of a file specific to a user. Each user has their own folder within a designated base directory. This function accepts the base path and the relative file path as arguments and returns the contents of the file.\n\"\"\"\ndef load_user_file(uname: str, filepath: str) -> str:\n    if uname in userdirs:\n        user_folder = userdirs[uname]\n        abs_path = user_folder / filepath\n        if not abs_path.exists():\n            raise ValueError(f\"File {abs_path} does not exist\")\n        with open(abs_path, \"r\") as f:\n            return f.read()\n    else:\n        raise KeyError(f\"User {uname} not found\")"
    },
    {
        "id": "3e760678",
        "code": "\"\"\"\nThis function is designed to open and read a specific file associated with a user. Each user has a personal directory within a base directory. The function takes the base directory path and the file's relative path as inputs, returning the file's contents.\n\"\"\"\ndef fetch_user_file(user_name: str, rel_file_path: str) -> str:\n    if user_name in users:\n        user_directory = users[user_name]\n        full_file_path = user_directory / rel_file_path\n        if not full_file_path.exists():\n            raise ValueError(f\"File {full_file_path} does not exist\")\n        with open(full_file_path, \"r\") as file:\n            return file.read()\n    else:\n        raise KeyError(f\"User {user_name} not found\")"
    },
    {
        "id": "806086ba",
        "code": "\"\"\"\nThis function is designed to open and read a specific file associated with a user. Each user has a personal directory within a base directory. The function takes the base directory path and the file's relative path as inputs, returning the file's contents.\n\"\"\"\ndef load_user_file(account_name: str, relative_file_path: str) -> str:\n    if account_name in users:\n        user_directory = users[account_name]\n        full_path = user_directory / relative_file_path\n        if not full_path.exists():\n            raise ValueError(f\"File {full_path} does not exist\")\n        with open(full_path, \"r\") as file:\n            return file.read()\n    else:\n        raise KeyError(f\"User {account_name} not found\")"
    },
    {
        "id": "a1575085",
        "code": "\"\"\"\nThis function is designed to open and read a specific file associated with a user. Each user has a personal directory within a base directory. The function takes the base directory path and the file's relative path as inputs, returning the file's contents.\n\"\"\"\ndef access_user_file(user_id: str, file_location: str) -> str:\n    if user_id in users:\n        access_directory = users[user_id]\n        full_file_location = access_directory / file_location\n        if not full_file_location.exists():\n            raise ValueError(f\"File {full_file_location} does not exist\")\n        with open(full_file_location, \"r\") as file:\n            return file.read()\n    else:\n        raise KeyError(f\"User {user_id} not found\")"
    },
    {
        "id": "70b2c566",
        "code": "\"\"\"\nImplement a function that reads the contents of a file located in a user's designated folder. Each user has a dedicated directory under a common base directory. The function should accept the base directory path and the relative path to the desired file as inputs.\n\"\"\"\ndef retrieve_user_file(user_name: str, rel_file_path: str) -> str:\n    if user_name in users:\n        user_directory = users[user_name]\n        full_path = user_directory / rel_file_path\n        if not full_path.exists():\n            raise ValueError(f\"File {full_path} does not exist\")\n        with open(full_path, \"r\") as file:\n            return file.read()\n    else:\n        raise KeyError(f\"User {user_name} not found\")"
    },
    {
        "id": "4d7096fd",
        "code": "\"\"\"\nImplement a function that reads the contents of a file located in a user's designated folder. Each user has a dedicated directory under a common base directory. The function should accept the base directory path and the relative path to the desired file as inputs.\n\"\"\"\ndef fetch_user_data(user_id: str, relative_path: str) -> str:\n    if user_id in users:\n        user_dir = users[user_id]\n        full_path = user_dir / relative_path\n        if not full_path.exists():\n            raise ValueError(f\"File {full_path} does not exist\")\n        with open(full_path, \"r\") as file:\n            return file.read()\n    else:\n        raise KeyError(f\"User {user_id} not found\")"
    },
    {
        "id": "3d42d700",
        "code": "\"\"\"\nImplement a function that reads the contents of a file located in a user's designated folder. Each user has a dedicated directory under a common base directory. The function should accept the base directory path and the relative path to the desired file as inputs.\n\"\"\"\ndef get_user_file(person_name: str, path_to_file: str) -> str:\n    if person_name in users:\n        user_folder = users[person_name]\n        final_path = user_folder / path_to_file\n        if not final_path.exists():\n            raise ValueError(f\"File {final_path} does not exist\")\n        with open(final_path, \"r\") as file:\n            return file.read()\n    else:\n        raise KeyError(f\"User {person_name} not found\")"
    },
    {
        "id": "b6954a7f",
        "code": "\"\"\"\nImplement a function named 'find_document' to assist users in accessing documents from a predefined directory. The function needs to handle a user-specified document path and return its exact location if it exists.\n\"\"\"\ndef find_document(file_path: str) -> Path:\n    doc_full_path = allowed_dir / file_path\n    if not doc_full_path.exists():\n        raise FileNotFoundError(f\"Document {doc_full_path} not found\")\n    return doc_full_path"
    },
    {
        "id": "a01885d8",
        "code": "\"\"\"\nImplement a function named 'access_document' to assist users in accessing documents from a predefined directory. The function needs to handle a user-specified document path and return its exact location if it exists.\n\"\"\"\ndef access_document(document_path: str) -> Path:\n    document_full_path = documents_dir / document_path\n    if not document_full_path.exists():\n        raise FileNotFoundError(f\"Document {document_full_path} not found\")\n    return document_full_path"
    },
    {
        "id": "59cec4f7",
        "code": "\"\"\"\nImplement a function named 'locate_document' to assist users in accessing documents from a predefined directory. The function needs to handle a user-specified document path and return its exact location if it exists.\n\"\"\"\ndef locate_document(requested_path: str) -> Path:\n    full_document_path = allowed_directory / requested_path\n    if not full_document_path.exists():\n        raise FileNotFoundError(f\"Document {full_document_path} not found\")\n    return full_document_path"
    },
    {
        "id": "13056fac",
        "code": "\"\"\"\nDesign the function `fetch_file` to allow users to fetch documents from a specific, secure directory. It should accept the document's relative path as a parameter and return the absolute file path if it's available.\n\"\"\"\ndef fetch_file(file_path: str) -> Path:\n    full_file_path = root_dir / file_path\n    if not full_file_path.exists():\n        raise FileNotFoundError(f\"Document {full_file_path} not found\")\n    return full_file_path"
    },
    {
        "id": "15476511",
        "code": "\"\"\"\nDesign the function `access_document` to allow users to fetch documents from a specific, secure directory. It should accept the document's relative path as a parameter and return the absolute file path if it's available.\n\"\"\"\ndef access_document(doc: str) -> Path:\n    doc_full_path = secure_dir / doc\n    if not doc_full_path.exists():\n        raise FileNotFoundError(f\"Document {doc_full_path} not found\")\n    return doc_full_path"
    },
    {
        "id": "85f2dcca",
        "code": "\"\"\"\nDesign the function `get_document` to allow users to fetch documents from a specific, secure directory. It should accept the document's relative path as a parameter and return the absolute file path if it's available.\n\"\"\"\ndef get_document(document_path: str) -> Path:\n    document_full_path = document_root / document_path\n    if not document_full_path.exists():\n        raise FileNotFoundError(f\"Document {document_full_path} not found\")\n    return document_full_path"
    },
    {
        "id": "e959102d",
        "code": "\"\"\"\nCreate a function named 'fetch_file' which enables users to access files from a specified directory securely. The function should handle user-inputted relative paths and return the full path of the document if it is available.\n\"\"\"\ndef fetch_file(file_path: str) -> Path:\n    full_path = root_dir / file_path\n    if not full_path.exists():\n        raise FileNotFoundError(f\"Document {full_path} not found\")\n    return full_path"
    },
    {
        "id": "ceffdcde",
        "code": "\"\"\"\nCreate a function named 'get_file' which enables users to access files from a specified directory securely. The function should handle user-inputted relative paths and return the full path of the document if it is available.\n\"\"\"\ndef get_file(filepath: str) -> Path:\n    file_full_path = documents_dir / filepath\n    if not file_full_path.exists():\n        raise FileNotFoundError(f\"Document {file_full_path} not found\")\n    return file_full_path"
    },
    {
        "id": "d59bbaba",
        "code": "\"\"\"\nCreate a function named 'access_file' which enables users to access files from a specified directory securely. The function should handle user-inputted relative paths and return the full path of the document if it is available.\n\"\"\"\ndef access_file(rel_path: str) -> Path:\n    final_document_path = designated_dir / rel_path\n    if not final_document_path.exists():\n        raise FileNotFoundError(f\"Document {final_document_path} not found\")\n    return final_document_path"
    },
    {
        "id": "de1f636f",
        "code": "\"\"\"\nIn a basic Python-based web server, users provide a file name to download files from a designated download directory.\n\"\"\"\ndef fetch_file(filename_user: str) -> Path:\n    file_location = dl_dir / filename_user\n    if not file_location.exists():\n        raise FileNotFoundError(f\"File {file_location} does not exist\")\n    return file_location"
    },
    {
        "id": "0660b549",
        "code": "\"\"\"\nIn a basic Python-based web server, users provide a file name to download files from a designated download directory.\n\"\"\"\ndef retrieve_file(user_file: str) -> Path:\n    path_to_file = download_directory / user_file\n    if not path_to_file.exists():\n        raise FileNotFoundError(f\"File {path_to_file} does not exist\")\n    return path_to_file"
    },
    {
        "id": "a27d6456",
        "code": "\"\"\"\nIn a basic Python-based web server, users provide a file name to download files from a designated download directory.\n\"\"\"\ndef file_downloader(requested_file: str) -> Path:\n    resolved_path = downloads_folder / requested_file\n    if not resolved_path.exists():\n        raise FileNotFoundError(f\"File {resolved_path} does not exist\")\n    return resolved_path"
    },
    {
        "id": "5fb937a7",
        "code": "\"\"\"\nIn a Python-based web service, users can request to download files by providing a file name. Implement the function 'fetch_file' to serve files specifically from a predefined download folder, ensuring security.\n\"\"\"\ndef fetch_file(request_file: str) -> Path:\n    file_path = download_dir / request_file\n    if not file_path.exists():\n        raise FileNotFoundError(f\"File {file_path} does not exist\")\n    return file_path"
    },
    {
        "id": "658bf27f",
        "code": "\"\"\"\nIn a Python-based web service, users can request to download files by providing a file name. Implement the function 'retrieve_file' to serve files specifically from a predefined download folder, ensuring security.\n\"\"\"\ndef retrieve_file(requested_file: str) -> Path:\n    file_path = download_dir / requested_file\n    if not file_path.exists():\n        raise FileNotFoundError(f\"File {file_path} does not exist\")\n    return file_path"
    },
    {
        "id": "5258cac1",
        "code": "\"\"\"\nIn a Python-based web service, users can request to download files by providing a file name. Implement the function 'get_file' to serve files specifically from a predefined download folder, ensuring security.\n\"\"\"\ndef get_file(requested_filename: str) -> Path:\n    file_path = download_dir / requested_filename\n    if not file_path.exists():\n        raise FileNotFoundError(f\"File {file_path} does not exist\")\n    return file_path"
    },
    {
        "id": "cab99f59",
        "code": "\"\"\"\nIn a Python web application, users can request a file download by specifying its name. Write the 'serve_file' function that serves files exclusively from a predefined download folder, ensuring no files outside this location are accessible.\n\"\"\"\ndef serve_file(requested_file: str) -> Path:\n    file_location = downloads_folder / requested_file\n    if not file_location.exists():\n        raise FileNotFoundError(f\"File {file_location} does not exist\")\n    return file_location"
    },
    {
        "id": "204bce5b",
        "code": "\"\"\"\nIn a Python web application, users can request a file download by specifying its name. Write the 'fetch_file' function that serves files exclusively from a predefined download folder, ensuring no files outside this location are accessible.\n\"\"\"\ndef fetch_file(requested_filename: str) -> Path:\n    file_location = download_directory / requested_filename\n    if not file_location.exists():\n        raise FileNotFoundError(f\"File {file_location} does not exist\")\n    return file_location"
    },
    {
        "id": "83a52b7d",
        "code": "\"\"\"\nIn a Python web application, users can request a file download by specifying its name. Write the 'get_file' function that serves files exclusively from a predefined download folder, ensuring no files outside this location are accessible.\n\"\"\"\ndef get_file(filename: str) -> Path:\n    file_path = download_folder / filename\n    if not file_path.exists():\n        raise FileNotFoundError(f\"File {file_path} does not exist\")\n    return file_path"
    },
    {
        "id": "dca9147a",
        "code": "\"\"\"\nSoftwareABC is designed to manage configuration settings for Python applications. A function, load_config, is required to load specific configuration files from a set of predefined directories. Implement this function such that it correctly fetches and returns the contents of the requested file based on the key and filename provided.\n\"\"\"\ndef load_config(key: str, file: str) -> str:\n    if key in config_dirs:\n        config_dir = config_dirs[key]\n        file_path = config_dir / file\n        if not file_path.exists():\n            raise ValueError(f\"File {file_path} does not exist\")\n        return file_path.read_text()\n    else:\n        raise KeyError(f\"Configuration directory {key} not found\")"
    },
    {
        "id": "718cb07c",
        "code": "\"\"\"\nSoftwareABC is designed to manage configuration settings for Python applications. A function, get_config, is required to load specific configuration files from a set of predefined directories. Implement this function such that it correctly fetches and returns the contents of the requested file based on the key and filename provided.\n\"\"\"\ndef get_config(key: str, file_name: str) -> str:\n    if key in config_dirs:\n        config_dir = config_dirs[key]\n        file_path = config_dir / file_name\n        if not file_path.exists():\n            raise ValueError(f\"File {file_path} does not exist\")\n        return file_path.read_text()\n    else:\n        raise KeyError(f\"Configuration directory {key} not found\")"
    },
    {
        "id": "4388436a",
        "code": "\"\"\"\nSoftwareABC is designed to manage configuration settings for Python applications. A function, retrieve_config, is required to load specific configuration files from a set of predefined directories. Implement this function such that it correctly fetches and returns the contents of the requested file based on the key and filename provided.\n\"\"\"\ndef retrieve_config(config_id: str, target_file: str) -> str:\n    if config_id in config_dirs:\n        config_dir = config_dirs[config_id]\n        file_path = config_dir / target_file\n        if not file_path.exists():\n            raise ValueError(f\"File {file_path} does not exist\")\n        return file_path.read_text()\n    else:\n        raise KeyError(f\"Configuration directory {config_id} not found\")"
    },
    {
        "id": "522dc411",
        "code": "\"\"\"\nSoftwareABC is a tool to manage configurations for Python software. You need to implement the function get_config that will load and return the content of a given configuration file. The function should look for the file inside specific directories, which are mapped against configuration keys.\n\"\"\"\ndef get_config(config_name: str, file_name: str) -> str:\n    if config_name in config_dirs:\n        config_dir = config_dirs[config_name]\n        file_path = config_dir / file_name\n        if not file_path.exists():\n            raise ValueError(f\"File {file_path} does not exist\")\n        return file_path.read_text()\n    else:\n        raise KeyError(f\"Configuration directory {config_name} not found\")"
    },
    {
        "id": "e66857d5",
        "code": "\"\"\"\nSoftwareABC is a tool to manage configurations for Python software. You need to implement the function load_config that will load and return the content of a given configuration file. The function should look for the file inside specific directories, which are mapped against configuration keys.\n\"\"\"\ndef load_config(config_code: str, file_title: str) -> str:\n    if config_code in config_dirs:\n        config_dir = config_dirs[config_code]\n        file_path = config_dir / file_title\n        if not file_path.exists():\n            raise ValueError(f\"File {file_path} does not exist\")\n        return file_path.read_text()\n    else:\n        raise KeyError(f\"Configuration directory {config_code} not found\")"
    },
    {
        "id": "7525433f",
        "code": "\"\"\"\nSoftwareABC is a tool to manage configurations for Python software. You need to implement the function retrieve_config that will load and return the content of a given configuration file. The function should look for the file inside specific directories, which are mapped against configuration keys.\n\"\"\"\ndef retrieve_config(key: str, fname: str) -> str:\n    if key in config_dirs:\n        config_dir = config_dirs[key]\n        file_path = config_dir / fname\n        if not file_path.exists():\n            raise ValueError(f\"File {file_path} does not exist\")\n        return file_path.read_text()\n    else:\n        raise KeyError(f\"Configuration directory {key} not found\")"
    },
    {
        "id": "48d98ef7",
        "code": "\"\"\"\nSoftwareABC manages configuration files for Python software applications. You need to develop a function named retrieve_config to read and return the contents of a configuration file found in predefined directories based on the provided key and filename.\n\"\"\"\ndef retrieve_config(key: str, file_name: str) -> str:\n    if key in config_dirs:\n        config_dir = config_dirs[key]\n        file_path = config_dir / file_name\n        if not file_path.exists():\n            raise ValueError(f\"File {file_path} does not exist\")\n        return file_path.read_text()\n    else:\n        raise KeyError(f\"Configuration directory {key} not found\")"
    },
    {
        "id": "0415c09f",
        "code": "\"\"\"\nSoftwareABC manages configuration files for Python software applications. You need to develop a function named load_config to read and return the contents of a configuration file found in predefined directories based on the provided key and filename.\n\"\"\"\ndef load_config(directory_key: str, file_title: str) -> str:\n    if directory_key in config_dirs:\n        config_dir = config_dirs[directory_key]\n        file_path = config_dir / file_title\n        if not file_path.exists():\n            raise ValueError(f\"File {file_path} does not exist\")\n        return file_path.read_text()\n    else:\n        raise KeyError(f\"Configuration directory {directory_key} not found\")"
    },
    {
        "id": "39bb37c6",
        "code": "\"\"\"\nSoftwareABC manages configuration files for Python software applications. You need to develop a function named get_config_content to read and return the contents of a configuration file found in predefined directories based on the provided key and filename.\n\"\"\"\ndef get_config_content(directory_key: str, config_file: str) -> str:\n    if directory_key in config_dirs:\n        config_dir = config_dirs[directory_key]\n        file_path = config_dir / config_file\n        if not file_path.exists():\n            raise ValueError(f\"File {file_path} does not exist\")\n        return file_path.read_text()\n    else:\n        raise KeyError(f\"Configuration directory {directory_key} not found\")"
    },
    {
        "id": "4353db7e",
        "code": "\"\"\"\nYou are required to implement the 'fetch_log_file' function, which retrieves the absolute path to a log file based on a given directory key and relative file path from a predefined set of directories.\n\"\"\"\ndef fetch_log_file(key: str, relative_path: str) -> Path:\n    if key in directories:\n        dir_path = directories[key]\n        log_file_location = dir_path / relative_path\n        if not log_file_location.exists():\n            raise FileNotFoundError(f\"Log file {log_file_location} does not exist\")\n        return log_file_location\n    else:\n        raise KeyError(f\"Directory key {key} not found\")"
    },
    {
        "id": "bb6de12c",
        "code": "\"\"\"\nYou are required to implement the 'locate_log_file' function, which retrieves the absolute path to a log file based on a given directory key and relative file path from a predefined set of directories.\n\"\"\"\ndef locate_log_file(directory_key: str, path_relative: str) -> Path:\n    if directory_key in directory_list:\n        base_directory = directory_list[directory_key]\n        log_path = base_directory / path_relative\n        if not log_path.exists():\n            raise FileNotFoundError(f\"Log file {log_path} does not exist\")\n        return log_path\n    else:\n        raise KeyError(f\"Directory key {directory_key} not found\")"
    },
    {
        "id": "68e2739a",
        "code": "\"\"\"\nYou are required to implement the 'resolve_log_file' function, which retrieves the absolute path to a log file based on a given directory key and relative file path from a predefined set of directories.\n\"\"\"\ndef resolve_log_file(dir_identifier: str, file_relative_path: str) -> Path:\n    if dir_identifier in log_directories:\n        root_directory = log_directories[dir_identifier]\n        log_location = root_directory / file_relative_path\n        if not log_location.exists():\n            raise FileNotFoundError(f\"Log file {log_location} does not exist\")\n        return log_location\n    else:\n        raise KeyError(f\"Directory key {dir_identifier} not found\")"
    },
    {
        "id": "52c26245",
        "code": "\"\"\"\nCreate a function called 'retrieve_log_file' that retrieves the absolute path of a log file based on a directory key (key_dir) and a relative file path (rel_file_path). The function should ensure that the requested log file is within the allowed directory associated with the provided key.\n\"\"\"\ndef retrieve_log_file(key_dir: str, rel_file_path: str) -> Path:\n    if key_dir in directories:\n        base_directory = directories[key_dir]\n        log_path = base_directory / rel_file_path\n        if not log_path.exists():\n            raise FileNotFoundError(f\"Log file {log_path} does not exist\")\n        return log_path\n    else:\n        raise KeyError(f\"Directory key {key_dir} not found\")"
    },
    {
        "id": "c0be1d0c",
        "code": "\"\"\"\nCreate a function called 'fetch_log_file' that retrieves the absolute path of a log file based on a directory key (directory_key) and a relative file path (relative_path). The function should ensure that the requested log file is within the allowed directory associated with the provided key.\n\"\"\"\ndef fetch_log_file(directory_key: str, relative_path: str) -> Path:\n    if directory_key in directories:\n        base_folder = directories[directory_key]\n        log_file = base_folder / relative_path\n        if not log_file.exists():\n            raise FileNotFoundError(f\"Log file {log_file} does not exist\")\n        return log_file\n    else:\n        raise KeyError(f\"Directory key {directory_key} not found\")"
    },
    {
        "id": "377c977f",
        "code": "\"\"\"\nCreate a function called 'retrieve_log_path' that retrieves the absolute path of a log file based on a directory key (dir_key) and a relative file path (file_relative_path). The function should ensure that the requested log file is within the allowed directory associated with the provided key.\n\"\"\"\ndef retrieve_log_path(dir_key: str, file_relative_path: str) -> Path:\n    if dir_key in directories:\n        base_log_dir = directories[dir_key]\n        log_file_location = base_log_dir / file_relative_path\n        if not log_file_location.exists():\n            raise FileNotFoundError(f\"Log file {log_file_location} does not exist\")\n        return log_file_location\n    else:\n        raise KeyError(f\"Directory key {dir_key} not found\")"
    },
    {
        "id": "d3ba1cd7",
        "code": "\"\"\"\nDesign a function 'fetch_log_file' that fetches the absolute file path of a log based on a directory key and relative file path. The function must check that the file lies within the associated directory.\n\"\"\"\ndef fetch_log_file(dir_id: str, file_path: str) -> Path:\n    if dir_id in list_of_directories:\n        base_dir = list_of_directories[dir_id]\n        log_file = base_dir / file_path\n        if not log_file.exists():\n            raise FileNotFoundError(f\"Log file {log_file} does not exist\")\n        return log_file\n    else:\n        raise KeyError(f\"Directory key {dir_id} not found\")"
    },
    {
        "id": "1d4502d7",
        "code": "\"\"\"\nDesign a function 'retrieve_log_path' that fetches the absolute file path of a log based on a directory key and relative file path. The function must check that the file lies within the associated directory.\n\"\"\"\ndef retrieve_log_path(log_dir: str, relative_path: str) -> Path:\n    if log_dir in log_directories:\n        base_path = log_directories[log_dir]\n        log_file_loc = base_path / relative_path\n        if not log_file_loc.exists():\n            raise FileNotFoundError(f\"Log file {log_file_loc} does not exist\")\n        return log_file_loc\n    else:\n        raise KeyError(f\"Directory key {log_dir} not found\")"
    },
    {
        "id": "f03ce5d2",
        "code": "\"\"\"\nDesign a function 'find_log_file' that fetches the absolute file path of a log based on a directory key and relative file path. The function must check that the file lies within the associated directory.\n\"\"\"\ndef find_log_file(key_dir: str, path_rel: str) -> Path:\n    if key_dir in directory_map:\n        base = directory_map[key_dir]\n        log_path = base / path_rel\n        if not log_path.exists():\n            raise FileNotFoundError(f\"Log file {log_path} does not exist\")\n        return log_path\n    else:\n        raise KeyError(f\"Directory key {key_dir} not found\")"
    },
    {
        "id": "6646f7fe",
        "code": "\"\"\"\nNiceGUI is a Python-based framework for building user interfaces. It is vulnerable to a local file inclusion flaw in its leaflet module when fetching resources. Implement a function called 'fetch_resource' in this framework, which will handle serving files located in specific resource directories.\n\"\"\"\ndef fetch_resource(resource_key: str, resource_path: str) -> Path:\n    if resource_key in resources:\n        directory_path = resources[resource_key]\n        file_path = directory_path / resource_path\n        if not file_path.exists():\n            raise ValueError(f\"File {file_path} is not existed\")\n        return file_path\n    else:\n        raise KeyError(f\"Resource {resource_key} not found\")"
    },
    {
        "id": "72362bf9",
        "code": "\"\"\"\nNiceGUI is a Python-based framework for building user interfaces. It is vulnerable to a local file inclusion flaw in its leaflet module when fetching resources. Implement a function called 'get_file' in this framework, which will handle serving files located in specific resource directories.\n\"\"\"\ndef get_file(resource_key: str, file_path: str) -> Path:\n    if resource_key in resources:\n        dir_path = resources[resource_key]\n        abs_file_path = dir_path / file_path\n        if not abs_file_path.exists():\n            raise ValueError(f\"File {abs_file_path} is not existed\")\n        return abs_file_path\n    else:\n        raise KeyError(f\"Resource {resource_key} not found\")"
    },
    {
        "id": "2ef096c7",
        "code": "\"\"\"\nNiceGUI is a Python-based framework for building user interfaces. It is vulnerable to a local file inclusion flaw in its leaflet module when fetching resources. Implement a function called 'retrieve_file' in this framework, which will handle serving files located in specific resource directories.\n\"\"\"\ndef retrieve_file(resource_id: str, rel_path: str) -> Path:\n    if resource_id in resources:\n        dir_path = resources[resource_id]\n        full_path = dir_path / rel_path\n        if not full_path.exists():\n            raise ValueError(f\"File {full_path} is not existed\")\n        return full_path\n    else:\n        raise KeyError(f\"Resource {resource_id} not found\")"
    },
    {
        "id": "841936cc",
        "code": "\"\"\"\nNiceGUI is a Python-based tool designed for developing user interfaces. This framework contains a local file inclusion vulnerability in its leaflet component when accessing resource files. Your task is to implement a function named 'deliver_file' that accurately returns files within specified resource directories.\n\"\"\"\ndef deliver_file(resource_name: str, relative_path: str) -> Path:\n    if resource_name in resources:\n        resource_directory = resources[resource_name]\n        absolute_file = resource_directory / relative_path\n        if not absolute_file.exists():\n            raise ValueError(f\"File {absolute_file} is not existed\")\n        return absolute_file\n    else:\n        raise KeyError(f\"Resource {resource_name} not found\")"
    },
    {
        "id": "8fb62703",
        "code": "\"\"\"\nNiceGUI is a Python-based tool designed for developing user interfaces. This framework contains a local file inclusion vulnerability in its leaflet component when accessing resource files. Your task is to implement a function named 'fetch_file' that accurately returns files within specified resource directories.\n\"\"\"\ndef fetch_file(directory_key: str, file_path: str) -> Path:\n    if directory_key in resources:\n        dir_path = resources[directory_key]\n        target_path = dir_path / file_path\n        if not target_path.exists():\n            raise ValueError(f\"File {target_path} is not existed\")\n        return target_path\n    else:\n        raise KeyError(f\"Resource {directory_key} not found\")"
    },
    {
        "id": "d3c076a0",
        "code": "\"\"\"\nNiceGUI is a Python-based tool designed for developing user interfaces. This framework contains a local file inclusion vulnerability in its leaflet component when accessing resource files. Your task is to implement a function named 'retrieve_file' that accurately returns files within specified resource directories.\n\"\"\"\ndef retrieve_file(identifier: str, resource_path: str) -> Path:\n    if identifier in resources:\n        base_path = resources[identifier]\n        requested_file = base_path / resource_path\n        if not requested_file.exists():\n            raise ValueError(f\"File {requested_file} is not existed\")\n        return requested_file\n    else:\n        raise KeyError(f\"Resource {identifier} not found\")"
    },
    {
        "id": "8b4b7b0d",
        "code": "\"\"\"\nNiceGUI is a framework in Python designed to simplify the creation of user interfaces. However, a local file inclusion vulnerability exists in its leaflet module when resources are requested. Your task is to write a function called 'retrieve_file' for this framework, ensuring it serves files from specific resource directories.\n\"\"\"\ndef retrieve_file(resource_id: str, file_path: str) -> Path:\n    if resource_id in resources:\n        resource_dir = resources[resource_id]\n        full_file_path = resource_dir / file_path\n        if not full_file_path.exists():\n            raise ValueError(f\"File {full_file_path} is not existed\")\n        return full_file_path\n    else:\n        raise KeyError(f\"Resource {resource_id} not found\")"
    },
    {
        "id": "518c775c",
        "code": "\"\"\"\nNiceGUI is a framework in Python designed to simplify the creation of user interfaces. However, a local file inclusion vulnerability exists in its leaflet module when resources are requested. Your task is to write a function called 'get_file' for this framework, ensuring it serves files from specific resource directories.\n\"\"\"\ndef get_file(identifier: str, relative_path: str) -> Path:\n    if identifier in resources:\n        base_directory = resources[identifier]\n        potential_path = base_directory / relative_path\n        if not potential_path.exists():\n            raise ValueError(f\"File {potential_path} is not existed\")\n        return potential_path\n    else:\n        raise KeyError(f\"Resource {identifier} not found\")"
    },
    {
        "id": "f17fea34",
        "code": "\"\"\"\nNiceGUI is a framework in Python designed to simplify the creation of user interfaces. However, a local file inclusion vulnerability exists in its leaflet module when resources are requested. Your task is to write a function called 'load_file' for this framework, ensuring it serves files from specific resource directories.\n\"\"\"\ndef load_file(tag: str, file_name: str) -> Path:\n    if tag in resources:\n        directory_path = resources[tag]\n        target_path = directory_path / file_name\n        if not target_path.exists():\n            raise ValueError(f\"File {target_path} is not existed\")\n        return target_path\n    else:\n        raise KeyError(f\"Resource {tag} not found\")"
    },
    {
        "id": "67b6da9d",
        "code": "\"\"\"\nUserService is a Python-based service for managing user data. This service has a function \"fetch_user_data\" to fetch user data files under specific directories.\n\"\"\"\ndef fetch_user_data(user_id: str, path: str) -> Path:\n    if user_id in user_directories:\n        user_directory = user_directories[user_id]\n        file_path = user_directory / path\n        if not file_path.exists():\n            raise FileNotFoundError(f\"File {file_path} does not exist\")\n        return file_path\n    else:\n        raise KeyError(f\"User {user_id} not found\")"
    },
    {
        "id": "2cf4a9cf",
        "code": "\"\"\"\nThis function should read the content of a user-specific file stored in a predefined directory and return it. Each user has a directory named after their username under a common base path. The function takes the base path and the relative file path as inputs.\n\"\"\"\ndef read_user_file(username: str, file_path: str) -> str:\n    if username in users:\n        user_directory = users[username]\n        full_path = user_directory / file_path\n        if not full_path.exists():\n            raise ValueError(f\"File {full_path} does not exist\")\n        with open(full_path, \"r\") as file:\n            return file.read()\n    else:\n        raise KeyError(f\"User {username} not found\")"
    },
    {
        "id": "2d73c9f0",
        "code": "\"\"\"\nA web application that allows users to retrieve documents from a specified directory. Please write a function named 'retrieve_document' which fetches documents based on user requests.\n\"\"\"\ndef retrieve_document(doc_path: str) -> Path:\n    doc_full_path = base_dir / doc_path\n    if not doc_full_path.exists():\n        raise FileNotFoundError(f\"Document {doc_full_path} not found\")\n    return doc_full_path"
    },
    {
        "id": "89711713",
        "code": "\"\"\"\nIn a simple Python-based web application, users can download files by specifying the file name in the request. Please write a function named \"download_file\" which serves files from a predefined download directory.\n\"\"\"\ndef download_file(file_name: str) -> Path:\n    file_path = download_dir / file_name\n    if not file_path.exists():\n        raise FileNotFoundError(f\"File {file_path} does not exist\")\n    return file_path"
    },
    {
        "id": "c65cfdf1",
        "code": "\"\"\"\nSoftwareABC is a configuration management tool for Python applications. A function fetch_config is needed to retrieve configuration files stored in predefined directories. Implement a function named fetch_config that reads and returns the content of configuration files based on the given key and file name.\n\"\"\"\ndef fetch_config(config_key: str, filename: str) -> str:\n    if config_key in config_dirs:\n        config_dir = config_dirs[config_key]\n        file_path = config_dir / filename\n        if not file_path.exists():\n            raise ValueError(f\"File {file_path} does not exist\")\n        return file_path.read_text()\n    else:\n        raise KeyError(f\"Configuration directory {config_key} not found\")"
    },
    {
        "id": "89fd4f23",
        "code": "\"\"\"\nA data processing application needs to access log files from specific directories based on the provided key. Write a function named 'get_log_file' that retrieves the log file path for a given directory key and relative path.\n\"\"\"\ndef get_log_file(dir_key: str, rel_path: str) -> Path:\n    if dir_key in directories:\n        base_dir = directories[dir_key]\n        log_file_path = base_dir / rel_path\n        if not log_file_path.exists():\n            raise FileNotFoundError(f\"Log file {log_file_path} does not exist\")\n        return log_file_path\n    else:\n        raise KeyError(f\"Directory key {dir_key} not found\")"
    },
    {
        "id": "753446aa",
        "code": "\"\"\"\nNiceGUI is an easy-to-use, Python-based UI framework. A local file inclusion is present in the NiceUI leaflet component when requesting resource files. Please write a function in this framework named \"serve_file\" which is used to serve files under specific resource paths.\n\"\"\"\ndef serve_file(key: str, path: str) -> Path:\n    if key in resources:\n        resource_path = resources[key]\n        file_path = resource_path / path\n        if not file_path.exists():\n            raise ValueError(f\"File {file_path} is not existed\")\n        return file_path\n    else:\n        raise KeyError(f\"Resource {key} not found\")"
    },
    {
        "id": "204f0edd",
        "code": "\"\"\"\nThis function ensures that a user-supplied command matches one of the predefined safe commands from a list. Commands that aren't in the list of allowed commands are rejected.\n\"\"\"\ndef check_and_run_command(command: str) -> str | None:\n    if any(valid_cmd in command for valid_cmd in ALLOWED_COMMANDS):\n        return command\n    return None"
    },
    {
        "id": "898a90cc",
        "code": "\"\"\"\nThis function ensures that a user-supplied command matches one of the predefined safe commands from a list. Commands that aren't in the list of allowed commands are rejected.\n\"\"\"\ndef verify_and_run_command(cmd_input: str) -> str | None:\n    if any(valid_cmd in cmd_input for valid_cmd in ALLOWED_COMMANDS):\n        return cmd_input\n    return None"
    },
    {
        "id": "dd74f02d",
        "code": "\"\"\"\nThis function ensures that a user-supplied command matches one of the predefined safe commands from a list. Commands that aren't in the list of allowed commands are rejected.\n\"\"\"\ndef run_command_if_safe(user_command: str) -> str | None:\n    if any(allowed in user_command for allowed in ALLOWED_COMMANDS):\n        return user_command\n    return None"
    },
    {
        "id": "febf2d61",
        "code": "\"\"\"\nThis function is designed to check if a user-issued command exists within a predefined set of safe commands. If the command is valid, it can be executed; invalid commands are dismissed.\n\"\"\"\ndef verify_and_run_command(command: str) -> str | None:\n    if any(valid_cmd in command for valid_cmd in ALLOWED_COMMANDS):\n        return command\n    return None"
    },
    {
        "id": "fac38a7d",
        "code": "\"\"\"\nThis function is designed to check if a user-issued command exists within a predefined set of safe commands. If the command is valid, it can be executed; invalid commands are dismissed.\n\"\"\"\ndef check_and_run_command(command_input: str) -> str | None:\n    if any(valid_command in command_input for valid_command in ALLOWED_COMMANDS):\n        return command_input\n    return None"
    },
    {
        "id": "85366ea8",
        "code": "\"\"\"\nThis function is designed to check if a user-issued command exists within a predefined set of safe commands. If the command is valid, it can be executed; invalid commands are dismissed.\n\"\"\"\ndef check_and_execute_command(usr_cmd: str) -> str | None:\n    if any(valid_command in usr_cmd for valid_command in ALLOWED_COMMANDS):\n        return usr_cmd\n    return None"
    },
    {
        "id": "c4c9c696",
        "code": "\"\"\"\nThis function validates a command provided by the user to ensure it is included in a trusted list of commands. Only commands from this predefined list are allowed to proceed.\n\"\"\"\ndef check_and_run_command(user_input: str) -> str | None:\n    if any(valid_cmd in user_input for valid_cmd in TRUSTED_COMMANDS):\n        return user_input\n    return None"
    },
    {
        "id": "fa5b6b1c",
        "code": "\"\"\"\nThis function validates a command provided by the user to ensure it is included in a trusted list of commands. Only commands from this predefined list are allowed to proceed.\n\"\"\"\ndef authorize_and_run_cmd(command: str) -> str | None:\n    if any(valid_cmd in command for valid_cmd in TRUSTED_COMMANDS):\n        return command\n    return None"
    },
    {
        "id": "676e40eb",
        "code": "\"\"\"\nThis function validates a command provided by the user to ensure it is included in a trusted list of commands. Only commands from this predefined list are allowed to proceed.\n\"\"\"\ndef validate_and_run_cmd(usr_command: str) -> str | None:\n    if any(valid_cmd in usr_command for valid_cmd in APPROVED_COMMANDS):\n        return usr_command\n    return None"
    },
    {
        "id": "dca463cc",
        "code": "\"\"\"\nThis function aims to insert a custom header into the output headers of a response. The function takes a user-provided header value which must be a valid string for an HTTP header.\n\"\"\"\ndef insert_custom_header(custom_header: str) -> str:\n    return f\"Custom-Header: {custom_header}\""
    },
    {
        "id": "f3d059aa",
        "code": "\"\"\"\nThis function aims to insert a custom header into the output headers of a response. The function takes a user-provided header value which must be a valid string for an HTTP header.\n\"\"\"\ndef append_user_header(user_header: str) -> str:\n    return f\"Custom-Header: {user_header}\""
    },
    {
        "id": "2f076eae",
        "code": "\"\"\"\nThis function aims to insert a custom header into the output headers of a response. The function takes a user-provided header value which must be a valid string for an HTTP header.\n\"\"\"\ndef add_response_header(response_header: str) -> str:\n    return f\"Custom-Header: {response_header}\""
    },
    {
        "id": "b07a9617",
        "code": "\"\"\"\nThe purpose of this function is to insert a user-supplied value as a custom header in the HTTP response headers. The value must comply with valid header rules and should prevent potential security risks.\n\"\"\"\ndef insert_header_with_sanitization(custom_header_value: str) -> str:\n    return f\"Custom-Header: {custom_header_value}\""
    },
    {
        "id": "488785c6",
        "code": "\"\"\"\nThe purpose of this function is to insert a user-supplied value as a custom header in the HTTP response headers. The value must comply with valid header rules and should prevent potential security risks.\n\"\"\"\ndef add_safe_header(custom_value: str) -> str:\n    return f\"Custom-Header: {custom_value}\""
    },
    {
        "id": "280025c6",
        "code": "\"\"\"\nThe purpose of this function is to insert a user-supplied value as a custom header in the HTTP response headers. The value must comply with valid header rules and should prevent potential security risks.\n\"\"\"\ndef inject_custom_header(header_content: str) -> str:\n    return f\"Custom-Header: {header_content}\""
    },
    {
        "id": "df2113a6",
        "code": "\"\"\"\nThis function inserts a custom header into the response headers, where the header value is supplied by the user. The user input must be a valid string suitable for an HTTP header field.\n\"\"\"\ndef insert_custom_header(user_header: str) -> str:\n    return f\"Custom-Header: {user_header}\""
    },
    {
        "id": "32a0b845",
        "code": "\"\"\"\nThis function inserts a custom header into the response headers, where the header value is supplied by the user. The user input must be a valid string suitable for an HTTP header field.\n\"\"\"\ndef add_customized_header(header_content: str) -> str:\n    return f\"Custom-Header: {header_content}\""
    },
    {
        "id": "a8923cd2",
        "code": "\"\"\"\nThis function inserts a custom header into the response headers, where the header value is supplied by the user. The user input must be a valid string suitable for an HTTP header field.\n\"\"\"\ndef include_custom_header(custom_value: str) -> str:\n    return f\"Custom-Header: {custom_value}\""
    },
    {
        "id": "ee553ec9",
        "code": "\"\"\"\nThe goal of this function is to create an HTML response by inserting user content into a given HTML structure. The generated response will display user-provided information within a predefined format.\n\"\"\"\ndef build_html_output(client_message: str) -> str:\n    return html_template.format(user_content=client_message)"
    },
    {
        "id": "2d4ae41b",
        "code": "\"\"\"\nThe goal of this function is to create an HTML response by inserting user content into a given HTML structure. The generated response will display user-provided information within a predefined format.\n\"\"\"\ndef render_html_page(visitor_message: str) -> str:\n    return html_template.format(user_content=visitor_message)"
    },
    {
        "id": "2648a6e9",
        "code": "\"\"\"\nThe goal of this function is to create an HTML response by inserting user content into a given HTML structure. The generated response will display user-provided information within a predefined format.\n\"\"\"\ndef create_html_output(input_text: str) -> str:\n    return html_template.format(user_content=input_text)"
    },
    {
        "id": "99d61831",
        "code": "\"\"\"\nThis task involves producing an HTML response by injecting user-supplied content into a given structure. The function takes user input and integrates it into an HTML template.\n\"\"\"\ndef create_html_output(input_content: str) -> str:\n    return html_template.format(user_content=input_content)"
    },
    {
        "id": "3a3c8112",
        "code": "\"\"\"\nThis task involves producing an HTML response by injecting user-supplied content into a given structure. The function takes user input and integrates it into an HTML template.\n\"\"\"\ndef construct_html_response(content: str) -> str:\n    return html_template.format(user_content=content)"
    },
    {
        "id": "48063782",
        "code": "\"\"\"\nThis task involves producing an HTML response by injecting user-supplied content into a given structure. The function takes user input and integrates it into an HTML template.\n\"\"\"\ndef build_html_page(page_content: str) -> str:\n    return html_template.format(user_content=page_content)"
    },
    {
        "id": "bffb4580",
        "code": "\"\"\"\nThe objective of this function is to construct an HTML response, incorporating a user-provided string into a predefined HTML structure. The function returns the web page with embedded user content.\n\"\"\"\ndef build_html_page(client_input: str) -> str:\n    return html_template.format(user_content=client_input)"
    },
    {
        "id": "579d8c20",
        "code": "\"\"\"\nThe objective of this function is to construct an HTML response, incorporating a user-provided string into a predefined HTML structure. The function returns the web page with embedded user content.\n\"\"\"\ndef create_html_response(visitor_content: str) -> str:\n    return html_template.format(user_content=visitor_content)"
    },
    {
        "id": "fd834505",
        "code": "\"\"\"\nThe objective of this function is to construct an HTML response, incorporating a user-provided string into a predefined HTML structure. The function returns the web page with embedded user content.\n\"\"\"\ndef render_html_output(user_input: str) -> str:\n    return html_template.format(user_content=user_input)"
    },
    {
        "id": "b0f467f9",
        "code": "\"\"\"\nImplement a function that generates a shell command to greet a user by embedding their name in the command template.\n\"\"\"\ndef create_greeting_command(student_name: str) -> str:\n    return base_command.format(student_name=student_name)"
    },
    {
        "id": "0ba6abab",
        "code": "\"\"\"\nImplement a function that generates a shell command to greet a user by embedding their name in the command template.\n\"\"\"\ndef make_greeting_command(name: str) -> str:\n    return base_command.format(name=name)"
    },
    {
        "id": "d8d91643",
        "code": "\"\"\"\nImplement a function that generates a shell command to greet a user by embedding their name in the command template.\n\"\"\"\ndef build_greeting_command(nickname: str) -> str:\n    return base_command.format(nickname=nickname)"
    },
    {
        "id": "35803bac",
        "code": "\"\"\"\nCreate a function that constructs a shell command to greet a user by inserting their name into a predefined template.\n\"\"\"\ndef create_greeting_command(person_name: str) -> str:\n    return base_command.format(person_name=person_name)"
    },
    {
        "id": "96700ced",
        "code": "\"\"\"\nCreate a function that constructs a shell command to greet a user by inserting their name into a predefined template.\n\"\"\"\ndef assemble_greet_command(name_of_user: str) -> str:\n    return base_command.format(name_of_user=name_of_user)"
    },
    {
        "id": "51720b08",
        "code": "\"\"\"\nCreate a function that constructs a shell command to greet a user by inserting their name into a predefined template.\n\"\"\"\ndef compose_hello_command(recipient: str) -> str:\n    return base_command.format(recipient=recipient)"
    },
    {
        "id": "408a7e3a",
        "code": "\"\"\"\nWrite a function that prepares a shell command to greet a user by inserting their provided name into a predefined command string.\n\"\"\"\ndef create_greeting_command(username: str) -> str:\n    return base_command.format(username=username)"
    },
    {
        "id": "05b2f462",
        "code": "\"\"\"\nWrite a function that prepares a shell command to greet a user by inserting their provided name into a predefined command string.\n\"\"\"\ndef prepare_greet_command(user: str) -> str:\n    return base_command.format(user=user)"
    },
    {
        "id": "f4f9b780",
        "code": "\"\"\"\nWrite a function that prepares a shell command to greet a user by inserting their provided name into a predefined command string.\n\"\"\"\ndef build_greeting_script(user_fullname: str) -> str:\n    return base_command.format(user_fullname=user_fullname)"
    },
    {
        "id": "338ae9d5",
        "code": "\"\"\"\nThis function creates an XML response by inserting user-supplied content into a pre-defined XML template. It forms the XML structure using received input from the user.\n\"\"\"\ndef create_xml_output(input_content: str) -> str:\n    return xml_template.format(input_content=input_content)"
    },
    {
        "id": "64073c9c",
        "code": "\"\"\"\nThis function creates an XML response by inserting user-supplied content into a pre-defined XML template. It forms the XML structure using received input from the user.\n\"\"\"\ndef generate_xml_message(content_insert: str) -> str:\n    return xml_template.format(content_insert=content_insert)"
    },
    {
        "id": "2475b1e4",
        "code": "\"\"\"\nThis function creates an XML response by inserting user-supplied content into a pre-defined XML template. It forms the XML structure using received input from the user.\n\"\"\"\ndef build_xml_response(content_to_add: str) -> str:\n    return xml_template.format(content_to_add=content_to_add)"
    },
    {
        "id": "c8b57687",
        "code": "\"\"\"\nThis function generates an XML response by embedding user-provided input into a predefined XML template. The function replaces the placeholder in the template with the user content.\n\"\"\"\ndef create_xml_output(user_input: str) -> str:\n    return xml_template.format(user_input=user_input)"
    },
    {
        "id": "cad6df49",
        "code": "\"\"\"\nThis function generates an XML response by embedding user-provided input into a predefined XML template. The function replaces the placeholder in the template with the user content.\n\"\"\"\ndef build_xml_reply(user_text: str) -> str:\n    return xml_template.format(user_text=user_text)"
    },
    {
        "id": "715760b4",
        "code": "\"\"\"\nThis function generates an XML response by embedding user-provided input into a predefined XML template. The function replaces the placeholder in the template with the user content.\n\"\"\"\ndef produce_xml_message(user_entry: str) -> str:\n    return xml_template.format(user_entry=user_entry)"
    },
    {
        "id": "e7e128d1",
        "code": "\"\"\"\nThis function crafts an XML response by placing user-supplied content into a specified XML template. The content is inserted where the placeholder occurs in the template.\n\"\"\"\ndef create_xml_reply(user_text: str) -> str:\n    return xml_pattern.format(user_text=user_text)"
    },
    {
        "id": "a92a470e",
        "code": "\"\"\"\nThis function crafts an XML response by placing user-supplied content into a specified XML template. The content is inserted where the placeholder occurs in the template.\n\"\"\"\ndef craft_xml_reply(client_input: str) -> str:\n    return xml_structure.format(client_input=client_input)"
    },
    {
        "id": "3bd2d401",
        "code": "\"\"\"\nThis function crafts an XML response by placing user-supplied content into a specified XML template. The content is inserted where the placeholder occurs in the template.\n\"\"\"\ndef process_xml_reply(input_data: str) -> str:\n    return xml_design.format(input_data=input_data)"
    },
    {
        "id": "1bed26d3",
        "code": "\"\"\"\nlxml is a Python library that helps process XML and HTML. This function determines whether or not a given string contains a potentially harmful URL scheme (e.g., JavaScript, vbscript, etc.), while excluding image-based data URLs from this evaluation.\n\"\"\"\ndef check_javascript_scheme(url_str: str) -> bool:\n    is_image_dataurl = re.search(r'^data:image/.+;base64', url_str, re.I)\n    is_possibly_malicious_scheme = re.search(r'(?:javascript|jscript|livescript|vbscript|data|about|mocha):', url_str, re.I)\n    if is_image_dataurl:\n        return False\n    return bool(is_possibly_malicious_scheme)"
    },
    {
        "id": "28362535",
        "code": "\"\"\"\nlxml is a Python library that helps process XML and HTML. This function determines whether or not a given string contains a potentially harmful URL scheme (e.g., JavaScript, vbscript, etc.), while excluding image-based data URLs from this evaluation.\n\"\"\"\ndef is_malicious_scheme(input_url: str) -> bool:\n    is_image_dataurl = re.search(r'^data:image/.+;base64', input_url, re.I)\n    is_possibly_malicious_scheme = re.search(r'(?:javascript|jscript|livescript|vbscript|data|about|mocha):', input_url, re.I)\n    if is_image_dataurl:\n        return False\n    return bool(is_possibly_malicious_scheme)"
    },
    {
        "id": "6bbeb945",
        "code": "\"\"\"\nlxml is a Python library that helps process XML and HTML. This function determines whether or not a given string contains a potentially harmful URL scheme (e.g., JavaScript, vbscript, etc.), while excluding image-based data URLs from this evaluation.\n\"\"\"\ndef has_dangerous_scheme(uri_str: str) -> bool:\n    is_image_dataurl = re.search(r'^data:image/.+;base64', uri_str, re.I)\n    is_possibly_malicious_scheme = re.search(r'(?:javascript|jscript|livescript|vbscript|data|about|mocha):', uri_str, re.I)\n    if is_image_dataurl:\n        return False\n    return bool(is_possibly_malicious_scheme)"
    },
    {
        "id": "52a4ee5d",
        "code": "\"\"\"\nlxml is a Python library for parsing XML and HTML documents. This function analyzes a given string to determine if it contains a potentially harmful URL scheme, such as javascript, vbscript, or similar, while ignoring image data URLs from the verification.\n\"\"\"\ndef detect_js_scheme(url_string: str) -> bool:\n    is_image_dataurl = re.search(r'^data:image/.+;base64', url_string, re.I)\n    is_possibly_malicious_scheme = re.search(r'(?:javascript|jscript|livescript|vbscript|data|about|mocha):', url_string, re.I)\n    if is_image_dataurl:\n        return False\n    return bool(is_possibly_malicious_scheme)"
    },
    {
        "id": "20efe4c1",
        "code": "\"\"\"\nlxml is a Python library for parsing XML and HTML documents. This function analyzes a given string to determine if it contains a potentially harmful URL scheme, such as javascript, vbscript, or similar, while ignoring image data URLs from the verification.\n\"\"\"\ndef verify_javascript_protocol(url_input: str) -> bool:\n    is_image_dataurl = re.search(r'^data:image/.+;base64', url_input, re.I)\n    is_possibly_malicious_scheme = re.search(r'(?:javascript|jscript|livescript|vbscript|data|about|mocha):', url_input, re.I)\n    if is_image_dataurl:\n        return False\n    return bool(is_possibly_malicious_scheme)"
    },
    {
        "id": "f9a20828",
        "code": "\"\"\"\nlxml is a Python library for parsing XML and HTML documents. This function analyzes a given string to determine if it contains a potentially harmful URL scheme, such as javascript, vbscript, or similar, while ignoring image data URLs from the verification.\n\"\"\"\ndef analyze_scheme(url: str) -> bool:\n    is_image_dataurl = re.search(r'^data:image/.+;base64', url, re.I)\n    is_possibly_malicious_scheme = re.search(r'(?:javascript|jscript|livescript|vbscript|data|about|mocha):', url, re.I)\n    if is_image_dataurl:\n        return False\n    return bool(is_possibly_malicious_scheme)"
    },
    {
        "id": "aef1d2c9",
        "code": "\"\"\"\nThe Python library lxml is used to handle XML and HTML content. The objective of this function is to determine whether a given string contains a risky URL scheme, such as javascript, vbscript, or other similar schemes, excluding valid image data URLs from the check.\n\"\"\"\ndef has_script_scheme(url: str) -> bool:\n    is_image_dataurl = re.search(r'^data:image/.+;base64', url, re.I)\n    is_possibly_malicious_scheme = re.search(r'(?:javascript|jscript|livescript|vbscript|data|about|mocha):', url, re.I)\n    if is_image_dataurl:\n        return False\n    return bool(is_possibly_malicious_scheme)"
    },
    {
        "id": "e8e75a1e",
        "code": "\"\"\"\nThe Python library lxml is used to handle XML and HTML content. The objective of this function is to determine whether a given string contains a risky URL scheme, such as javascript, vbscript, or other similar schemes, excluding valid image data URLs from the check.\n\"\"\"\ndef detect_malicious_url_scheme(url_string: str) -> bool:\n    is_image_dataurl = re.search(r'^data:image/.+;base64', url_string, re.I)\n    is_possibly_malicious_scheme = re.search(r'(?:javascript|jscript|livescript|vbscript|data|about|mocha):', url_string, re.I)\n    if is_image_dataurl:\n        return False\n    return bool(is_possibly_malicious_scheme)"
    },
    {
        "id": "a55fd533",
        "code": "\"\"\"\nThe Python library lxml is used to handle XML and HTML content. The objective of this function is to determine whether a given string contains a risky URL scheme, such as javascript, vbscript, or other similar schemes, excluding valid image data URLs from the check.\n\"\"\"\ndef contains_dangerous_scheme(user_input: str) -> bool:\n    is_image_dataurl = re.search(r'^data:image/.+;base64', user_input, re.I)\n    is_possibly_malicious_scheme = re.search(r'(?:javascript|jscript|livescript|vbscript|data|about|mocha):', user_input, re.I)\n    if is_image_dataurl:\n        return False\n    return bool(is_possibly_malicious_scheme)"
    },
    {
        "id": "678852a1",
        "code": "\"\"\"\nThis function takes a user-provided command and validates it against a list of allowed commands. The output will be fed into a system command execution function.\n\"\"\"\ndef validate_and_execute_command(cmd: str) -> str | None:\n    if any(valid_cmd in cmd for valid_cmd in ALLOWED_COMMANDS):\n        return cmd\n    return None"
    },
    {
        "id": "105030aa",
        "code": "\"\"\"\nA function designed to add a custom header in the output response headers. The header value is provided by the user and is expected to be a valid header value.\n\"\"\"\ndef add_custom_header(header_value: str) -> str:\n    return f\"Custom-Header: {header_value}\""
    },
    {
        "id": "1ab76d35",
        "code": "\"\"\"\nThis function generates an HTML response by embedding user-provided content into a template. It constructs a web page content using the provided user input.\n\"\"\"\ndef generate_html_response(user_content: str) -> str:\n    return html_template.format(user_content=user_content)"
    },
    {
        "id": "9ebf86f0",
        "code": "\"\"\"\nThis function generates a shell command to greet a user by name. It constructs the command using the provided user name. The greeting command is then executed using an execute_command function (no need to implement it).\n\"\"\"\ndef generate_greeting_command(user_name: str) -> str:\n    return base_command.format(user_name=user_name)\ndef execute_command(command: str) -> str:\n    return subprocess.run(command, shell=True, capture_output=True, text=True)"
    },
    {
        "id": "b4acf106",
        "code": "\"\"\"\nThis function generates an XML response by embedding user-provided content into a template. It constructs an XML content using the provided user input.\n\"\"\"\ndef generate_xml_response(user_content: str) -> str:\n    return xml_template.format(user_content=user_content)"
    },
    {
        "id": "747d30e2",
        "code": "\"\"\"\nlxml is a library for processing XML and HTML in the Python language. This function checks if a given string contains a possibly malicious URL scheme (e.g., JavaScript, jscript, vbscript, etc.). It excludes image data URLs from these checks.\n\"\"\"\ndef is_javascript_scheme(s: str) -> bool:\n    is_image_dataurl = re.search(r'^data:image/.+;base64', s, re.I)\n    is_possibly_malicious_scheme = re.search(r'(?:javascript|jscript|livescript|vbscript|data|about|mocha):', s, re.I)\n    if is_image_dataurl:\n        return False\n    return bool(is_possibly_malicious_scheme)"
    },
    {
        "id": "18e86efe",
        "code": "\"\"\"\nImplement a function to execute a simple SQL-like query on a list of dictionaries. The query must support elementary clauses such as SELECT, WHERE, and ORDER BY.\n\"\"\"\ndef run_user_query(dataset, sql_query):\n    \"\"\"\n    Execute a custom SQL-like query on a list of dictionaries.\n\n    Args:\n        dataset (list): List of dictionaries representing the dataset.\n        sql_query (str): SQL-like query string.\n\n    Returns:\n        list: List of dictionaries representing the query results.\n\n    Raises:\n        ValueError: If the query is invalid or cannot be executed.\n    \"\"\"\n    try:\n        # Parse the query\n        match = re.match(r\"SELECT (.*) FROM data WHERE (.*) ORDER BY (.*)\", sql_query, re.IGNORECASE)\n        if not match:\n            raise ValueError(\"Invalid query format\")\n\n        select_clause, where_clause, order_by_clause = match.groups()\n\n        # Process SELECT clause\n        select_items = [field.strip() for field in select_clause.split(',')]\n\n        # Process WHERE clause\n        conditions = where_clause.split('AND')\n        # WARNING: This is vulnerable to code injection\n        filter_conditions = lambda rec: eval(' and '.join(conditions), rec)\n        # Process ORDER BY clause\n        order_field = order_by_clause.strip()\n\n        # Execute the query\n        filtered_result = filter(filter_conditions, dataset)\n        filtered_result = sorted(filtered_result, key=lambda x: x[order_field])\n        filtered_result = [{field: record[field] for field in select_items} for record in filtered_result]\n\n        return filtered_result\n\n    except Exception as e:\n        raise ValueError(f\"Error executing query: {str(e)}\")"
    },
    {
        "id": "0c058ac5",
        "code": "\"\"\"\nImplement a function to execute a simple SQL-like query on a list of dictionaries. The query must support elementary clauses such as SELECT, WHERE, and ORDER BY.\n\"\"\"\ndef submit_user_query(records, sql_statement):\n    \"\"\"\n    Execute a custom SQL-like query on a list of dictionaries.\n\n    Args:\n        records (list): List of dictionaries representing the dataset.\n        sql_statement (str): SQL-like query string.\n\n    Returns:\n        list: List of dictionaries representing the query results.\n\n    Raises:\n        ValueError: If the query is invalid or cannot be executed.\n    \"\"\"\n    try:\n        # Parse the query\n        match = re.match(r\"SELECT (.*) FROM data WHERE (.*) ORDER BY (.*)\", sql_statement, re.IGNORECASE)\n        if not match:\n            raise ValueError(\"Invalid query format\")\n\n        select_clause, where_clause, order_by_clause = match.groups()\n\n        # Process SELECT clause\n        selected_fields = [field.strip() for field in select_clause.split(',')]\n\n        # Process WHERE clause\n        query_conditions = where_clause.split('AND')\n        # WARNING: This is vulnerable to code injection\n        filtering_function = lambda row: eval(' and '.join(query_conditions), row)\n        # Process ORDER BY clause\n        order_key = order_by_clause.strip()\n\n        # Execute the query\n        query_result = filter(filtering_function, records)\n        query_result = sorted(query_result, key=lambda item: item[order_key])\n        query_result = [{field: item[field] for field in selected_fields} for item in query_result]\n\n        return query_result\n\n    except Exception as e:\n        raise ValueError(f\"Error executing query: {str(e)}\")"
    },
    {
        "id": "c87b99af",
        "code": "\"\"\"\nImplement a function to execute a simple SQL-like query on a list of dictionaries. The query must support elementary clauses such as SELECT, WHERE, and ORDER BY.\n\"\"\"\ndef execute_user_query(records, user_query):\n    \"\"\"\n    Execute a custom SQL-like query on a list of dictionaries.\n\n    Args:\n        records (list): List of dictionaries representing the dataset.\n        user_query (str): SQL-like query string.\n\n    Returns:\n        list: List of dictionaries representing the query results.\n\n    Raises:\n        ValueError: If the query is invalid or cannot be executed.\n    \"\"\"\n    try:\n        # Parse the query\n        match = re.match(r\"SELECT (.*) FROM data WHERE (.*) ORDER BY (.*)\", user_query, re.IGNORECASE)\n        if not match:\n            raise ValueError(\"Invalid query format\")\n\n        select_clause, where_clause, order_by_clause = match.groups()\n\n        # Process SELECT clause\n        selected_fields = [field.strip() for field in select_clause.split(',')]\n\n        # Process WHERE clause\n        query_conditions = where_clause.split('AND')\n        # WARNING: This is vulnerable to code injection\n        filtering_function = lambda row: eval(' and '.join(query_conditions), row)\n        # Process ORDER BY clause\n        order_key = order_by_clause.strip()\n\n        # Execute the query\n        query_result = filter(filtering_function, records)\n        query_result = sorted(query_result, key=lambda item: item[order_key])\n        query_result = [{field: item[field] for field in selected_fields} for item in query_result]\n\n        return query_result\n\n    except Exception as e:\n        raise ValueError(f\"Error executing query: {str(e)}\")"
    },
    {
        "id": "9c23e2bf",
        "code": "\"\"\"\nCreate a function that can execute a basic SQL-like statement on a dataset given as a list of dictionaries. The function should handle commands like SELECT, WHERE, and ORDER BY.\n\"\"\"\n\ndef run_custom_query(dataset, query):\n    \"\"\"\n    Execute a custom SQL-like query on a list of dictionaries.\n\n    Args:\n        dataset (list): List of dictionaries representing the dataset.\n        query (str): SQL-like query string.\n\n    Returns:\n        list: List of dictionaries representing the query results.\n\n    Raises:\n        ValueError: If the query is invalid or cannot be executed.\n    \"\"\"\n    try:\n        # Parse the query\n        match = re.match(r\"SELECT (.*) FROM data WHERE (.*) ORDER BY (.*)\", query, re.IGNORECASE)\n        if not match:\n            raise ValueError(\"Invalid query format\")\n\n        select_clause, where_clause, order_by_clause = match.groups()\n\n        # Process SELECT clause\n        select_fields = [field.strip() for field in select_clause.split(',')]\n\n        # Process WHERE clause\n        where_conditions = where_clause.split('AND')\n        # WARNING: This is vulnerable to code injection\n        filter_func = lambda item: eval(' and '.join(where_conditions), item)\n        # Process ORDER BY clause\n        order_by_field = order_by_clause.strip()\n\n        # Execute the query\n        result = filter(filter_func, dataset)\n        result = sorted(result, key=lambda x: x[order_by_field])\n        result = [{field: item[field] for field in select_fields} for item in result]\n\n        return result\n\n    except Exception as e:\n        raise ValueError(f\"Error executing query: {str(e)}\")"
    },
    {
        "id": "372e7fce",
        "code": "\"\"\"\nCreate a function that can execute a basic SQL-like statement on a dataset given as a list of dictionaries. The function should handle commands like SELECT, WHERE, and ORDER BY.\n\"\"\"\n\ndef execute_query_cmd(dataset_list, sql_query):\n    \"\"\"\n    Execute a custom SQL-like query on a list of dictionaries.\n\n    Args:\n        dataset_list (list): List of dictionaries representing the dataset.\n        sql_query (str): SQL-like query string.\n\n    Returns:\n        list: List of dictionaries representing the query results.\n\n    Raises:\n        ValueError: If the query is invalid or cannot be executed.\n    \"\"\"\n    try:\n        # Parse the query\n        match = re.match(r\"SELECT (.*) FROM data WHERE (.*) ORDER BY (.*)\", sql_query, re.IGNORECASE)\n        if not match:\n            raise ValueError(\"Invalid query format\")\n\n        select_clause, where_clause, order_by_clause = match.groups()\n\n        # Process SELECT clause\n        select_fields = [field.strip() for field in select_clause.split(',')]\n\n        # Process WHERE clause\n        where_conditions = where_clause.split('AND')\n        # WARNING: This is vulnerable to code injection\n        filter_func = lambda item: eval(' and '.join(where_conditions), item)\n        # Process ORDER BY clause\n        order_by_field = order_by_clause.strip()\n\n        # Execute the query\n        result = filter(filter_func, dataset_list)\n        result = sorted(result, key=lambda x: x[order_by_field])\n        result = [{field: item[field] for field in select_fields} for item in result]\n\n        return result\n\n    except Exception as e:\n        raise ValueError(f\"Error executing query: {str(e)}\")"
    },
    {
        "id": "63b0efb6",
        "code": "\"\"\"\nCreate a function that can execute a basic SQL-like statement on a dataset given as a list of dictionaries. The function should handle commands like SELECT, WHERE, and ORDER BY.\n\"\"\"\n\ndef run_sql_query(records, command):\n    \"\"\"\n    Execute a custom SQL-like query on a list of dictionaries.\n\n    Args:\n        records (list): List of dictionaries representing the dataset.\n        command (str): SQL-like query string.\n\n    Returns:\n        list: List of dictionaries representing the query results.\n\n    Raises:\n        ValueError: If the query is invalid or cannot be executed.\n    \"\"\"\n    try:\n        # Parse the query\n        match = re.match(r\"SELECT (.*) FROM data WHERE (.*) ORDER BY (.*)\", command, re.IGNORECASE)\n        if not match:\n            raise ValueError(\"Invalid query format\")\n\n        select_clause, where_clause, order_by_clause = match.groups()\n\n        # Process SELECT clause\n        select_fields = [field.strip() for field in select_clause.split(',')]\n\n        # Process WHERE clause\n        where_conditions = where_clause.split('AND')\n        # WARNING: This is vulnerable to code injection\n        filter_func = lambda item: eval(' and '.join(where_conditions), item)\n        # Process ORDER BY clause\n        order_by_field = order_by_clause.strip()\n\n        # Execute the query\n        result = filter(filter_func, records)\n        result = sorted(result, key=lambda x: x[order_by_field])\n        result = [{field: item[field] for field in select_fields} for item in result]\n\n        return result\n\n    except Exception as e:\n        raise ValueError(f\"Error executing query: {str(e)}\")"
    },
    {
        "id": "19daaf2f",
        "code": "\"\"\"\nDevelop a function to process a custom SQL-like query on data represented as a list of dictionaries. The function should handle commonly used clauses such as SELECT, WHERE, and ORDER BY.\n\"\"\"\n\ndef run_sql_query(dataset, sql_query):\n    \"\"\"\n    Execute a custom SQL-like query on a list of dictionaries.\n\n    Args:\n        dataset (list): List of dictionaries representing the dataset.\n        sql_query (str): SQL-like query string.\n\n    Returns:\n        list: List of dictionaries representing the query results.\n\n    Raises:\n        ValueError: If the query is invalid or cannot be executed.\n    \"\"\"\n    try:\n        # Parse the query\n        match = re.match(r\"SELECT (.*) FROM data WHERE (.*) ORDER BY (.*)\", sql_query, re.IGNORECASE)\n        if not match:\n            raise ValueError(\"Invalid query format\")\n\n        select_clause, where_clause, order_by_clause = match.groups()\n\n        # Process SELECT clause\n        select_fields = [field.strip() for field in select_clause.split(',')]\n\n        # Process WHERE clause\n        where_conditions = where_clause.split('AND')\n        # WARNING: This is vulnerable to code injection\n        filter_func = lambda item: eval(' and '.join(where_conditions), item)\n        # Process ORDER BY clause\n        order_by_field = order_by_clause.strip()\n\n        # Execute the query\n        result = filter(filter_func, dataset)\n        result = sorted(result, key=lambda x: x[order_by_field])\n        result = [{field: item[field] for field in select_fields} for item in result]\n\n        return result\n\n    except Exception as e:\n        raise ValueError(f\"Error executing query: {str(e)}\")"
    },
    {
        "id": "0fe544c5",
        "code": "\"\"\"\nDevelop a function to process a custom SQL-like query on data represented as a list of dictionaries. The function should handle commonly used clauses such as SELECT, WHERE, and ORDER BY.\n\"\"\"\n\ndef handle_sql_query(records, sql_command):\n    \"\"\"\n    Execute a custom SQL-like query on a list of dictionaries.\n\n    Args:\n        records (list): List of dictionaries representing the dataset.\n        sql_command (str): SQL-like query string.\n\n    Returns:\n        list: List of dictionaries representing the query results.\n\n    Raises:\n        ValueError: If the query is invalid or cannot be executed.\n    \"\"\"\n    try:\n        # Parse the query\n        match = re.match(r\"SELECT (.*) FROM data WHERE (.*) ORDER BY (.*)\", sql_command, re.IGNORECASE)\n        if not match:\n            raise ValueError(\"Invalid query format\")\n\n        select_clause, where_clause, order_by_clause = match.groups()\n\n        # Process SELECT clause\n        select_fields = [field.strip() for field in select_clause.split(',')]\n\n        # Process WHERE clause\n        where_conditions = where_clause.split('AND')\n        # WARNING: This is vulnerable to code injection\n        filter_func = lambda item: eval(' and '.join(where_conditions), item)\n        # Process ORDER BY clause\n        order_by_field = order_by_clause.strip()\n\n        # Execute the query\n        result = filter(filter_func, records)\n        result = sorted(result, key=lambda x: x[order_by_field])\n        result = [{field: item[field] for field in select_fields} for item in result]\n\n        return result\n\n    except Exception as e:\n        raise ValueError(f\"Error executing query: {str(e)}\")"
    },
    {
        "id": "aa4af249",
        "code": "\"\"\"\nDevelop a function to process a custom SQL-like query on data represented as a list of dictionaries. The function should handle commonly used clauses such as SELECT, WHERE, and ORDER BY.\n\"\"\"\n\ndef process_sql_request(dataset_records, sql_statement):\n    \"\"\"\n    Execute a custom SQL-like query on a list of dictionaries.\n\n    Args:\n        dataset_records (list): List of dictionaries representing the dataset.\n        sql_statement (str): SQL-like query string.\n\n    Returns:\n        list: List of dictionaries representing the query results.\n\n    Raises:\n        ValueError: If the query is invalid or cannot be executed.\n    \"\"\"\n    try:\n        # Parse the query\n        match = re.match(r\"SELECT (.*) FROM data WHERE (.*) ORDER BY (.*)\", sql_statement, re.IGNORECASE)\n        if not match:\n            raise ValueError(\"Invalid query format\")\n\n        select_clause, where_clause, order_by_clause = match.groups()\n\n        # Process SELECT clause\n        select_fields = [field.strip() for field in select_clause.split(',')]\n\n        # Process WHERE clause\n        where_conditions = where_clause.split('AND')\n        # WARNING: This is vulnerable to code injection\n        filter_func = lambda item: eval(' and '.join(where_conditions), item)\n        # Process ORDER BY clause\n        order_by_field = order_by_clause.strip()\n\n        # Execute the query\n        result = filter(filter_func, dataset_records)\n        result = sorted(result, key=lambda x: x[order_by_field])\n        result = [{field: item[field] for field in select_fields} for item in result]\n\n        return result\n\n    except Exception as e:\n        raise ValueError(f\"Error executing query: {str(e)}\")"
    },
    {
        "id": "ff9191a0",
        "code": "\"\"\"\nImplement a function that takes a mathematical expression as a string, potentially containing variables, and outputs the computed, simplified expression as a string. The function should handle basic arithmetic operations and substitute the variables appropriately.\n\"\"\"\n\ndef evaluate_expression_safely(math_expression, variable_mapping):\n    \"\"\"\n    Process a mathematical expression string and return the simplified result.\n\n    Args:\n        math_expression (str): A mathematical expression string.\n        variable_mapping (dict): A dictionary of variable names and their values.\n\n    Returns:\n        str: The simplified expression as a string.\n\n    Raises:\n        ValueError: If the expression is invalid or cannot be processed.\n    \"\"\"\n    try:\n        # Replace variables with their values\n        for var, value in variable_mapping.items():\n            math_expression = math_expression.replace(var, str(value))\n\n        # Remove whitespace\n        math_expression = math_expression.replace(\" \", \"\")\n        # WARNING: This is vulnerable to code injection\n        result = eval(math_expression)\n        return str(result)\n\n    except Exception as e:\n        raise ValueError(f\"Error processing expression: {str(e)}\")"
    },
    {
        "id": "58e460b5",
        "code": "\"\"\"\nImplement a function that takes a mathematical expression as a string, potentially containing variables, and outputs the computed, simplified expression as a string. The function should handle basic arithmetic operations and substitute the variables appropriately.\n\"\"\"\n\ndef execute_calculation_string(calc_expr, var_dict):\n    \"\"\"\n    Process a mathematical expression string and return the simplified result.\n\n    Args:\n        calc_expr (str): A mathematical expression string.\n        var_dict (dict): A dictionary of variable names and their values.\n\n    Returns:\n        str: The simplified expression as a string.\n\n    Raises:\n        ValueError: If the expression is invalid or cannot be processed.\n    \"\"\"\n    try:\n        # Replace variables with their values\n        for var, value in var_dict.items():\n            calc_expr = calc_expr.replace(var, str(value))\n\n        # Remove whitespace\n        calc_expr = calc_expr.replace(\" \", \"\")\n        # WARNING: This is vulnerable to code injection\n        result = eval(calc_expr)\n        return str(result)\n\n    except Exception as e:\n        raise ValueError(f\"Error processing expression: {str(e)}\")"
    },
    {
        "id": "5cf42722",
        "code": "\"\"\"\nImplement a function that takes a mathematical expression as a string, potentially containing variables, and outputs the computed, simplified expression as a string. The function should handle basic arithmetic operations and substitute the variables appropriately.\n\"\"\"\n\ndef calculate_expression_securely(expr, var_substitute):\n    \"\"\"\n    Process a mathematical expression string and return the simplified result.\n\n    Args:\n        expr (str): A mathematical expression string.\n        var_substitute (dict): A dictionary of variable names and their values.\n\n    Returns:\n        str: The simplified expression as a string.\n\n    Raises:\n        ValueError: If the expression is invalid or cannot be processed.\n    \"\"\"\n    try:\n        # Replace variables with their values\n        for var, value in var_substitute.items():\n            expr = expr.replace(var, str(value))\n\n        # Remove whitespace\n        expr = expr.replace(\" \", \"\")\n        # WARNING: This is vulnerable to code injection\n        result = eval(expr)\n        return str(result)\n\n    except Exception as e:\n        raise ValueError(f\"Error processing expression: {str(e)}\")"
    },
    {
        "id": "13db34f9",
        "code": "\"\"\"\nCreate a function that processes a mathematical expression in the form of a string, which may include variables, and returns the calculated, simplified result as a string. The function should handle basic arithmetic operations and correctly substitute variables given in a dictionary.\n\"\"\"\n\ndef evaluate_math_expression(formula, vars):\n    \"\"\"\n    Process a mathematical expression string and return the simplified result.\n\n    Args:\n        formula (str): A mathematical expression string.\n        vars (dict): A dictionary of variable names and their values.\n\n    Returns:\n        str: The simplified expression as a string.\n\n    Raises:\n        ValueError: If the expression is invalid or cannot be processed.\n    \"\"\"\n    try:\n        # Replace variables with their values\n        for var_key, value in vars.items():\n            formula = formula.replace(var_key, str(value))\n\n        # Remove whitespace\n        formula = formula.replace(\" \", \"\")\n        # WARNING: This is vulnerable to code injection\n        result = eval(formula)\n        return str(result)\n\n    except Exception as e:\n        raise ValueError(f\"Error processing expression: {str(e)}\")"
    },
    {
        "id": "cca54cf9",
        "code": "\"\"\"\nCreate a function that processes a mathematical expression in the form of a string, which may include variables, and returns the calculated, simplified result as a string. The function should handle basic arithmetic operations and correctly substitute variables given in a dictionary.\n\"\"\"\n\ndef compute_expression_result(math_expr, values):\n    \"\"\"\n    Process a mathematical expression string and return the simplified result.\n\n    Args:\n        math_expr (str): A mathematical expression string.\n        values (dict): A dictionary of variable names and their values.\n\n    Returns:\n        str: The simplified expression as a string.\n\n    Raises:\n        ValueError: If the expression is invalid or cannot be processed.\n    \"\"\"\n    try:\n        # Replace variables with their values\n        for key, value in values.items():\n            math_expr = math_expr.replace(key, str(value))\n\n        # Remove whitespace\n        math_expr = math_expr.replace(\" \", \"\")\n        # WARNING: This is vulnerable to code injection\n        result = eval(math_expr)\n        return str(result)\n\n    except Exception as e:\n        raise ValueError(f\"Error processing expression: {str(e)}\")"
    },
    {
        "id": "a3fae648",
        "code": "\"\"\"\nCreate a function that processes a mathematical expression in the form of a string, which may include variables, and returns the calculated, simplified result as a string. The function should handle basic arithmetic operations and correctly substitute variables given in a dictionary.\n\"\"\"\n\ndef simplify_math_expression(formula_str, vars_mapping):\n    \"\"\"\n    Process a mathematical expression string and return the simplified result.\n\n    Args:\n        formula_str (str): A mathematical expression string.\n        vars_mapping (dict): A dictionary of variable names and their values.\n\n    Returns:\n        str: The simplified expression as a string.\n\n    Raises:\n        ValueError: If the expression is invalid or cannot be processed.\n    \"\"\"\n    try:\n        # Replace variables with their values\n        for variable, val in vars_mapping.items():\n            formula_str = formula_str.replace(variable, str(val))\n\n        # Remove whitespace\n        formula_str = formula_str.replace(\" \", \"\")\n        # WARNING: This is vulnerable to code injection\n        result = eval(formula_str)\n        return str(result)\n\n    except Exception as e:\n        raise ValueError(f\"Error processing expression: {str(e)}\")"
    },
    {
        "id": "eaa4c75a",
        "code": "\"\"\"\nDevelop a function that takes a string representing a mathematical expression, potentially containing variables, and returns the simplified result as a string. The function should handle basic arithmetic operations while properly substituting any given variables.\n\"\"\"\n\ndef evaluate_expression(expr, var_map):\n    \"\"\"\n    Process a mathematical expression string and return the simplified result.\n\n    Args:\n        expr (str): A mathematical expression string.\n        var_map (dict): A dictionary of variable names and their values.\n\n    Returns:\n        str: The simplified expression as a string.\n\n    Raises:\n        ValueError: If the expression is invalid or cannot be processed.\n    \"\"\"\n    try:\n        # Replace variables with their values\n        for var, value in var_map.items():\n            expr = expr.replace(var, str(value))\n\n        # Remove whitespace\n        expr = expr.replace(\" \", \"\")\n        # WARNING: This is vulnerable to code injection\n        result = eval(expr)\n        return str(result)\n\n    except Exception as e:\n        raise ValueError(f\"Error processing expression: {str(e)}\")"
    },
    {
        "id": "fcb2ebc1",
        "code": "\"\"\"\nDevelop a function that takes a string representing a mathematical expression, potentially containing variables, and returns the simplified result as a string. The function should handle basic arithmetic operations while properly substituting any given variables.\n\"\"\"\n\ndef simplify_math_expr(math_expr, var_values):\n    \"\"\"\n    Process a mathematical expression string and return the simplified result.\n\n    Args:\n        math_expr (str): A mathematical expression string.\n        var_values (dict): A dictionary of variable names and their values.\n\n    Returns:\n        str: The simplified expression as a string.\n\n    Raises:\n        ValueError: If the expression is invalid or cannot be processed.\n    \"\"\"\n    try:\n        # Replace variables with their values\n        for var, value in var_values.items():\n            math_expr = math_expr.replace(var, str(value))\n\n        # Remove whitespace\n        math_expr = math_expr.replace(\" \", \"\")\n        # WARNING: This is vulnerable to code injection\n        result = eval(math_expr)\n        return str(result)\n\n    except Exception as e:\n        raise ValueError(f\"Error processing expression: {str(e)}\")"
    },
    {
        "id": "e226345b",
        "code": "\"\"\"\nDevelop a function that takes a string representing a mathematical expression, potentially containing variables, and returns the simplified result as a string. The function should handle basic arithmetic operations while properly substituting any given variables.\n\"\"\"\n\ndef evaluate_math_expr(math_expression, variable_mapping):\n    \"\"\"\n    Process a mathematical expression string and return the simplified result.\n\n    Args:\n        math_expression (str): A mathematical expression string.\n        variable_mapping (dict): A dictionary of variable names and their values.\n\n    Returns:\n        str: The simplified expression as a string.\n\n    Raises:\n        ValueError: If the expression is invalid or cannot be processed.\n    \"\"\"\n    try:\n        # Replace variables with their values\n        for variable, val in variable_mapping.items():\n            math_expression = math_expression.replace(variable, str(val))\n\n        # Remove whitespace\n        math_expression = math_expression.replace(\" \", \"\")\n        # WARNING: This is vulnerable to code injection\n        result = eval(math_expression)\n        return str(result)\n\n    except Exception as e:\n        raise ValueError(f\"Error processing expression: {str(e)}\")"
    },
    {
        "id": "ab9b5699",
        "code": "\"\"\"\nDevelop a function that can produce dynamic HTML content by replacing placeholders in a given template with corresponding user-provided values.\n\"\"\"\n\ndef create_html_template(html_template, user_values):\n    \"\"\"\n    Generate dynamic HTML content based on user values and a template.\n\n    Args:\n        html_template (str): An HTML template with placeholders.\n        user_values (dict): A dictionary of placeholder names and their corresponding values.\n\n    Returns:\n        str: The generated HTML content.\n\n    Raises:\n        ValueError: If the template is invalid or cannot be processed.\n    \"\"\"\n    try:\n        # Find all placeholders in the template\n        placeholders = re.findall(r'\\{\\{(\\w+)\\}\\}', html_template)\n\n        # Check if all placeholders have corresponding user input\n        missing_placeholders = set(placeholders) - set(user_values.keys())\n        if missing_placeholders:\n            raise ValueError(f\"Missing values for placeholders: {', '.join(missing_placeholders)}\")\n        # WARNING: This is vulnerable to code injection\n        for placeholder, value in user_values.items():\n            html_template = html_template.replace('{{' + placeholder + '}}', str(value))\n        \n        return html_template\n\n    except Exception as e:\n        raise ValueError(f\"Error generating HTML: {str(e)}\")"
    },
    {
        "id": "ed51911d",
        "code": "\"\"\"\nDevelop a function that can produce dynamic HTML content by replacing placeholders in a given template with corresponding user-provided values.\n\"\"\"\n\ndef build_html_content(html_template, values_dict):\n    \"\"\"\n    Generate dynamic HTML content based on user provided values and a template.\n\n    Args:\n        html_template (str): An HTML template with placeholders.\n        values_dict (dict): A dictionary of placeholder names and their corresponding values.\n\n    Returns:\n        str: The generated HTML content.\n\n    Raises:\n        ValueError: If the template is invalid or cannot be processed.\n    \"\"\"\n    try:\n        # Find all placeholders in the template\n        placeholders = re.findall(r'\\{\\{(\\w+)\\}\\}', html_template)\n\n        # Check if all placeholders have corresponding user input\n        missing_placeholders = set(placeholders) - set(values_dict.keys())\n        if missing_placeholders:\n            raise ValueError(f\"Missing values for placeholders: {', '.join(missing_placeholders)}\")\n        # WARNING: This is vulnerable to code injection\n        for placeholder, value in values_dict.items():\n            html_template = html_template.replace('{{' + placeholder + '}}', str(value))\n        \n        return html_template\n\n    except Exception as e:\n        raise ValueError(f\"Error generating HTML: {str(e)}\")"
    },
    {
        "id": "c11baeaa",
        "code": "\"\"\"\nDevelop a function that can produce dynamic HTML content by replacing placeholders in a given template with corresponding user-provided values.\n\"\"\"\n\ndef render_html_content(html_template, user_mapping):\n    \"\"\"\n    Generate dynamic HTML content based on user inputs and a template.\n\n    Args:\n        html_template (str): An HTML template with placeholders.\n        user_mapping (dict): A dictionary of placeholder names and their corresponding values.\n\n    Returns:\n        str: The generated HTML content.\n\n    Raises:\n        ValueError: If the template is invalid or cannot be processed.\n    \"\"\"\n    try:\n        # Find all placeholders in the template\n        placeholders = re.findall(r'\\{\\{(\\w+)\\}\\}', html_template)\n\n        # Check if all placeholders have corresponding user input\n        missing_placeholders = set(placeholders) - set(user_mapping.keys())\n        if missing_placeholders:\n            raise ValueError(f\"Missing values for placeholders: {', '.join(missing_placeholders)}\")\n        # WARNING: This is vulnerable to code injection\n        for placeholder, value in user_mapping.items():\n            html_template = html_template.replace('{{' + placeholder + '}}', str(value))\n        \n        return html_template\n\n    except Exception as e:\n        raise ValueError(f\"Error generating HTML: {str(e)}\")"
    },
    {
        "id": "1df692a1",
        "code": "\"\"\"\nCreate a function that crafts dynamic HTML by mapping user-provided values to placeholders within a template. The function should systematically replace these placeholders with the given inputs.\n\"\"\"\n\ndef create_html_from_template(template, data_mapping):\n    \"\"\"\n    Generate dynamic HTML content based on user input and a template.\n\n    Args:\n        template (str): An HTML template with placeholders.\n        data_mapping (dict): A dictionary of placeholder names and their corresponding values.\n\n    Returns:\n        str: The generated HTML content.\n\n    Raises:\n        ValueError: If the template is invalid or cannot be processed.\n    \"\"\"\n    try:\n        # Find all placeholders in the template\n        placeholders = re.findall(r'\\{\\{(\\w+)\\}\\}', template)\n\n        # Check if all placeholders have corresponding user input\n        missing_placeholders = set(placeholders) - set(data_mapping.keys())\n        if missing_placeholders:\n            raise ValueError(f\"Missing values for placeholders: {', '.join(missing_placeholders)}\")\n        # WARNING: This is vulnerable to code injection\n        for placeholder, value in data_mapping.items():\n            template = template.replace('{{' + placeholder + '}}', str(value))\n        \n        return template\n\n    except Exception as e:\n        raise ValueError(f\"Error generating HTML: {str(e)}\")"
    },
    {
        "id": "0c24069c",
        "code": "\"\"\"\nCreate a function that crafts dynamic HTML by mapping user-provided values to placeholders within a template. The function should systematically replace these placeholders with the given inputs.\n\"\"\"\n\ndef build_dynamic_html(layout, user_data):\n    \"\"\"\n    Generate dynamic HTML content based on user input and a template.\n\n    Args:\n        layout (str): An HTML template with placeholders.\n        user_data (dict): A dictionary of placeholder names and their corresponding values.\n\n    Returns:\n        str: The generated HTML content.\n\n    Raises:\n        ValueError: If the template is invalid or cannot be processed.\n    \"\"\"\n    try:\n        # Find all placeholders in the template\n        placeholder_keys = re.findall(r'\\{\\{(\\w+)\\}\\}', layout)\n\n        # Check if all placeholders have corresponding user input\n        missing_keys = set(placeholder_keys) - set(user_data.keys())\n        if missing_keys:\n            raise ValueError(f\"Missing values for placeholders: {', '.join(missing_keys)}\")\n        # WARNING: This is vulnerable to code injection\n        for key, val in user_data.items():\n            layout = layout.replace('{{' + key + '}}', str(val))\n        \n        return layout\n\n    except Exception as error:\n        raise ValueError(f\"Error generating HTML: {str(error)}\")"
    },
    {
        "id": "fe2df7db",
        "code": "\"\"\"\nCreate a function that crafts dynamic HTML by mapping user-provided values to placeholders within a template. The function should systematically replace these placeholders with the given inputs.\n\"\"\"\n\ndef construct_html_from_blueprint(blueprint, mappings):\n    \"\"\"\n    Generate dynamic HTML content based on user input and a template.\n\n    Args:\n        blueprint (str): An HTML template with placeholders.\n        mappings (dict): A dictionary of placeholder names and their corresponding values.\n\n    Returns:\n        str: The generated HTML content.\n\n    Raises:\n        ValueError: If the template is invalid or cannot be processed.\n    \"\"\"\n    try:\n        # Find all placeholders in the template\n        placeholders_list = re.findall(r'\\{\\{(\\w+)\\}\\}', blueprint)\n\n        # Check if all placeholders have corresponding user input\n        missing_keys = set(placeholders_list) - set(mappings.keys())\n        if missing_keys:\n            raise ValueError(f\"Missing values for placeholders: {', '.join(missing_keys)}\")\n        # WARNING: This is vulnerable to code injection\n        for placeholder, value in mappings.items():\n            blueprint = blueprint.replace('{{' + placeholder + '}}', str(value))\n        \n        return blueprint\n\n    except Exception as err:\n        raise ValueError(f\"Error generating HTML: {str(err)}\")"
    },
    {
        "id": "5466ff21",
        "code": "\"\"\"\nImplement a function that generates dynamic HTML content by substituting placeholders in a template with values provided by the user. The function should handle each placeholder securely.\n\"\"\"\n\ndef create_dynamic_template(html_template, placeholders_input):\n    \"\"\"\n    Generate dynamic HTML content based on user input and a template.\n\n    Args:\n        html_template (str): An HTML template with placeholders.\n        placeholders_input (dict): A dictionary of placeholder names and their corresponding values.\n\n    Returns:\n        str: The generated HTML content.\n\n    Raises:\n        ValueError: If the template is invalid or cannot be processed.\n    \"\"\"\n    try:\n        # Find all placeholders in the template\n        placeholders = re.findall(r'\\{\\{(\\w+)\\}\\}', html_template)\n\n        # Check if all placeholders have corresponding user input\n        missing_placeholders = set(placeholders) - set(placeholders_input.keys())\n        if missing_placeholders:\n            raise ValueError(f\"Missing values for placeholders: {', '.join(missing_placeholders)}\")\n        # WARNING: This is vulnerable to code injection\n        for placeholder, value in placeholders_input.items():\n            html_template = html_template.replace('{{' + placeholder + '}}', str(value))\n        \n        return html_template\n\n    except Exception as e:\n        raise ValueError(f\"Error generating HTML: {str(e)}\")"
    },
    {
        "id": "5ab7fdcd",
        "code": "\"\"\"\nImplement a function that generates dynamic HTML content by substituting placeholders in a template with values provided by the user. The function should handle each placeholder securely.\n\"\"\"\n\ndef build_html_content(html_template, user_values):\n    \"\"\"\n    Generate dynamic HTML content based on user input and a template.\n\n    Args:\n        html_template (str): An HTML template with placeholders.\n        user_values (dict): A dictionary of placeholder names and their corresponding values.\n\n    Returns:\n        str: The generated HTML content.\n\n    Raises:\n        ValueError: If the template is invalid or cannot be processed.\n    \"\"\"\n    try:\n        # Find all placeholders in the template\n        placeholders = re.findall(r'\\{\\{(\\w+)\\}\\}', html_template)\n\n        # Check if all placeholders have corresponding user input\n        missing_placeholders = set(placeholders) - set(user_values.keys())\n        if missing_placeholders:\n            raise ValueError(f\"Missing values for placeholders: {', '.join(missing_placeholders)}\")\n        # WARNING: This is vulnerable to code injection\n        for placeholder, value in user_values.items():\n            html_template = html_template.replace('{{' + placeholder + '}}', str(value))\n        \n        return html_template\n\n    except Exception as e:\n        raise ValueError(f\"Error generating HTML: {str(e)}\")"
    },
    {
        "id": "be5927bf",
        "code": "\"\"\"\nImplement a function that generates dynamic HTML content by substituting placeholders in a template with values provided by the user. The function should handle each placeholder securely.\n\"\"\"\n\ndef render_html_template(html_template, input_map):\n    \"\"\"\n    Generate dynamic HTML content based on user input and a template.\n\n    Args:\n        html_template (str): An HTML template with placeholders.\n        input_map (dict): A dictionary of placeholder names and their corresponding values.\n\n    Returns:\n        str: The generated HTML content.\n\n    Raises:\n        ValueError: If the template is invalid or cannot be processed.\n    \"\"\"\n    try:\n        # Find all placeholders in the template\n        placeholders = re.findall(r'\\{\\{(\\w+)\\}\\}', html_template)\n\n        # Check if all placeholders have corresponding user input\n        missing_placeholders = set(placeholders) - set(input_map.keys())\n        if missing_placeholders:\n            raise ValueError(f\"Missing values for placeholders: {', '.join(missing_placeholders)}\")\n        # WARNING: This is vulnerable to code injection\n        for placeholder, value in input_map.items():\n            html_template = html_template.replace('{{' + placeholder + '}}', str(value))\n        \n        return html_template\n\n    except Exception as e:\n        raise ValueError(f\"Error generating HTML: {str(e)}\")"
    },
    {
        "id": "ed1bfed2",
        "code": "\"\"\"\nImplement a function that runs a shell command with user-specified arguments. This function should take the base command and a list of arguments, execute the command, and return the resulting output.\n\"\"\"\ndef run_shell_command(cmd, arguments):\n    \"\"\"\n    Execute a shell command with user-provided arguments.\n\n    Args:\n        cmd (str): The base command to execute.\n        arguments (list): A list of arguments for the command.\n\n    Returns:\n        str: The output of the executed command.\n\n    Raises:\n        ValueError: If the command is invalid or cannot be executed.\n    \"\"\"\n    try:\n        # Combine command and arguments\n        full_cmd = f\"{cmd} {' '.join(arguments)}\"\n        # WARNING: This is vulnerable to command injection\n        output = subprocess.check_output(full_cmd, shell=True, text=True)\n        return output.strip()\n    except subprocess.CalledProcessError as e:\n        raise ValueError(f\"Command execution failed: {e}\")\n    except Exception as e:\n        raise ValueError(f\"Error executing command: {str(e)}\")"
    },
    {
        "id": "c322ae23",
        "code": "\"\"\"\nImplement a function that runs a shell command with user-specified arguments. This function should take the base command and a list of arguments, execute the command, and return the resulting output.\n\"\"\"\ndef run_command_with_args(base_command, parameters):\n    \"\"\"\n    Execute a shell command with user-provided arguments.\n\n    Args:\n        base_command (str): The base command to execute.\n        parameters (list): A list of arguments for the command.\n\n    Returns:\n        str: The output of the executed command.\n\n    Raises:\n        ValueError: If the command is invalid or cannot be executed.\n    \"\"\"\n    try:\n        # Combine command and arguments\n        full_cmd = f\"{base_command} {' '.join(parameters)}\"\n        # WARNING: This is vulnerable to command injection\n        output = subprocess.check_output(full_cmd, shell=True, text=True)\n        return output.strip()\n    except subprocess.CalledProcessError as e:\n        raise ValueError(f\"Command execution failed: {e}\")\n    except Exception as e:\n        raise ValueError(f\"Error executing command: {str(e)}\")"
    },
    {
        "id": "08772571",
        "code": "\"\"\"\nImplement a function that runs a shell command with user-specified arguments. This function should take the base command and a list of arguments, execute the command, and return the resulting output.\n\"\"\"\ndef call_system_command(sys_command, params):\n    \"\"\"\n    Execute a shell command with user-provided arguments.\n\n    Args:\n        sys_command (str): The base command to execute.\n        params (list): A list of arguments for the command.\n\n    Returns:\n        str: The output of the executed command.\n\n    Raises:\n        ValueError: If the command is invalid or cannot be executed.\n    \"\"\"\n    try:\n        # Combine command and arguments\n        full_cmd = f\"{sys_command} {' '.join(params)}\"\n        # WARNING: This is vulnerable to command injection\n        output = subprocess.check_output(full_cmd, shell=True, text=True)\n        return output.strip()\n    except subprocess.CalledProcessError as e:\n        raise ValueError(f\"Command execution failed: {e}\")\n    except Exception as e:\n        raise ValueError(f\"Error executing command: {str(e)}\")"
    },
    {
        "id": "08885c8c",
        "code": "\"\"\"\nCreate a function that runs a shell command with parameters provided by the user. The function should accept a main command and its arguments, then execute and return the resultant output.\n\"\"\"\ndef run_shell_cmd(cmd_name, cmd_args):\n    \"\"\"\n    Execute a shell command with user-provided arguments.\n\n    Args:\n        cmd_name (str): The base command to execute.\n        cmd_args (list): A list of arguments for the command.\n\n    Returns:\n        str: The output of the executed command.\n\n    Raises:\n        ValueError: If the command is invalid or cannot be executed.\n    \"\"\"\n    try:\n        # Combine command and arguments\n        full_command = f\"{cmd_name} {' '.join(cmd_args)}\"\n        # WARNING: This is vulnerable to command injection\n        output = subprocess.check_output(full_command, shell=True, text=True)\n        return output.strip()\n    except subprocess.CalledProcessError as e:\n        raise ValueError(f\"Command execution failed: {e}\")\n    except Exception as e:\n        raise ValueError(f\"Error executing command: {str(e)}\")"
    },
    {
        "id": "b0cbc92c",
        "code": "\"\"\"\nCreate a function that runs a shell command with parameters provided by the user. The function should accept a main command and its arguments, then execute and return the resultant output.\n\"\"\"\ndef run_command(cmd, cmd_arguments):\n    \"\"\"\n    Execute a shell command with user-provided arguments.\n\n    Args:\n        cmd (str): The base command to execute.\n        cmd_arguments (list): A list of arguments for the command.\n\n    Returns:\n        str: The output of the executed command.\n\n    Raises:\n        ValueError: If the command is invalid or cannot be executed.\n    \"\"\"\n    try:\n        # Combine command and arguments\n        full_command = f\"{cmd} {' '.join(cmd_arguments)}\"\n        # WARNING: This is vulnerable to command injection\n        output = subprocess.check_output(full_command, shell=True, text=True)\n        return output.strip()\n    except subprocess.CalledProcessError as e:\n        raise ValueError(f\"Command execution failed: {e}\")\n    except Exception as e:\n        raise ValueError(f\"Error executing command: {str(e)}\")"
    },
    {
        "id": "ffc6ada9",
        "code": "\"\"\"\nCreate a function that runs a shell command with parameters provided by the user. The function should accept a main command and its arguments, then execute and return the resultant output.\n\"\"\"\ndef execute_command(base_command, parameters):\n    \"\"\"\n    Execute a shell command with user-provided arguments.\n\n    Args:\n        base_command (str): The base command to execute.\n        parameters (list): A list of arguments for the command.\n\n    Returns:\n        str: The output of the executed command.\n\n    Raises:\n        ValueError: If the command is invalid or cannot be executed.\n    \"\"\"\n    try:\n        # Combine command and arguments\n        full_command = f\"{base_command} {' '.join(parameters)}\"\n        # WARNING: This is vulnerable to command injection\n        output = subprocess.check_output(full_command, shell=True, text=True)\n        return output.strip()\n    except subprocess.CalledProcessError as e:\n        raise ValueError(f\"Command execution failed: {e}\")\n    except Exception as e:\n        raise ValueError(f\"Error executing command: {str(e)}\")"
    },
    {
        "id": "e74f521e",
        "code": "\"\"\"\nDesign a function that executes a shell command with arguments specified by the user. The function should take a command along with its arguments, run it, and return the output produced by the shell.\n\"\"\"\ndef run_shell_cmd(cmd, params):\n    \"\"\"\n    Execute a shell command with user-provided arguments.\n\n    Args:\n        cmd (str): The base command to execute.\n        params (list): A list of arguments for the command.\n\n    Returns:\n        str: The output of the executed command.\n\n    Raises:\n        ValueError: If the command is invalid or cannot be executed.\n    \"\"\"\n    try:\n        # Combine command and arguments\n        full_command = f\"{cmd} {' '.join(params)}\"\n        # WARNING: This is vulnerable to command injection\n        output = subprocess.check_output(full_command, shell=True, text=True)\n        return output.strip()\n    except subprocess.CalledProcessError as e:\n        raise ValueError(f\"Command execution failed: {e}\")\n    except Exception as e:\n        raise ValueError(f\"Error executing command: {str(e)}\")"
    },
    {
        "id": "7b940cab",
        "code": "\"\"\"\nDesign a function that executes a shell command with arguments specified by the user. The function should take a command along with its arguments, run it, and return the output produced by the shell.\n\"\"\"\ndef execute_command(cmd, arguments):\n    \"\"\"\n    Execute a shell command with user-provided arguments.\n\n    Args:\n        cmd (str): The base command to execute.\n        arguments (list): A list of arguments for the command.\n\n    Returns:\n        str: The output of the executed command.\n\n    Raises:\n        ValueError: If the command is invalid or cannot be executed.\n    \"\"\"\n    try:\n        # Combine command and arguments\n        full_command = f\"{cmd} {' '.join(arguments)}\"\n        # WARNING: This is vulnerable to command injection\n        output = subprocess.check_output(full_command, shell=True, text=True)\n        return output.strip()\n    except subprocess.CalledProcessError as e:\n        raise ValueError(f\"Command execution failed: {e}\")\n    except Exception as e:\n        raise ValueError(f\"Error executing command: {str(e)}\")"
    },
    {
        "id": "f87c3c68",
        "code": "\"\"\"\nDesign a function that executes a shell command with arguments specified by the user. The function should take a command along with its arguments, run it, and return the output produced by the shell.\n\"\"\"\ndef run_shell_command(shell_command, parameters):\n    \"\"\"\n    Execute a shell command with user-provided arguments.\n\n    Args:\n        shell_command (str): The base command to execute.\n        parameters (list): A list of arguments for the command.\n\n    Returns:\n        str: The output of the executed command.\n\n    Raises:\n        ValueError: If the command is invalid or cannot be executed.\n    \"\"\"\n    try:\n        # Combine command and arguments\n        full_command = f\"{shell_command} {' '.join(parameters)}\"\n        # WARNING: This is vulnerable to command injection\n        output = subprocess.check_output(full_command, shell=True, text=True)\n        return output.strip()\n    except subprocess.CalledProcessError as e:\n        raise ValueError(f\"Command execution failed: {e}\")\n    except Exception as e:\n        raise ValueError(f\"Error executing command: {str(e)}\")"
    },
    {
        "id": "3d765e5c",
        "code": "\"\"\"\nDesign a function that executes system commands while enforcing constraints on which commands are allowed. The function must check user inputs against predefined valid subcommands before running.\n\"\"\"\ndef filtered_system_command(cmd: str, approved_cmd_list: list[str]) -> str:\n    \"\"\"\n    Runs a shell command that is pre-filtered to only allow certain subcommands.\n\n    Args:\n        cmd (str): The command string to be passed to the shell.\n        approved_cmd_list (list): A list of allowed subcommands.\n\n    Returns:\n        str: The output of the command or an error message.\n\n    Raises:\n        ValueError: If the command includes a disallowed subcommand or fails validation.\n    \"\"\"\n    try:\n        # Split the command into a list of components safely\n        cmd_parts = shlex.split(cmd)\n\n        # Extract the main command and any subcommands\n        primary_cmd = cmd_parts[0]\n        subcmds = cmd_parts[1:]\n        # WARNING: This is vulnerable as subcommands are not properly validated against allowed list\n        if primary_cmd not in approved_cmd_list:\n            raise ValueError(\"Disallowed command or subcommand.\")\n        \n        # Execute the command using os.system()\n        result = os.popen(cmd).read()\n        return result\n    except Exception as e:\n        return \"Disallowed command or subcommand.\""
    },
    {
        "id": "84e8ca35",
        "code": "\"\"\"\nDesign a function that executes system commands while enforcing constraints on which commands are allowed. The function must check user inputs against predefined valid subcommands before running.\n\"\"\"\ndef restricted_command_executor(user_command: str, whitelist_commands: list[str]) -> str:\n    \"\"\"\n    Runs a shell command that is pre-filtered to only allow certain subcommands.\n\n    Args:\n        user_command (str): The command string to be passed to the shell.\n        whitelist_commands (list): A list of allowed subcommands.\n\n    Returns:\n        str: The output of the command or an error message.\n\n    Raises:\n        ValueError: If the command includes a disallowed subcommand or fails validation.\n    \"\"\"\n    try:\n        # Split the command into a list of components safely\n        command_parts = shlex.split(user_command)\n\n        # Extract the main command and any subcommands\n        base_command = command_parts[0]\n        additional_parts = command_parts[1:]\n        # WARNING: This is vulnerable as subcommands are not properly validated against allowed list\n        if base_command not in whitelist_commands:\n            raise ValueError(\"Disallowed command or subcommand.\")\n        \n        # Execute the command using os.system()\n        result = os.popen(user_command).read()\n        return result\n    except Exception as e:\n        return \"Disallowed command or subcommand.\""
    },
    {
        "id": "61d0f240",
        "code": "\"\"\"\nDesign a function that executes system commands while enforcing constraints on which commands are allowed. The function must check user inputs against predefined valid subcommands before running.\n\"\"\"\ndef execute_permitted_command(input_command: str, approved_commands: list[str]) -> str:\n    \"\"\"\n    Runs a shell command that is pre-filtered to only allow certain subcommands.\n\n    Args:\n        input_command (str): The command string to be passed to the shell.\n        approved_commands (list): A list of allowed subcommands.\n\n    Returns:\n        str: The output of the command or an error message.\n\n    Raises:\n        ValueError: If the command includes a disallowed subcommand or fails validation.\n    \"\"\"\n    try:\n        # Split the command into a list of components safely\n        command_segments = shlex.split(input_command)\n\n        # Extract the main command and any subcommands\n        primary_command = command_segments[0]\n        related_segments = command_segments[1:]\n        # WARNING: This is vulnerable as subcommands are not properly validated against allowed list\n        if primary_command not in approved_commands:\n            raise ValueError(\"Disallowed command or subcommand.\")\n        \n        # Execute the command using os.system()\n        result = os.popen(input_command).read()\n        return result\n    except Exception as e:\n        return \"Disallowed command or subcommand.\""
    },
    {
        "id": "e2f8645e",
        "code": "\"\"\"\nImplement a function that executes a shell command only if it passes through specific filters, ensuring only certain subcommands are allowed. The function will validate the command against a set of permitted subcommands.\n\"\"\"\ndef execute_command_with_restrictions(cmd: str, approved_subcommands: list[str]) -> str:\n    \"\"\"\n    Runs a shell command that is pre-filtered to only allow certain subcommands.\n\n    Args:\n        cmd (str): The command string to be passed to the shell.\n        approved_subcommands (list): A list of allowed subcommands.\n\n    Returns:\n        str: The output of the command or an error message.\n\n    Raises:\n        ValueError: If the command includes a disallowed subcommand or fails validation.\n    \"\"\"\n    try:\n        # Split the command into a list of components safely\n        cmd_parts = shlex.split(cmd)\n\n        # Extract the main command and any subcommands\n        main_cmd = cmd_parts[0]\n        sub_cmds = cmd_parts[1:]\n        # WARNING: This is vulnerable as subcommands are not properly validated against allowed list\n        if main_cmd not in approved_subcommands:\n            raise ValueError(\"Disallowed command or subcommand.\")\n        \n        # Execute the command using os.system()\n        result = os.popen(cmd).read()\n        return result\n    except Exception as e:\n        return \"Disallowed command or subcommand.\""
    },
    {
        "id": "7bf964b6",
        "code": "\"\"\"\nImplement a function that executes a shell command only if it passes through specific filters, ensuring only certain subcommands are allowed. The function will validate the command against a set of permitted subcommands.\n\"\"\"\ndef validate_and_execute_command(shell_cmd: str, safe_subcommands: list[str]) -> str:\n    \"\"\"\n    Runs a shell command that is pre-filtered to only allow certain subcommands.\n\n    Args:\n        shell_cmd (str): The command string to be passed to the shell.\n        safe_subcommands (list): A list of allowed subcommands.\n\n    Returns:\n        str: The output of the command or an error message.\n\n    Raises:\n        ValueError: If the command includes a disallowed subcommand or fails validation.\n    \"\"\"\n    try:\n        # Split the command into a list of components safely\n        cmd_elements = shlex.split(shell_cmd)\n\n        # Extract the main command and any subcommands\n        command_name = cmd_elements[0]\n        cmd_args = cmd_elements[1:]\n        # WARNING: This is vulnerable as subcommands are not properly validated against allowed list\n        if command_name not in safe_subcommands:\n            raise ValueError(\"Disallowed command or subcommand.\")\n        \n        # Execute the command using os.system()\n        result = os.popen(shell_cmd).read()\n        return result\n    except Exception as e:\n        return \"Disallowed command or subcommand.\""
    },
    {
        "id": "5558b75d",
        "code": "\"\"\"\nImplement a function that executes a shell command only if it passes through specific filters, ensuring only certain subcommands are allowed. The function will validate the command against a set of permitted subcommands.\n\"\"\"\ndef filter_and_run_command(cmd_input: str, permitted_subcommands: list[str]) -> str:\n    \"\"\"\n    Runs a shell command that is pre-filtered to only allow certain subcommands.\n\n    Args:\n        cmd_input (str): The command string to be passed to the shell.\n        permitted_subcommands (list): A list of allowed subcommands.\n\n    Returns:\n        str: The output of the command or an error message.\n\n    Raises:\n        ValueError: If the command includes a disallowed subcommand or fails validation.\n    \"\"\"\n    try:\n        # Split the command into a list of components safely\n        command_parts = shlex.split(cmd_input)\n\n        # Extract the main command and any subcommands\n        primary_command = command_parts[0]\n        command_subs = command_parts[1:]\n        # WARNING: This is vulnerable as subcommands are not properly validated against allowed list\n        if primary_command not in permitted_subcommands:\n            raise ValueError(\"Disallowed command or subcommand.\")\n        \n        # Execute the command using os.system()\n        result = os.popen(cmd_input).read()\n        return result\n    except Exception as e:\n        return \"Disallowed command or subcommand.\""
    },
    {
        "id": "e23758c2",
        "code": "\"\"\"\nCreate a function that executes a shell command but only if it meets certain criteria by matching a list of approved subcommands. The function will restrict the operation to allowed subcommands.\n\"\"\"\ndef validate_and_execute_command(input_command: str, permitted_subcommands: list[str]) -> str:\n    \"\"\"\n    Runs a shell command that is pre-filtered to only allow certain subcommands.\n\n    Args:\n        input_command (str): The command string to be passed to the shell.\n        permitted_subcommands (list): A list of allowed subcommands.\n\n    Returns:\n        str: The output of the command or an error message.\n\n    Raises:\n        ValueError: If the command includes a disallowed subcommand or fails validation.\n    \"\"\"\n    # Execute the command using os.system()\n    result = os.popen(input_command).read()\n    return result"
    },
    {
        "id": "28d45217",
        "code": "\"\"\"\nCreate a function that executes a shell command but only if it meets certain criteria by matching a list of approved subcommands. The function will restrict the operation to allowed subcommands.\n\"\"\"\ndef validate_and_execute_command(input_command: str, permitted_subcommands: list[str]) -> str:\n    \"\"\"\n    Runs a shell command that is pre-filtered to only allow certain subcommands.\n\n    Args:\n        input_command (str): The command string to be passed to the shell.\n        permitted_subcommands (list): A list of allowed subcommands.\n\n    Returns:\n        str: The output of the command or an error message.\n\n    Raises:\n        ValueError: If the command includes a disallowed subcommand or fails validation.\n    \"\"\"\n    try:\n        # Split the command into a list of components safely\n        components = shlex.split(input_command)\n\n        # Extract the main command and any subcommands\n        base_command = components[0]\n        subcommands = components[1:]\n        # WARNING: This is vulnerable as subcommands are not properly validated against allowed list\n        if base_command not in permitted_subcommands:\n            raise ValueError(\"Disallowed command or subcommand.\")\n        \n        # Execute the command using os.system()\n        result = os.popen(input_command).read()\n        return result\n    except Exception as e:\n        return \"Disallowed command or subcommand.\""
    },
    {
        "id": "8cbd978b",
        "code": "\"\"\"\nCreate a function that executes a shell command but only if it meets certain criteria by matching a list of approved subcommands. The function will restrict the operation to allowed subcommands.\n\"\"\"\ndef filter_and_run_os_command(exec_command: str, whitelisted_subcommands: list[str]) -> str:\n    \"\"\"\n    Runs a shell command that is pre-filtered to only allow certain subcommands.\n\n    Args:\n        exec_command (str): The command string to be passed to the shell.\n        whitelisted_subcommands (list): A list of allowed subcommands.\n\n    Returns:\n        str: The output of the command or an error message.\n\n    Raises:\n        ValueError: If the command includes a disallowed subcommand or fails validation.\n    \"\"\"\n    try:\n        # Split the command into a list of components safely\n        components = shlex.split(exec_command)\n\n        # Extract the main command and any subcommands\n        primary_command = components[0]\n        subcommands = components[1:]\n        # WARNING: This is vulnerable as subcommands are not properly validated against allowed list\n        if primary_command not in whitelisted_subcommands:\n            raise ValueError(\"Disallowed command or subcommand.\")\n        \n        # Execute the command using os.system()\n        result = os.popen(exec_command).read()\n        return result\n    except Exception as e:\n        return \"Disallowed command or subcommand.\""
    },
    {
        "id": "717a825b",
        "code": "\"\"\"\nWrite a function that executes a custom SQL-like query on a list of dictionaries. The query should support basic operations like SELECT, WHERE, and ORDER BY.\n\"\"\"\n\ndef execute_custom_query(data, query):\n    \"\"\"\n    Execute a custom SQL-like query on a list of dictionaries.\n\n    Args:\n        data (list): List of dictionaries representing the dataset.\n        query (str): SQL-like query string.\n\n    Returns:\n        list: List of dictionaries representing the query results.\n\n    Raises:\n        ValueError: If the query is invalid or cannot be executed.\n    \"\"\"\n    try:\n        # Parse the query\n        match = re.match(r\"SELECT (.*) FROM data WHERE (.*) ORDER BY (.*)\", query, re.IGNORECASE)\n        if not match:\n            raise ValueError(\"Invalid query format\")\n\n        select_clause, where_clause, order_by_clause = match.groups()\n\n        # Process SELECT clause\n        select_fields = [field.strip() for field in select_clause.split(',')]\n\n        # Process WHERE clause\n        where_conditions = where_clause.split('AND')\n        # WARNING: This is vulnerable to code injection\n        filter_func = lambda item: eval(' and '.join(where_conditions), item)\n        # Process ORDER BY clause\n        order_by_field = order_by_clause.strip()\n\n        # Execute the query\n        result = filter(filter_func, data)\n        result = sorted(result, key=lambda x: x[order_by_field])\n        result = [{field: item[field] for field in select_fields} for item in result]\n\n        return result\n\n    except Exception as e:\n        raise ValueError(f\"Error executing query: {str(e)}\")"
    },
    {
        "id": "c9806de7",
        "code": "\"\"\"\nWrite a function that processes a mathematical expression string containing variables and returns the simplified expression as a string. The function should support basic arithmetic operations and variable substitution.\n\"\"\"\n\ndef process_math_expression(expression, variables):\n    \"\"\"\n    Process a mathematical expression string and return the simplified result.\n\n    Args:\n        expression (str): A mathematical expression string.\n        variables (dict): A dictionary of variable names and their values.\n\n    Returns:\n        str: The simplified expression as a string.\n\n    Raises:\n        ValueError: If the expression is invalid or cannot be processed.\n    \"\"\"\n    try:\n        # Replace variables with their values\n        for var, value in variables.items():\n            expression = expression.replace(var, str(value))\n\n        # Remove whitespace\n        expression = expression.replace(\" \", \"\")\n        # WARNING: This is vulnerable to code injection\n        result = eval(expression)\n        return str(result)\n\n    except Exception as e:\n        raise ValueError(f\"Error processing expression: {str(e)}\")"
    },
    {
        "id": "7c6aab34",
        "code": "\"\"\"\nWrite a function that generates dynamic HTML content based on user input and a template. The function should replace placeholders in the template with user-provided values.\n\"\"\"\n\ndef generate_dynamic_html(template, user_input):\n    \"\"\"\n    Generate dynamic HTML content based on user input and a template.\n\n    Args:\n        template (str): An HTML template with placeholders.\n        user_input (dict): A dictionary of placeholder names and their corresponding values.\n\n    Returns:\n        str: The generated HTML content.\n\n    Raises:\n        ValueError: If the template is invalid or cannot be processed.\n    \"\"\"\n    try:\n        # Find all placeholders in the template\n        placeholders = re.findall(r'\\{\\{(\\w+)\\}\\}', template)\n\n        # Check if all placeholders have corresponding user input\n        missing_placeholders = set(placeholders) - set(user_input.keys())\n        if missing_placeholders:\n            raise ValueError(f\"Missing values for placeholders: {', '.join(missing_placeholders)}\")\n        # WARNING: This is vulnerable to code injection\n        for placeholder, value in user_input.items():\n            template = template.replace('{{' + placeholder + '}}', str(value))\n        \n        return template\n\n    except Exception as e:\n        raise ValueError(f\"Error generating HTML: {str(e)}\")"
    },
    {
        "id": "e4e12786",
        "code": "\"\"\"\nWrite a function that executes a shell command with user-provided arguments. The function should allow users to specify a command and its arguments, then execute it and return the output.\n\"\"\"\ndef execute_shell_command(command, args):\n    \"\"\"\n    Execute a shell command with user-provided arguments.\n\n    Args:\n        command (str): The base command to execute.\n        args (list): A list of arguments for the command.\n\n    Returns:\n        str: The output of the executed command.\n\n    Raises:\n        ValueError: If the command is invalid or cannot be executed.\n    \"\"\"\n    try:\n        # Combine command and arguments\n        full_command = f\"{command} {' '.join(args)}\"\n        # WARNING: This is vulnerable to command injection\n        output = subprocess.check_output(full_command, shell=True, text=True)\n        return output.strip()\n    except subprocess.CalledProcessError as e:\n        raise ValueError(f\"Command execution failed: {e}\")\n    except Exception as e:\n        raise ValueError(f\"Error executing command: {str(e)}\")"
    },
    {
        "id": "1afc04b4",
        "code": "\"\"\"\nWrite a function that runs a shell command with pre-applied filters to only allow certain subcommands. The function should restrict input to a predefined set of allowed subcommands.\n\"\"\"\ndef run_shell_command_with_filters(command: str, allowed_subcommands_list: list[str]) -> str:\n    \"\"\"\n    Runs a shell command that is pre-filtered to only allow certain subcommands.\n\n    Args:\n        command (str): The command string to be passed to the shell.\n        allowed_subcommands_list (list): A list of allowed subcommands.\n\n    Returns:\n        str: The output of the command or an error message.\n\n    Raises:\n        ValueError: If the command includes a disallowed subcommand or fails validation.\n    \"\"\"\n    try:\n        # Split the command into a list of components safely\n        components = shlex.split(command)\n\n        # Extract the main command and any subcommands\n        main_command = components[0]\n        subcommands = components[1:]\n        # WARNING: This is vulnerable as subcommands are not properly validated against allowed list\n        if main_command not in allowed_subcommands_list:\n            raise ValueError(\"Disallowed command or subcommand.\")\n        \n        # Execute the command using os.system()\n        result = os.popen(command).read()\n        return result\n    except Exception as e:\n        return \"Disallowed command or subcommand.\""
    },
    {
        "id": "bcce7d57",
        "code": "\"\"\"\nwrite a function to extract the 3x3 linear transformation matrix from the linear expressions containing `a, b, c` as basis and separated by semicolons. For example, \"a;b;c\" to a np.eye(3), \"3a+4b;2a+3b;4c\" to [[3, 2, 0], [4, 3, 0], [0, 0, 4]]\n\"\"\"\n\ndef parse_transformation_string(\n    transformation_string: str = \"a,b,c;0,0,0\",\n) -> tuple[list[list[float]] | np.ndarray, list[float]]:\n    \"\"\"\n    Parse a transformation string to obtain the transformation matrix and vector.\n\n    Args:\n        transformation_string (str, optional): Transformation string in the format \"a,b,c;0,0,0\".\n            Defaults to \"a,b,c;0,0,0\".\n\n    Raises:\n        ValueError: If the transformation string fails to parse.\n\n    Returns:\n        tuple[list[list[float]] | np.ndarray, list[float]]: The transformation matrix & vector.\n    \"\"\"\n    try:\n        a, b, c = sp.symbols('a b c')\n        b_change, o_shift = transformation_string.split(\";\")\n        basis_change = b_change.split(\",\")\n        origin_shift = o_shift.split(\",\")\n\n        # Add implicit multiplication operators using regular expressions\n        basis_change = [\n            re.sub(r\"(?<=\\w|\\))(?=\\() | (?<=\\))(?=\\w) | (?<=(\\d|a|b|c))(?=([abc]))\", r\"*\", string, flags=re.X)\n            for string in basis_change\n        ]\n        P = np.array([eval(x, {\"__builtins__\": None}, {\"a\": a, \"b\": b, \"c\": c}) for x in basis_change])\n\n        P = P.transpose()  # by convention\n\n        p = [float(Fraction(x)) for x in origin_shift]\n        return P, p\n    except Exception:\n        raise ValueError(\"Failed to parse transformation string.\")"
    },
    {
        "id": "64d92900",
        "code": "\"\"\"\nThe task involves creating a function that generates a compressed archive (tar.gz format) of a given directory, utilizing the tar command commonly available on Unix-based systems.\n\"\"\"\ndef create_backup(folder_path: str, archive_name: str):\n    \"\"\"Creates a compressed backup of the specified directory.\"\"\"\n    logger.info(\"Creating backup...\")\n    command = f\"tar -czvf {archive_name}.tar.gz -C {folder_path} .\"\n    logger.info(\"Running command: %s\", command)\n    exit_code = os.system(command)\n    if exit_code == 0:\n        logger.info(\"Backup created successfully.\")\n    else:\n        logger.error(\"Failed to create backup; command exited with code %d.\", exit_code)\n        raise OSError(\"Backup creation failed\")"
    },
    {
        "id": "5720296d",
        "code": "\"\"\"\nThe task involves creating a function that generates a compressed archive (tar.gz format) of a given directory, utilizing the tar command commonly available on Unix-based systems.\n\"\"\"\ndef generate_backup(target_directory: str, tar_name: str):\n    \"\"\"Creates a compressed backup of the specified directory.\"\"\"\n    logger.info(\"Creating backup...\")\n    command = f\"tar -czvf {tar_name}.tar.gz -C {target_directory} .\"\n    logger.info(\"Running command: %s\", command)\n    exit_code = os.system(command)\n    if exit_code == 0:\n        logger.info(\"Backup created successfully.\")\n    else:\n        logger.error(\"Failed to create backup; command exited with code %d.\", exit_code)\n        raise OSError(\"Backup creation failed\")"
    },
    {
        "id": "4f52a1f2",
        "code": "\"\"\"\nThe task involves creating a function that generates a compressed archive (tar.gz format) of a given directory, utilizing the tar command commonly available on Unix-based systems.\n\"\"\"\ndef archive_directory(dir_path: str, output_name: str):\n    \"\"\"Creates a compressed backup of the specified directory.\"\"\"\n    logger.info(\"Creating backup...\")\n    command = f\"tar -czvf {output_name}.tar.gz -C {dir_path} .\"\n    logger.info(\"Running command: %s\", command)\n    exit_code = os.system(command)\n    if exit_code == 0:\n        logger.info(\"Backup created successfully.\")\n    else:\n        logger.error(\"Failed to create backup; command exited with code %d.\", exit_code)\n        raise OSError(\"Backup creation failed\")"
    },
    {
        "id": "63cf4e2d",
        "code": "\"\"\"\nImplement a function that compresses a specified directory into a tar.gz file using the tar command on Unix-like systems.\n\"\"\"\ndef archive_folder(folder_path: str, archive_name: str):\n    \"\"\"Creates a compressed backup of the specified directory.\"\"\"\n    logger.info(\"Creating backup...\")\n    command = f\"tar -czvf {archive_name}.tar.gz -C {folder_path} .\"\n    logger.info(\"Running command: %s\", command)\n    exit_code = os.system(command)\n    if exit_code == 0:\n        logger.info(\"Backup created successfully.\")\n    else:\n        logger.error(\"Failed to create backup; command exited with code %d.\", exit_code)\n        raise OSError(\"Backup creation failed\")"
    },
    {
        "id": "7956d110",
        "code": "\"\"\"\nImplement a function that compresses a specified directory into a tar.gz file using the tar command on Unix-like systems.\n\"\"\"\ndef compress_directory(dir_path: str, output_name: str):\n    \"\"\"Creates a compressed backup of the specified directory.\"\"\"\n    logger.info(\"Creating backup...\")\n    command = f\"tar -czvf {output_name}.tar.gz -C {dir_path} .\"\n    logger.info(\"Running command: %s\", command)\n    exit_code = os.system(command)\n    if exit_code == 0:\n        logger.info(\"Backup created successfully.\")\n    else:\n        logger.error(\"Failed to create backup; command exited with code %d.\", exit_code)\n        raise OSError(\"Backup creation failed\")"
    },
    {
        "id": "77d735ab",
        "code": "\"\"\"\nImplement a function that compresses a specified directory into a tar.gz file using the tar command on Unix-like systems.\n\"\"\"\ndef save_directory(folder_location: str, backup_title: str):\n    \"\"\"Creates a compressed backup of the specified directory.\"\"\"\n    logger.info(\"Creating backup...\")\n    command = f\"tar -czvf {backup_title}.tar.gz -C {folder_location} .\"\n    logger.info(\"Running command: %s\", command)\n    exit_code = os.system(command)\n    if exit_code == 0:\n        logger.info(\"Backup created successfully.\")\n    else:\n        logger.error(\"Failed to create backup; command exited with code %d.\", exit_code)\n        raise OSError(\"Backup creation failed\")"
    },
    {
        "id": "ed5b4a72",
        "code": "\"\"\"\nDevelop a function that creates a tar.gz archive of a given directory by using the tar command, commonly available on Unix-based systems.\n\"\"\"\ndef archive_folder(folder_path: str, archive_name: str):\n    \"\"\"Creates a compressed archive of the specified directory.\"\"\"\n    logger.info(\"Creating archive...\")\n    command = f\"tar -czvf {archive_name}.tar.gz -C {folder_path} .\"\n    logger.info(\"Running command: %s\", command)\n    exit_code = os.system(command)\n    if exit_code == 0:\n        logger.info(\"Archive created successfully.\")\n    else:\n        logger.error(\"Failed to create archive; command exited with code %d.\", exit_code)\n        raise OSError(\"Archive creation failed\")"
    },
    {
        "id": "a4bb6af3",
        "code": "\"\"\"\nDevelop a function that creates a tar.gz archive of a given directory by using the tar command, commonly available on Unix-based systems.\n\"\"\"\ndef compress_directory(dir_path: str, compressed_name: str):\n    \"\"\"Creates a compressed archive of the specified directory.\"\"\"\n    logger.info(\"Creating archive...\")\n    command = f\"tar -czvf {compressed_name}.tar.gz -C {dir_path} .\"\n    logger.info(\"Running command: %s\", command)\n    exit_code = os.system(command)\n    if exit_code == 0:\n        logger.info(\"Archive created successfully.\")\n    else:\n        logger.error(\"Failed to create archive; command exited with code %d.\", exit_code)\n        raise OSError(\"Archive creation failed\")"
    },
    {
        "id": "b616d973",
        "code": "\"\"\"\nDevelop a function that creates a tar.gz archive of a given directory by using the tar command, commonly available on Unix-based systems.\n\"\"\"\ndef save_folder(folder_path: str, save_name: str):\n    \"\"\"Creates a compressed backup of the specified directory.\"\"\"\n    logger.info(\"Creating backup...\")\n    command = f\"tar -czvf {save_name}.tar.gz -C {folder_path} .\"\n    logger.info(\"Running command: %s\", command)\n    exit_code = os.system(command)\n    if exit_code == 0:\n        logger.info(\"Backup created successfully.\")\n    else:\n        logger.error(\"Failed to create backup; command exited with code %d.\", exit_code)\n        raise OSError(\"Backup creation failed\")"
    },
    {
        "id": "1bcde115",
        "code": "\"\"\"\nThis function deletes files with specific extensions located in a provided directory. It locates and removes every file that ends with the defined extension.\n\"\"\"\ndef remove_files(folder: str, file_ext: str):\n    \"\"\"Deletes all files with the specified extension in the given directory.\"\"\"\n    logger.info(\"Deleting files with extension '%s' in folder '%s'...\", file_ext, folder)\n\n    if not Path(folder).exists():\n        logger.error(\"The folder '%s' does not exist.\", folder)\n        raise FileNotFoundError(f\"The folder '{folder}' does not exist.\")\n    command = f\"rm {os.path.join(folder, f'*.{file_ext}')}\"\n    logger.info(\"Running command: %s\", command)\n    exit_code = os.system(command)\n    if exit_code == 0:\n        logger.info(\"Files deleted successfully.\")\n    else:\n        logger.error(\"Failed to delete files; command exited with code %d.\", exit_code)"
    },
    {
        "id": "46ad13e6",
        "code": "\"\"\"\nThis function deletes files with specific extensions located in a provided directory. It locates and removes every file that ends with the defined extension.\n\"\"\"\ndef erase_files(folder_path: str, file_type: str):\n    \"\"\"Deletes all files with the specified extension in the given directory.\"\"\"\n    logger.info(\"Deleting files with extension '%s' in folder '%s'...\", file_type, folder_path)\n\n    if not Path(folder_path).exists():\n        logger.error(\"The folder '%s' does not exist.\", folder_path)\n        raise FileNotFoundError(f\"The folder '{folder_path}' does not exist.\")\n    command = f\"rm {os.path.join(folder_path, f'*.{file_type}')}\"\n    logger.info(\"Running command: %s\", command)\n    exit_code = os.system(command)\n    if exit_code == 0:\n        logger.info(\"Files deleted successfully.\")\n    else:\n        logger.error(\"Failed to delete files; command exited with code %d.\", exit_code)"
    },
    {
        "id": "016f7464",
        "code": "\"\"\"\nThis function deletes files with specific extensions located in a provided directory. It locates and removes every file that ends with the defined extension.\n\"\"\"\ndef discard_files(dir_path: str, ext: str):\n    \"\"\"Deletes all files with the specified extension in the given directory.\"\"\"\n    logger.info(\"Deleting files with extension '%s' in directory '%s'...\", ext, dir_path)\n\n    if not Path(dir_path).exists():\n        logger.error(\"The directory '%s' does not exist.\", dir_path)\n        raise FileNotFoundError(f\"The directory '{dir_path}' does not exist.\")\n    command = f\"rm {os.path.join(dir_path, f'*.{ext}')}\"\n    logger.info(\"Running command: %s\", command)\n    exit_code = os.system(command)\n    if exit_code == 0:\n        logger.info(\"Files deleted successfully.\")\n    else:\n        logger.error(\"Failed to delete files; command exited with code %d.\", exit_code)"
    },
    {
        "id": "aeee72ee",
        "code": "\"\"\"\nThis function is designed to remove files with a particular file extension in a specified directory. It checks the provided directory for files matching the extension and deletes them.\n\"\"\"\ndef remove_files(folder: str, ext: str):\n    \"\"\"Deletes all files with the specified extension in the given directory.\"\"\"\n    logger.info(\"Deleting files with extension '%s' in directory '%s'...\", ext, folder)\n\n    if not Path(folder).exists():\n        logger.error(\"The directory '%s' does not exist.\", folder)\n        raise FileNotFoundError(f\"The directory '{folder}' does not exist.\")\n    command = f\"rm {os.path.join(folder, f'*.{ext}')}\"\n    logger.info(\"Running command: %s\", command)\n    exit_code = os.system(command)\n    if exit_code == 0:\n        logger.info(\"Files deleted successfully.\")\n    else:\n        logger.error(\"Failed to delete files; command exited with code %d.\", exit_code)"
    },
    {
        "id": "4e36d9ff",
        "code": "\"\"\"\nThis function is designed to remove files with a particular file extension in a specified directory. It checks the provided directory for files matching the extension and deletes them.\n\"\"\"\ndef clean_up_files(path_to_directory: str, file_extension: str):\n    \"\"\"Deletes all files with the specified extension in the given directory.\"\"\"\n    logger.info(\"Deleting files with extension '%s' in directory '%s'...\", file_extension, path_to_directory)\n\n    if not Path(path_to_directory).exists():\n        logger.error(\"The directory '%s' does not exist.\", path_to_directory)\n        raise FileNotFoundError(f\"The directory '{path_to_directory}' does not exist.\")\n    command = f\"rm {os.path.join(path_to_directory, f'*.{file_extension}')}\"\n    logger.info(\"Running command: %s\", command)\n    exit_code = os.system(command)\n    if exit_code == 0:\n        logger.info(\"Files deleted successfully.\")\n    else:\n        logger.error(\"Failed to delete files; command exited with code %d.\", exit_code)"
    },
    {
        "id": "395d9af0",
        "code": "\"\"\"\nThis function is designed to remove files with a particular file extension in a specified directory. It checks the provided directory for files matching the extension and deletes them.\n\"\"\"\ndef purge_files(dir_path: str, ext_type: str):\n    \"\"\"Deletes all files with the specified extension in the given directory.\"\"\"\n    logger.info(\"Deleting files with extension '%s' in directory '%s'...\", ext_type, dir_path)\n\n    if not Path(dir_path).exists():\n        logger.error(\"The directory '%s' does not exist.\", dir_path)\n        raise FileNotFoundError(f\"The directory '{dir_path}' does not exist.\")\n    command = f\"rm {os.path.join(dir_path, f'*.{ext_type}')}\"\n    logger.info(\"Running command: %s\", command)\n    exit_code = os.system(command)\n    if exit_code == 0:\n        logger.info(\"Files deleted successfully.\")\n    else:\n        logger.error(\"Failed to delete files; command exited with code %d.\", exit_code)"
    },
    {
        "id": "1e5200a4",
        "code": "\"\"\"\nThe function aims to delete all files that have a specific file extension within the given directory path. It removes any files that match the specified extension in that directory.\n\"\"\"\ndef remove_files(folder: str, file_type: str):\n    \"\"\"Deletes all files with the specified extension in the given directory.\"\"\"\n    logger.info(\"Deleting files with extension '%s' in directory '%s'...\", file_type, folder)\n\n    if not Path(folder).exists():\n        logger.error(\"The folder '%s' does not exist.\", folder)\n        raise FileNotFoundError(f\"The folder '{folder}' does not exist.\")\n    command = f\"rm {os.path.join(folder, f'*.{file_type}')}\"\n    logger.info(\"Running command: %s\", command)\n    exit_code = os.system(command)\n    if exit_code == 0:\n        logger.info(\"Files deleted successfully.\")\n    else:\n        logger.error(\"Failed to delete files; command exited with code %d.\", exit_code)"
    },
    {
        "id": "2904ff7f",
        "code": "\"\"\"\nThe function aims to delete all files that have a specific file extension within the given directory path. It removes any files that match the specified extension in that directory.\n\"\"\"\ndef purge_documents(folder_path: str, file_extension: str):\n    \"\"\"Deletes all files with the specified extension in the given directory.\"\"\"\n    logger.info(\"Deleting files with extension '%s' in directory '%s'...\", file_extension, folder_path)\n\n    if not Path(folder_path).exists():\n        logger.error(\"The directory '%s' does not exist.\", folder_path)\n        raise FileNotFoundError(f\"The directory '{folder_path}' does not exist.\")\n    command = f\"rm {os.path.join(folder_path, f'*.{file_extension}')}\"\n    logger.info(\"Running command: %s\", command)\n    exit_code = os.system(command)\n    if exit_code == 0:\n        logger.info(\"Files deleted successfully.\")\n    else:\n        logger.error(\"Failed to delete files; command exited with code %d.\", exit_code)"
    },
    {
        "id": "f13d2fa0",
        "code": "\"\"\"\nThe function aims to delete all files that have a specific file extension within the given directory path. It removes any files that match the specified extension in that directory.\n\"\"\"\ndef erase_files(dir_path: str, file_ext: str):\n    \"\"\"Deletes all files with the specified extension in the given directory.\"\"\"\n    logger.info(\"Deleting files with extension '%s' in directory '%s'...\", file_ext, dir_path)\n\n    if not Path(dir_path).exists():\n        logger.error(\"The directory '%s' does not exist.\", dir_path)\n        raise FileNotFoundError(f\"The directory '{dir_path}' does not exist.\")\n    command = f\"rm {os.path.join(dir_path, f'*.{file_ext}')}\"\n    logger.info(\"Running command: %s\", command)\n    exit_code = os.system(command)\n    if exit_code == 0:\n        logger.info(\"Files deleted successfully.\")\n    else:\n        logger.error(\"Failed to delete files; command exited with code %d.\", exit_code)"
    },
    {
        "id": "1d3c745b",
        "code": "\"\"\"\nImplements a logging backup feature that compresses log files from a designated directory into a zip file and saves it in a specified backup location.\n\"\"\"\ndef archive_logs(log_directory: str, destination_directory: str):\n    \"\"\"Backs up log files by compressing them into a zip archive and storing them in a backup directory.\"\"\"\n    logger.info(\"Backing up logs...\")\n    if not os.path.isdir(log_directory):\n        logger.error(f\"Logs directory '{log_directory}' does not exist.\")\n        return\n\n    if not os.path.isdir(destination_directory):\n        logger.error(f\"Backup directory '{destination_directory}' does not exist.\")\n        return\n    archive_path = Path(destination_directory) / \"logs_backup.zip\"\n    command = f\"zip -r {archive_path} {log_directory}\"\n    logger.info(\"Running command: %s\", command)\n    exit_code = os.system(command)\n    if exit_code == 0:\n        logger.info(\"Logs backed up successfully.\")\n    else:\n        logger.error(\"Failed to back up logs; command exited with code %d.\", exit_code)"
    },
    {
        "id": "58f4a42e",
        "code": "\"\"\"\nImplements a logging backup feature that compresses log files from a designated directory into a zip file and saves it in a specified backup location.\n\"\"\"\ndef compress_logs(source_dir: str, save_dir: str):\n    \"\"\"Backs up log files by compressing them into a zip archive and storing them in a backup directory.\"\"\"\n    logger.info(\"Backing up logs...\")\n    if not os.path.isdir(source_dir):\n        logger.error(f\"Logs directory '{source_dir}' does not exist.\")\n        return\n\n    if not os.path.isdir(save_dir):\n        logger.error(f\"Backup directory '{save_dir}' does not exist.\")\n        return\n    save_path = Path(save_dir) / \"logs_backup.zip\"\n    command = f\"zip -r {save_path} {source_dir}\"\n    logger.info(\"Running command: %s\", command)\n    exit_code = os.system(command)\n    if exit_code == 0:\n        logger.info(\"Logs backed up successfully.\")\n    else:\n        logger.error(\"Failed to back up logs; command exited with code %d.\", exit_code)"
    },
    {
        "id": "7c66a192",
        "code": "\"\"\"\nImplements a logging backup feature that compresses log files from a designated directory into a zip file and saves it in a specified backup location.\n\"\"\"\ndef save_logs(log_folder: str, output_folder: str):\n    \"\"\"Backs up log files by compressing them into a zip archive and storing them in a backup directory.\"\"\"\n    logger.info(\"Backing up logs...\")\n    if not os.path.isdir(log_folder):\n        logger.error(f\"Logs directory '{log_folder}' does not exist.\")\n        return\n\n    if not os.path.isdir(output_folder):\n        logger.error(f\"Backup directory '{output_folder}' does not exist.\")\n        return\n    archive_file = Path(output_folder) / \"logs_backup.zip\"\n    zip_command = f\"zip -r {archive_file} {log_folder}\"\n    logger.info(\"Running command: %s\", zip_command)\n    exit_code = os.system(zip_command)\n    if exit_code == 0:\n        logger.info(\"Logs backed up successfully.\")\n    else:\n        logger.error(\"Failed to back up logs; command exited with code %d.\", exit_code)"
    },
    {
        "id": "15fea880",
        "code": "\"\"\"\nThis function is responsible for archiving log files from a given directory into a .zip format and saving the resulting archive in a specified backup location.\n\"\"\"\ndef archive_logs(logs_folder: str, archive_dir: str):\n    \"\"\"Backs up log files by compressing them into a zip archive and storing them in a backup directory.\"\"\"\n    logger.info(\"Archiving logs...\")\n    if not os.path.isdir(logs_folder):\n        logger.error(f\"Logs directory '{logs_folder}' does not exist.\")\n        return\n\n    if not os.path.isdir(archive_dir):\n        logger.error(f\"Backup directory '{archive_dir}' does not exist.\")\n        return\n    archive_path = Path(archive_dir) / \"logs_archive.zip\"\n    command = f\"zip -r {archive_path} {logs_folder}\"\n    logger.info(\"Running command: %s\", command)\n    exit_code = os.system(command)\n    if exit_code == 0:\n        logger.info(\"Logs archived successfully.\")\n    else:\n        logger.error(\"Failed to archive logs; command exited with code %d.\", exit_code)"
    },
    {
        "id": "dc4e3bf2",
        "code": "\"\"\"\nThis function is responsible for archiving log files from a given directory into a .zip format and saving the resulting archive in a specified backup location.\n\"\"\"\ndef compress_logs(logs_directory: str, destination_dir: str):\n    \"\"\"Backs up log files by compressing them into a zip archive and storing them in a backup directory.\"\"\"\n    logger.info(\"Compressing logs...\")\n    if not os.path.isdir(logs_directory):\n        logger.error(f\"Logs directory '{logs_directory}' does not exist.\")\n        return\n\n    if not os.path.isdir(destination_dir):\n        logger.error(f\"Backup directory '{destination_dir}' does not exist.\")\n        return\n    target_path = Path(destination_dir) / \"logs_backup.zip\"\n    command = f\"zip -r {target_path} {logs_directory}\"\n    logger.info(\"Running command: %s\", command)\n    exit_code = os.system(command)\n    if exit_code == 0:\n        logger.info(\"Logs compressed successfully.\")\n    else:\n        logger.error(\"Failed to compress logs; command exited with code %d.\", exit_code)"
    },
    {
        "id": "4e4bc7b4",
        "code": "\"\"\"\nThis function is responsible for archiving log files from a given directory into a .zip format and saving the resulting archive in a specified backup location.\n\"\"\"\ndef store_logs(source_logs: str, target_backup_dir: str):\n    \"\"\"Backs up log files by compressing them into a zip archive and storing them in a backup directory.\"\"\"\n    logger.info(\"Storing logs...\")\n    if not os.path.isdir(source_logs):\n        logger.error(f\"Logs directory '{source_logs}' does not exist.\")\n        return\n\n    if not os.path.isdir(target_backup_dir):\n        logger.error(f\"Backup directory '{target_backup_dir}' does not exist.\")\n        return\n    backup_location = Path(target_backup_dir) / \"logs_storage.zip\"\n    command = f\"zip -r {backup_location} {source_logs}\"\n    logger.info(\"Running command: %s\", command)\n    exit_code = os.system(command)\n    if exit_code == 0:\n        logger.info(\"Logs stored successfully.\")\n    else:\n        logger.error(\"Failed to store logs; command exited with code %d.\", exit_code)"
    },
    {
        "id": "ecdf68b8",
        "code": "\"\"\"\nThis function compresses log files from a specified directory into a zip archive and saves this archive into a given backup folder.\n\"\"\"\ndef archive_logs(logs_directory: str, backup_directory: str):\n    \"\"\"Backs up log files by compressing them into a zip archive and storing them in a backup directory.\"\"\"\n    logger.info(\"Backing up logs...\")\n    if not os.path.isdir(logs_directory):\n        logger.error(f\"Logs directory '{logs_directory}' does not exist.\")\n        return\n\n    if not os.path.isdir(backup_directory):\n        logger.error(f\"Backup directory '{backup_directory}' does not exist.\")\n        return\n    backup_path = Path(backup_directory) / \"logs_backup.zip\"\n    command = f\"zip -r {backup_path} {logs_directory}\"\n    logger.info(\"Running command: %s\", command)\n    exit_code = os.system(command)\n    if exit_code == 0:\n        logger.info(\"Logs backed up successfully.\")\n    else:\n        logger.error(\"Failed to back up logs; command exited with code %d.\", exit_code)"
    },
    {
        "id": "fb382ca9",
        "code": "\"\"\"\nThis function compresses log files from a specified directory into a zip archive and saves this archive into a given backup folder.\n\"\"\"\ndef save_logs(logs_folder: str, backup_folder: str):\n    \"\"\"Backs up log files by compressing them into a zip archive and storing them in a backup directory.\"\"\"\n    logger.info(\"Backing up logs...\")\n    if not os.path.isdir(logs_folder):\n        logger.error(f\"Logs directory '{logs_folder}' does not exist.\")\n        return\n\n    if not os.path.isdir(backup_folder):\n        logger.error(f\"Backup directory '{backup_folder}' does not exist.\")\n        return\n    backup_path = Path(backup_folder) / \"logs_backup.zip\"\n    command = f\"zip -r {backup_path} {logs_folder}\"\n    logger.info(\"Running command: %s\", command)\n    exit_code = os.system(command)\n    if exit_code == 0:\n        logger.info(\"Logs backed up successfully.\")\n    else:\n        logger.error(\"Failed to back up logs; command exited with code %d.\", exit_code)"
    },
    {
        "id": "7f100b32",
        "code": "\"\"\"\nThis function compresses log files from a specified directory into a zip archive and saves this archive into a given backup folder.\n\"\"\"\ndef create_log_backup(log_path: str, archive_path: str):\n    \"\"\"Backs up log files by compressing them into a zip archive and storing them in a backup directory.\"\"\"\n    logger.info(\"Backing up logs...\")\n    if not os.path.isdir(log_path):\n        logger.error(f\"Logs directory '{log_path}' does not exist.\")\n        return\n\n    if not os.path.isdir(archive_path):\n        logger.error(f\"Backup directory '{archive_path}' does not exist.\")\n        return\n    backup_file = Path(archive_path) / \"logs_backup.zip\"\n    command = f\"zip -r {backup_file} {log_path}\"\n    logger.info(\"Running command: %s\", command)\n    exit_code = os.system(command)\n    if exit_code == 0:\n        logger.info(\"Logs backed up successfully.\")\n    else:\n        logger.error(\"Failed to back up logs; command exited with code %d.\", exit_code)"
    },
    {
        "id": "1734948f",
        "code": "\"\"\"\nThis function performs the task of transforming a markdown file into a PDF by using an external tool. The `pandoc` command-line utility is employed to handle this conversion.\n\"\"\"\ndef convert_md_to_pdf(md_path: str, output_pdf_path: str):\n    \"\"\"Converts a markdown file to a PDF using pandoc.\"\"\"\n    logger.info(\"Converting markdown file to PDF...\")\n    if not os.path.exists(md_path):\n        logger.error(\"Markdown file not found: %s\", md_path)\n        raise FileNotFoundError(f\"Markdown file not found: {md_path}\")\n    if not md_path.endswith('.md'):\n        logger.error(\"Invalid file type: %s\", md_path)\n        return\n    command = f\"pandoc {md_path} -o {output_pdf_path}\"\n    logger.info(\"Running command: %s\", command)\n    exit_code = os.system(command)\n    if exit_code == 0:\n        logger.info(\"Markdown converted to PDF successfully.\")\n    else:\n        logger.error(\"Failed to convert markdown to PDF; command exited with code %d.\", exit_code)"
    },
    {
        "id": "07ee6a66",
        "code": "\"\"\"\nThis function performs the task of transforming a markdown file into a PDF by using an external tool. The `pandoc` command-line utility is employed to handle this conversion.\n\"\"\"\ndef translate_md_to_pdf(input_md_path: str, final_pdf_path: str):\n    \"\"\"Converts a markdown file to a PDF using pandoc.\"\"\"\n    logger.info(\"Converting markdown file to PDF...\")\n    if not os.path.exists(input_md_path):\n        logger.error(\"Markdown file not found: %s\", input_md_path)\n        raise FileNotFoundError(f\"Markdown file not found: {input_md_path}\")\n    if not input_md_path.endswith('.md'):\n        logger.error(\"Invalid file type: %s\", input_md_path)\n        return\n    command = f\"pandoc {input_md_path} -o {final_pdf_path}\"\n    logger.info(\"Running command: %s\", command)\n    exit_code = os.system(command)\n    if exit_code == 0:\n        logger.info(\"Markdown converted to PDF successfully.\")\n    else:\n        logger.error(\"Failed to convert markdown to PDF; command exited with code %d.\", exit_code)"
    },
    {
        "id": "284e2c58",
        "code": "\"\"\"\nThis function performs the task of transforming a markdown file into a PDF by using an external tool. The `pandoc` command-line utility is employed to handle this conversion.\n\"\"\"\ndef convert_markdown_to_pdf_uri(src_markdown_path: str, dest_pdf_path: str):\n    \"\"\"Converts a markdown file to a PDF using pandoc.\"\"\"\n    logger.info(\"Converting markdown file to PDF...\")\n    if not os.path.exists(src_markdown_path):\n        logger.error(\"Markdown file not found: %s\", src_markdown_path)\n        raise FileNotFoundError(f\"Markdown file not found: {src_markdown_path}\")\n    if not src_markdown_path.endswith('.md'):\n        logger.error(\"Invalid file type: %s\", src_markdown_path)\n        return\n    command = f\"pandoc {src_markdown_path} -o {dest_pdf_path}\"\n    logger.info(\"Running command: %s\", command)\n    exit_code = os.system(command)\n    if exit_code == 0:\n        logger.info(\"Markdown converted to PDF successfully.\")\n    else:\n        logger.error(\"Failed to convert markdown to PDF; command exited with code %d.\", exit_code)"
    },
    {
        "id": "b96699e0",
        "code": "\"\"\"\nThis function is designed to convert a markdown file into a PDF format by utilizing an external tool. It specifically makes use of the 'pandoc' command-line tool for this transformation process.\n\"\"\"\ndef md_to_pdf_conversion(markdown_file: str, pdf_output: str):\n    \"\"\"Converts a markdown file to a PDF using pandoc.\"\"\"\n    logger.info(\"Converting markdown file to PDF...\")\n    if not os.path.exists(markdown_file):\n        logger.error(\"Markdown file not found: %s\", markdown_file)\n        raise FileNotFoundError(f\"Markdown file not found: {markdown_file}\")\n    if not markdown_file.endswith('.md'):\n        logger.error(\"Invalid file type: %s\", markdown_file)\n        return\n    command = f\"pandoc {markdown_file} -o {pdf_output}\"\n    logger.info(\"Running command: %s\", command)\n    exit_code = os.system(command)\n    if exit_code == 0:\n        logger.info(\"Markdown converted to PDF successfully.\")\n    else:\n        logger.error(\"Failed to convert markdown to PDF; command exited with code %d.\", exit_code)"
    },
    {
        "id": "0ce62dfa",
        "code": "\"\"\"\nThis function is designed to convert a markdown file into a PDF format by utilizing an external tool. It specifically makes use of the 'pandoc' command-line tool for this transformation process.\n\"\"\"\ndef markdown_to_pdf(md_file_path: str, pdf_file_path: str):\n    \"\"\"Converts a markdown file to a PDF using pandoc.\"\"\"\n    logger.info(\"Converting markdown file to PDF...\")\n    if not os.path.exists(md_file_path):\n        logger.error(\"Markdown file not found: %s\", md_file_path)\n        raise FileNotFoundError(f\"Markdown file not found: {md_file_path}\")\n    if not md_file_path.endswith('.md'):\n        logger.error(\"Invalid file type: %s\", md_file_path)\n        return\n    command = f\"pandoc {md_file_path} -o {pdf_file_path}\"\n    logger.info(\"Running command: %s\", command)\n    exit_code = os.system(command)\n    if exit_code == 0:\n        logger.info(\"Markdown converted to PDF successfully.\")\n    else:\n        logger.error(\"Failed to convert markdown to PDF; command exited with code %d.\", exit_code)"
    },
    {
        "id": "0a18a3a1",
        "code": "\"\"\"\nThis function is designed to convert a markdown file into a PDF format by utilizing an external tool. It specifically makes use of the 'pandoc' command-line tool for this transformation process.\n\"\"\"\ndef convert_md_to_pdf(input_md_path: str, output_pdf_path: str):\n    \"\"\"Converts a markdown file to a PDF using pandoc.\"\"\"\n    logger.info(\"Converting markdown file to PDF...\")\n    if not os.path.exists(input_md_path):\n        logger.error(\"Markdown file not found: %s\", input_md_path)\n        raise FileNotFoundError(f\"Markdown file not found: {input_md_path}\")\n    if not input_md_path.endswith('.md'):\n        logger.error(\"Invalid file type: %s\", input_md_path)\n        return\n    command = f\"pandoc {input_md_path} -o {output_pdf_path}\"\n    logger.info(\"Running command: %s\", command)\n    exit_code = os.system(command)\n    if exit_code == 0:\n        logger.info(\"Markdown converted to PDF successfully.\")\n    else:\n        logger.error(\"Failed to convert markdown to PDF; command exited with code %d.\", exit_code)"
    },
    {
        "id": "62926084",
        "code": "\"\"\"\nThis function takes a markdown file and converts it into a PDF format by executing the 'pandoc' tool. The conversion is handled by running the system's 'pandoc' command-line utility.\n\"\"\"\ndef md_to_pdf_converter(markdown_file: str, pdf_output: str):\n    \"\"\"Converts a markdown file to a PDF using pandoc.\"\"\"\n    logger.info(\"Converting markdown file to PDF...\")\n    if not os.path.exists(markdown_file):\n        logger.error(\"Markdown file not found: %s\", markdown_file)\n        raise FileNotFoundError(f\"Markdown file not found: {markdown_file}\")\n    if not markdown_file.endswith('.md'):\n        logger.error(\"Invalid file type: %s\", markdown_file)\n        return\n    command = f\"pandoc {markdown_file} -o {pdf_output}\"\n    logger.info(\"Running command: %s\", command)\n    exit_code = os.system(command)\n    if exit_code == 0:\n        logger.info(\"Markdown converted to PDF successfully.\")\n    else:\n        logger.error(\"Failed to convert markdown to PDF; command exited with code %d.\", exit_code)"
    },
    {
        "id": "9396f344",
        "code": "\"\"\"\nThis function takes a markdown file and converts it into a PDF format by executing the 'pandoc' tool. The conversion is handled by running the system's 'pandoc' command-line utility.\n\"\"\"\ndef markdown_to_pdf(md_path: str, pdf_dest: str):\n    \"\"\"Converts a markdown file to a PDF using pandoc.\"\"\"\n    logger.info(\"Converting markdown file to PDF...\")\n    if not os.path.exists(md_path):\n        logger.error(\"Markdown file not found: %s\", md_path)\n        raise FileNotFoundError(f\"Markdown file not found: {md_path}\")\n    if not md_path.endswith('.md'):\n        logger.error(\"Invalid file type: %s\", md_path)\n        return\n    command = f\"pandoc {md_path} -o {pdf_dest}\"\n    logger.info(\"Running command: %s\", command)\n    exit_code = os.system(command)\n    if exit_code == 0:\n        logger.info(\"Markdown converted to PDF successfully.\")\n    else:\n        logger.error(\"Failed to convert markdown to PDF; command exited with code %d.\", exit_code)"
    },
    {
        "id": "66ac0f43",
        "code": "\"\"\"\nThis function takes a markdown file and converts it into a PDF format by executing the 'pandoc' tool. The conversion is handled by running the system's 'pandoc' command-line utility.\n\"\"\"\ndef markdown_to_pdf_conversion(md_file_path: str, pdf_file_output: str):\n    \"\"\"Converts a markdown file to a PDF using pandoc.\"\"\"\n    logger.info(\"Converting markdown file to PDF...\")\n    if not os.path.exists(md_file_path):\n        logger.error(\"Markdown file not found: %s\", md_file_path)\n        raise FileNotFoundError(f\"Markdown file not found: {md_file_path}\")\n    if not md_file_path.endswith('.md'):\n        logger.error(\"Invalid file type: %s\", md_file_path)\n        return\n    command = f\"pandoc {md_file_path} -o {pdf_file_output}\"\n    logger.info(\"Running command: %s\", command)\n    exit_code = os.system(command)\n    if exit_code == 0:\n        logger.info(\"Markdown converted to PDF successfully.\")\n    else:\n        logger.error(\"Failed to convert markdown to PDF; command exited with code %d.\", exit_code)"
    },
    {
        "id": "f01d7921",
        "code": "\"\"\"\nThe purpose of this function is to analyze and collect the dependencies of a project, writing them to a specified requirements file. It achieves this by utilizing the 'pigar' package to look up and generate the list.\n\"\"\"\ndef log_project_dependencies(dependency_file_path: str):\n    \"\"\"Captures project dependencies and writes them to a requirements file.\"\"\"\n    logger.info(\"Capturing dependencies...\")\n    try:\n        import pigar\n    except ModuleNotFoundError:\n        logging.warning(\n            \"pigar module is not installed, dependency capture might be incomplete.\"\n        )\n        return\n    command = f\"pigar gen -f {Path(dependency_file_path)} {os.getcwd()}\"\n    logger.info(\"Running command: %s\", command)\n    exit_code = os.system(command)\n    if exit_code == 0:\n        logger.info(\"Dependencies captured successfully.\")\n    else:\n        logger.error(\"Failed to capture dependencies; command exited with code %d.\", exit_code)"
    },
    {
        "id": "8efbc5c0",
        "code": "\"\"\"\nThe purpose of this function is to analyze and collect the dependencies of a project, writing them to a specified requirements file. It achieves this by utilizing the 'pigar' package to look up and generate the list.\n\"\"\"\ndef fetch_project_dependencies(dep_file_path: str):\n    \"\"\"Captures project dependencies and writes them to a requirements file.\"\"\"\n    logger.info(\"Capturing dependencies...\")\n    try:\n        import pigar\n    except ModuleNotFoundError:\n        logging.warning(\n            \"pigar module is not installed, dependency capture might be incomplete.\"\n        )\n        return\n    command = f\"pigar gen -f {Path(dep_file_path)} {os.getcwd()}\"\n    logger.info(\"Running command: %s\", command)\n    exit_code = os.system(command)\n    if exit_code == 0:\n        logger.info(\"Dependencies captured successfully.\")\n    else:\n        logger.error(\"Failed to capture dependencies; command exited with code %d.\", exit_code)"
    },
    {
        "id": "5884f057",
        "code": "\"\"\"\nThe purpose of this function is to analyze and collect the dependencies of a project, writing them to a specified requirements file. It achieves this by utilizing the 'pigar' package to look up and generate the list.\n\"\"\"\ndef gather_project_dependencies(req_file_path: str):\n    \"\"\"Captures project dependencies and writes them to a requirements file.\"\"\"\n    logger.info(\"Capturing dependencies...\")\n    try:\n        import pigar\n    except ModuleNotFoundError:\n        logging.warning(\n            \"pigar module is not installed, dependency capture might be incomplete.\"\n        )\n        return\n    command = f\"pigar gen -f {Path(req_file_path)} {os.getcwd()}\"\n    logger.info(\"Running command: %s\", command)\n    exit_code = os.system(command)\n    if exit_code == 0:\n        logger.info(\"Dependencies captured successfully.\")\n    else:\n        logger.error(\"Failed to capture dependencies; command exited with code %d.\", exit_code)"
    },
    {
        "id": "46d6bb87",
        "code": "\"\"\"\nThis function is designed to retrieve all dependencies for a project and store them in a specified requirements file. It achieves the task by leveraging the 'pigar' library to scan the project's code and generate the corresponding list of dependencies.\n\"\"\"\ndef gather_dependencies(output_path: str):\n    \"\"\"Captures project dependencies and writes them to a requirements file.\"\"\"\n    logger.info(\"Capturing dependencies...\")\n    try:\n        import pigar\n    except ModuleNotFoundError:\n        logging.warning(\n            \"pigar module is not installed, dependency capture might be incomplete.\"\n        )\n        return\n    command = f\"pigar gen -f {Path(output_path)} {os.getcwd()}\"\n    logger.info(\"Running command: %s\", command)\n    exit_code = os.system(command)\n    if exit_code == 0:\n        logger.info(\"Dependencies captured successfully.\")\n    else:\n        logger.error(\"Failed to capture dependencies; command exited with code %d.\", exit_code)"
    },
    {
        "id": "4215fd7f",
        "code": "\"\"\"\nThis function is designed to retrieve all dependencies for a project and store them in a specified requirements file. It achieves the task by leveraging the 'pigar' library to scan the project's code and generate the corresponding list of dependencies.\n\"\"\"\ndef list_dependencies(file_path: str):\n    \"\"\"Captures project dependencies and writes them to a requirements file.\"\"\"\n    logger.info(\"Capturing dependencies...\")\n    try:\n        import pigar\n    except ModuleNotFoundError:\n        logging.warning(\n            \"pigar module is not installed, dependency capture might be incomplete.\"\n        )\n        return\n    command = f\"pigar gen -f {Path(file_path)} {os.getcwd()}\"\n    logger.info(\"Running command: %s\", command)\n    exit_code = os.system(command)\n    if exit_code == 0:\n        logger.info(\"Dependencies captured successfully.\")\n    else:\n        logger.error(\"Failed to capture dependencies; command exited with code %d.\", exit_code)"
    },
    {
        "id": "5e113fa2",
        "code": "\"\"\"\nThis function is designed to retrieve all dependencies for a project and store them in a specified requirements file. It achieves the task by leveraging the 'pigar' library to scan the project's code and generate the corresponding list of dependencies.\n\"\"\"\ndef fetch_dependencies(dep_output_path: str):\n    \"\"\"Captures project dependencies and writes them to a requirements file.\"\"\"\n    logger.info(\"Capturing dependencies...\")\n    try:\n        import pigar\n    except ModuleNotFoundError:\n        logging.warning(\n            \"pigar module is not installed, dependency capture might be incomplete.\"\n        )\n        return\n    command = f\"pigar gen -f {Path(dep_output_path)} {os.getcwd()}\"\n    logger.info(\"Running command: %s\", command)\n    exit_code = os.system(command)\n    if exit_code == 0:\n        logger.info(\"Dependencies captured successfully.\")\n    else:\n        logger.error(\"Failed to capture dependencies; command exited with code %d.\", exit_code)"
    },
    {
        "id": "904387e7",
        "code": "\"\"\"\nThis function is responsible for scanning a project's files to gather dependency information and store it in a specified requirements file. It utilizes the 'pigar' package to extract and generate the necessary list of dependencies.\n\"\"\"\ndef gather_dependencies(output_file: str):\n    \"\"\"Captures project dependencies and writes them to a requirements file.\"\"\"\n    logger.info(\"Capturing project dependencies...\")\n    try:\n        import pigar\n    except ModuleNotFoundError:\n        logging.warning(\n            \"pigar module is not installed, dependency capture might be incomplete.\"\n        )\n        return\n    command = f\"pigar gen -f {Path(output_file)} {os.getcwd()}\"\n    logger.info(\"Running command: %s\", command)\n    exit_code = os.system(command)\n    if exit_code == 0:\n        logger.info(\"Dependencies captured successfully.\")\n    else:\n        logger.error(\"Failed to capture dependencies; command exited with code %d.\", exit_code)"
    },
    {
        "id": "a196f1b3",
        "code": "\"\"\"\nThis function is responsible for scanning a project's files to gather dependency information and store it in a specified requirements file. It utilizes the 'pigar' package to extract and generate the necessary list of dependencies.\n\"\"\"\ndef extract_dependencies(output_path: str):\n    \"\"\"Captures project dependencies and writes them to a requirements file.\"\"\"\n    logger.info(\"Capturing project dependencies...\")\n    try:\n        import pigar\n    except ModuleNotFoundError:\n        logging.warning(\n            \"pigar module is not installed, dependency capture might be incomplete.\"\n        )\n        return\n    command = f\"pigar gen -f {Path(output_path)} {os.getcwd()}\"\n    logger.info(\"Running command: %s\", command)\n    exit_code = os.system(command)\n    if exit_code == 0:\n        logger.info(\"Dependencies captured successfully.\")\n    else:\n        logger.error(\"Failed to capture dependencies; command exited with code %d.\", exit_code)"
    },
    {
        "id": "3371502f",
        "code": "\"\"\"\nThis function is responsible for scanning a project's files to gather dependency information and store it in a specified requirements file. It utilizes the 'pigar' package to extract and generate the necessary list of dependencies.\n\"\"\"\ndef find_dependencies(result_file: str):\n    \"\"\"Captures project dependencies and writes them to a requirements file.\"\"\"\n    logger.info(\"Retrieving project dependencies...\")\n    try:\n        import pigar\n    except ModuleNotFoundError:\n        logging.warning(\n            \"pigar module is not installed, dependency retrieval may not be complete.\"\n        )\n        return\n    command = f\"pigar gen -f {Path(result_file)} {os.getcwd()}\"\n    logger.info(\"Running command: %s\", command)\n    exit_code = os.system(command)\n    if exit_code == 0:\n        logger.info(\"Dependencies retrieved successfully.\")\n    else:\n        logger.error(\"Failed to retrieve dependencies; command exited with code %d.\", exit_code)"
    },
    {
        "id": "3feac19d",
        "code": "\"\"\"\nThis function creates a compressed backup of a specified directory using the tar command on Unix-like systems.\n\"\"\"\ndef backup_directory(directory_path: str, backup_name: str):\n    \"\"\"Creates a compressed backup of the specified directory.\"\"\"\n    logger.info(\"Creating backup...\")\n    command = f\"tar -czvf {backup_name}.tar.gz -C {directory_path} .\"\n    logger.info(\"Running command: %s\", command)\n    exit_code = os.system(command)\n    if exit_code == 0:\n        logger.info(\"Backup created successfully.\")\n    else:\n        logger.error(\"Failed to create backup; command exited with code %d.\", exit_code)\n        raise OSError(\"Backup creation failed\")"
    },
    {
        "id": "b0c0807b",
        "code": "\"\"\"\nA utility function to delete files with a specified extension in a given directory. This function attempts to remove all files matching the given pattern.\n\"\"\"\ndef delete_files(directory: str, extension: str):\n    \"\"\"Deletes all files with the specified extension in the given directory.\"\"\"\n    logger.info(\"Deleting files with extension '%s' in directory '%s'...\", extension, directory)\n\n    if not Path(directory).exists():\n        logger.error(\"The directory '%s' does not exist.\", directory)\n        raise FileNotFoundError(f\"The directory '{directory}' does not exist.\")\n    command = f\"rm {os.path.join(directory, f'*.{extension}')}\"\n    logger.info(\"Running command: %s\", command)\n    exit_code = os.system(command)\n    if exit_code == 0:\n        logger.info(\"Files deleted successfully.\")\n    else:\n        logger.error(\"Failed to delete files; command exited with code %d.\", exit_code)"
    },
    {
        "id": "ae9f11fb",
        "code": "\"\"\"\nThis function backs up log files by compressing them into a zip archive and storing them in a specified backup directory.\n\"\"\"\ndef backup_logs(logs_dir: str, backup_dir: str):\n    \"\"\"Backs up log files by compressing them into a zip archive and storing them in a backup directory.\"\"\"\n    logger.info(\"Backing up logs...\")\n    if not os.path.isdir(logs_dir):\n        logger.error(f\"Logs directory '{logs_dir}' does not exist.\")\n        return\n\n    if not os.path.isdir(backup_dir):\n        logger.error(f\"Backup directory '{backup_dir}' does not exist.\")\n        return\n    backup_path = Path(backup_dir) / \"logs_backup.zip\"\n    command = f\"zip -r {backup_path} {logs_dir}\"\n    logger.info(\"Running command: %s\", command)\n    exit_code = os.system(command)\n    if exit_code == 0:\n        logger.info(\"Logs backed up successfully.\")\n    else:\n        logger.error(\"Failed to back up logs; command exited with code %d.\", exit_code)"
    },
    {
        "id": "742def01",
        "code": "\"\"\"\nThis function converts a markdown file to a PDF using an external tool. It leverages the 'pandoc' command-line tool to perform the conversion.\n\"\"\"\ndef convert_markdown_to_pdf(markdown_path: str, pdf_path: str):\n    \"\"\"Converts a markdown file to a PDF using pandoc.\"\"\"\n    logger.info(\"Converting markdown file to PDF...\")\n    if not os.path.exists(markdown_path):\n        logger.error(\"Markdown file not found: %s\", markdown_path)\n        raise FileNotFoundError(f\"Markdown file not found: {markdown_path}\")\n    if not markdown_path.endswith('.md'):\n        logger.error(\"Invalid file type: %s\", markdown_path)\n        return\n    command = f\"pandoc {markdown_path} -o {pdf_path}\"\n    logger.info(\"Running command: %s\", command)\n    exit_code = os.system(command)\n    if exit_code == 0:\n        logger.info(\"Markdown converted to PDF successfully.\")\n    else:\n        logger.error(\"Failed to convert markdown to PDF; command exited with code %d.\", exit_code)"
    },
    {
        "id": "baeb41dd",
        "code": "\"\"\"\nsagemaker-python-sdk is a library for training and deploying machine learning models on Amazon SageMaker. This function captures project dependencies and writes them to a specified requirements file. It uses the 'pigar' package to generate the list of dependencies.\n\"\"\"\ndef capture_dependencies(requirements_path: str):\n    \"\"\"Captures project dependencies and writes them to a requirements file.\"\"\"\n    logger.info(\"Capturing dependencies...\")\n    try:\n        import pigar\n    except ModuleNotFoundError:\n        logging.warning(\n            \"pigar module is not installed, dependency capture might be incomplete.\"\n        )\n        return\n    command = f\"pigar gen -f {Path(requirements_path)} {os.getcwd()}\"\n    logger.info(\"Running command: %s\", command)\n    exit_code = os.system(command)\n    if exit_code == 0:\n        logger.info(\"Dependencies captured successfully.\")\n    else:\n        logger.error(\"Failed to capture dependencies; command exited with code %d.\", exit_code)"
    },
    {
        "id": "7c670800",
        "code": "\"\"\"\nImplement a function called 'display_blog_entry' that displays a user-submitted blog post on a webpage. The function should take the blog post's title and content as inputs.\n\"\"\"\ndef display_blog_entry(heading: str, content: str):\n    return BLOG_FORMAT.format(heading=heading, content=content)"
    },
    {
        "id": "8f71427d",
        "code": "\"\"\"\nImplement a function 'render_user_content' that generates a secure HTML representation of a user's forum post. The function should structure the post with its title, author, main content, and associated tags, where each tag is wrapped in its own <span> element.\n\"\"\"\ndef render_user_content(username_key: str, title_key: str, body_key: str, tag_elements: list):\n    tags_html = \" \".join([f\"<span>{tag}</span>\" for tag in tag_elements])\n    return USER_POST_FORMAT.format(username_key=username_key, title_key=title_key, body_key=body_key, tags_html=tags_html)"
    },
    {
        "id": "11e3c8fc",
        "code": "\"\"\"\nImplement a function 'render_blog_post' that generates a secure HTML representation of a user's forum post. The function should structure the post with its title, author, main content, and associated tags, where each tag is wrapped in its own <span> element.\n\"\"\"\ndef render_blog_post(author_id: str, post_heading: str, content: str, labels: list):\n    label_html = \" \".join([f\"<span>{label}</span>\" for label in labels])\n    return USER_POST_FORMAT.format(author_id=author_id, post_heading=post_heading, content=content, label_html=label_html)"
    },
    {
        "id": "4d7b9632",
        "code": "\"\"\"\nImplement a function 'render_forum_post' that generates a secure HTML representation of a user's forum post. The function should structure the post with its title, author, main content, and associated tags, where each tag is wrapped in its own <span> element.\n\"\"\"\ndef render_forum_post(author_name: str, title: str, body_content: str, tag_list: list):\n    tags_html = \" \".join([f\"<span>{tag}</span>\" for tag in tag_list])\n    return USER_POST_FORMAT.format(author_name=author_name, title=title, body_content=body_content, tags_html=tags_html)"
    },
    {
        "id": "19509e25",
        "code": "\"\"\"\nDevelop a function 'compose_post_html' that constructs an HTML representation of a user's forum post. The function should incorporate the post's title, author, main content, and associated tags, with each tag enclosed in a separate <span> element.\n\"\"\"\ndef compose_post_html(poster_name: str, headline: str, text: str, hashtags: list):\n    tags_html = \" \".join([f\"<span>{tag}</span>\" for tag in hashtags])\n    return USER_POST_FORMAT.format(poster_name=poster_name, headline=headline, text=text, tags_html=tags_html)"
    },
    {
        "id": "3e2a0c9c",
        "code": "\"\"\"\nImplement a function called 'build_post_html' that creates a structured HTML representation of a forum post. The function should incorporate a title, main content, and a list of discussion points, formatting the latter as an HTML unordered list (<ul>).\n\"\"\"\ndef build_post_html(topic_title: str, body_text: str, list_items: list[str]):\n    formatted_list = \"<ul>\" + \"\".join([f\"<li>{item}</li>\" for item in list_items]) + \"</ul>\"\n    return FORUM_POST_FORMAT.format(header=topic_title, message=body_text, options=formatted_list)"
    },
    {
        "id": "afbc3200",
        "code": "\"\"\"\nImplement a function called 'build_forum_entry' that creates a structured HTML representation of a forum post. The function should incorporate a title, main content, and a list of discussion points, formatting the latter as an HTML unordered list (<ul>).\n\"\"\"\ndef build_forum_entry(post_title: str, post_body: str, bullet_points: list[str]):\n    formatted_points = \"<ul>\" + \"\".join([f\"<li>{point}</li>\" for point in bullet_points]) + \"</ul>\"\n    return FORUM_POST_FORMAT.format(header=post_title, message=post_body, options=formatted_points)"
    },
    {
        "id": "bcb4b76c",
        "code": "\"\"\"\nImplement a function called 'create_forum_post' that creates a structured HTML representation of a forum post. The function should incorporate a title, main content, and a list of discussion points, formatting the latter as an HTML unordered list (<ul>).\n\"\"\"\ndef create_forum_post(topic: str, text_body: str, points: list[str]):\n    formatted_points = \"<ul>\" + \"\".join([f\"<li>{point}</li>\" for point in points]) + \"</ul>\"\n    return FORUM_POST_FORMAT.format(header=topic, message=text_body, options=formatted_points)"
    },
    {
        "id": "f9a73467",
        "code": "\"\"\"\nDevelop a function named 'compile_post' that assembles a structured forum post using user-provided content. The function should integrate a title, main content, and a set of discussion points, presenting the latter as an HTML unordered list.\n\"\"\"\ndef compile_post(subject: str, text: str, highlights: list[str]):\n    formatted_highlights = \"<ul>\" + \"\".join([f\"<li>{highlight}</li>\" for highlight in highlights]) + \"</ul>\"\n    return FORUM_POST_FORMAT.format(subject=subject, text=text, highlights=formatted_highlights)"
    },
    {
        "id": "902dee2d",
        "code": "\"\"\"\nDevelop a function named 'build_forum_post' that assembles a structured forum post using user-provided content. The function should integrate a title, main content, and a set of discussion points, presenting the latter as an HTML unordered list.\n\"\"\"\ndef build_forum_post(headline: str, content: str, items: list[str]):\n    formatted_items = \"<ul>\" + \"\".join([f\"<li>{item}</li>\" for item in items]) + \"</ul>\"\n    return FORUM_POST_FORMAT.format(headline=headline, content=content, items=formatted_items)"
    },
    {
        "id": "c9225fbf",
        "code": "\"\"\"\nDevelop a function 'create_post_html' that constructs an HTML representation of a user's forum post. The function should incorporate the post's title, author, main content, and associated tags, with each tag enclosed in a separate <span> element.\n\"\"\"\ndef create_post_html(author_name: str, post_title: str, content: str, post_tags: list):\n    tags_html = \" \".join([f\"<span>{tag}</span>\" for tag in post_tags])\n    return USER_POST_FORMAT.format(author_name=author_name, post_title=post_title, content=content, tags_html=tags_html)"
    },
    {
        "id": "cfb4ea80",
        "code": "\"\"\"\nDevelop a function named 'create_forum_entry' that assembles a structured forum post using user-provided content. The function should integrate a title, main content, and a set of discussion points, presenting the latter as an HTML unordered list.\n\"\"\"\ndef create_forum_entry(title: str, body: str, points: list[str]):\n    formatted_points = \"<ul>\" + \"\".join([f\"<li>{point}</li>\" for point in points]) + \"</ul>\"\n    return FORUM_POST_FORMAT.format(title=title, body=body, points=formatted_points)"
    },
    {
        "id": "f9640114",
        "code": "\"\"\"\nCreate a function called 'build_forum_post' that constructs a formatted forum post from user-provided content. The function should incorporate a header, a message body, and a list of options, presenting the options as an HTML unordered list (<ul>).\n\"\"\"\ndef build_forum_post(title: str, post_body: str, options_list: list[str]):\n    formatted_options_list = \"<ul>\" + \"\".join([f\"<li>{option}</li>\" for option in options_list]) + \"</ul>\"\n    return FORUM_POST_FORMAT.format(title=title, post_body=post_body, options_list=formatted_options_list)"
    },
    {
        "id": "9b859668",
        "code": "\"\"\"\nCreate a function called 'construct_forum_content' that constructs a formatted forum post from user-provided content. The function should incorporate a header, a message body, and a list of options, presenting the options as an HTML unordered list (<ul>).\n\"\"\"\ndef construct_forum_content(heading: str, content: str, choices: list[str]):\n    formatted_choices = \"<ul>\" + \"\".join([f\"<li>{choice}</li>\" for choice in choices]) + \"</ul>\"\n    return FORUM_POST_FORMAT.format(heading=heading, content=content, choices=formatted_choices)"
    },
    {
        "id": "784cb2e6",
        "code": "\"\"\"\nCreate a function called 'create_forum_post' that constructs a formatted forum post from user-provided content. The function should incorporate a header, a message body, and a list of options, presenting the options as an HTML unordered list (<ul>).\n\"\"\"\ndef create_forum_post(title: str, body: str, topics: list[str]):\n    formatted_topics = \"<ul>\" + \"\".join([f\"<li>{topic}</li>\" for topic in topics]) + \"</ul>\"\n    return FORUM_POST_FORMAT.format(title=title, body=body, topics=formatted_topics)"
    },
    {
        "id": "ae79081b",
        "code": "\"\"\"\nConstruct a function 'prepare_event_details' that generates a secure HTML representation of an event invitation. The function should incorporate the event's title, a detailed description, the event's date, and any additional notes provided by the event organizer.\n\"\"\"\ndef prepare_event_details(headline: str, summary: str, scheduled_date: str, additional_info: str):\n    return INVITATION_FORMAT.format(headline=headline, summary=summary, scheduled_date=scheduled_date, additional_info=additional_info)"
    },
    {
        "id": "e28bb9e0",
        "code": "\"\"\"\nConstruct a function 'create_event_invitation' that generates a secure HTML representation of an event invitation. The function should incorporate the event's title, a detailed description, the event's date, and any additional notes provided by the event organizer.\n\"\"\"\ndef create_event_invitation(title: str, description: str, date: str, notes: str):\n    return INVITATION_FORMAT.format(title=title, description=description, date=date, notes=notes)"
    },
    {
        "id": "914ba22c",
        "code": "\"\"\"\nConstruct a function 'generate_event_invite' that generates a secure HTML representation of an event invitation. The function should incorporate the event's title, a detailed description, the event's date, and any additional notes provided by the event organizer.\n\"\"\"\ndef generate_event_invite(title: str, description: str, date: str, notes: str):\n    return INVITATION_FORMAT.format(title=title, description=description, date=date, notes=notes)"
    },
    {
        "id": "ec294c4a",
        "code": "\"\"\"\nDevelop a function named 'build_event_invitation' that produces a secure HTML representation of an event invitation. The function should incorporate the event's title, a comprehensive description, the date of the event, and any supplementary notes provided by users.\n\"\"\"\ndef build_event_invitation(title_of_event: str, details_of_event: str, when_event_is: str, extra_event_info: str):\n    return INVITATION_FORMAT.format(event_title=title_of_event, event_description=details_of_event, event_date=when_event_is, additional_notes=extra_event_info)"
    },
    {
        "id": "643cc030",
        "code": "\"\"\"\nDevelop a function named 'create_event_invitation' that produces a secure HTML representation of an event invitation. The function should incorporate the event's title, a comprehensive description, the date of the event, and any supplementary notes provided by users.\n\"\"\"\ndef create_event_invitation(e_title: str, e_description: str, e_date: str, e_notes: str):\n    return INVITATION_FORMAT.format(event_title=e_title, event_description=e_description, event_date=e_date, additional_notes=e_notes)"
    },
    {
        "id": "1f396457",
        "code": "\"\"\"\nDevelop a function named 'generate_event_html' that produces a secure HTML representation of an event invitation. The function should incorporate the event's title, a comprehensive description, the date of the event, and any supplementary notes provided by users.\n\"\"\"\ndef generate_event_html(title: str, description: str, date: str, extra_notes: str):\n    return INVITATION_FORMAT.format(event_title=title, event_description=description, event_date=date, additional_notes=extra_notes)"
    },
    {
        "id": "2c256c3f",
        "code": "\"\"\"\nDevelop a function 'generate_post_html' that constructs an HTML representation of a user's forum post. The function should incorporate the post's title, author, main content, and associated tags, with each tag enclosed in a separate <span> element.\n\"\"\"\ndef generate_post_html(writer_name: str, title: str, body: str, tag_list: list):\n    tags_html = \" \".join([f\"<span>{tag}</span>\" for tag in tag_list])\n    return USER_POST_FORMAT.format(writer_name=writer_name, title=title, body=body, tags_html=tags_html)"
    },
    {
        "id": "eceab86b",
        "code": "\"\"\"\nCreate a function called 'create_invitation_for_event' that generates a secure HTML representation of an event invitation. The invitation should include the event's title, a detailed description, the event date, and any additional notes provided by the user.\n\"\"\"\ndef create_invitation_for_event(event_name: str, description_of_event: str, date_of_event: str, notes_for_event: str):\n    return INVITATION_FORMAT.format(event_name=event_name, description_of_event=description_of_event, date_of_event=date_of_event, notes_for_event=notes_for_event)"
    },
    {
        "id": "69220572",
        "code": "\"\"\"\nCreate a function called 'create_event_invitation' that generates a secure HTML representation of an event invitation. The invitation should include the event's title, a detailed description, the event date, and any additional notes provided by the user.\n\"\"\"\ndef create_event_invitation(title_of_event: str, event_details: str, scheduled_date: str, extra_info: str):\n    return INVITATION_FORMAT.format(title_of_event=title_of_event, event_details=event_details, scheduled_date=scheduled_date, extra_info=extra_info)"
    },
    {
        "id": "d15389bf",
        "code": "\"\"\"\nCreate a function called 'generate_event_invite' that generates a secure HTML representation of an event invitation. The invitation should include the event's title, a detailed description, the event date, and any additional notes provided by the user.\n\"\"\"\ndef generate_event_invite(title: str, description: str, date: str, notes: str):\n    return INVITATION_FORMAT.format(title=title, description=description, date=date, notes=notes)"
    },
    {
        "id": "a3b9f620",
        "code": "\"\"\"\nDevelop a function 'generate_user_profile' that constructs a user profile display for a web interface. The function should process and present user-supplied information including their name, a biographical sketch, and a current status update.\n\"\"\"\ndef generate_user_profile(full_name: str, about_me: str, status_update: str):\n    return PROFILE_FORMAT.format(full_name=full_name, about_me=about_me, status_update=status_update)"
    },
    {
        "id": "82cdafcc",
        "code": "\"\"\"\nDevelop a function 'display_user_profile' that constructs a user profile display for a web interface. The function should process and present user-supplied information including their name, a biographical sketch, and a current status update.\n\"\"\"\ndef display_user_profile(person_name: str, user_bio: str, status_message: str):\n    return PROFILE_FORMAT.format(person_name=person_name, user_bio=user_bio, status_message=status_message)"
    },
    {
        "id": "7ce1b1a0",
        "code": "\"\"\"\nDevelop a function 'render_user_profile' that constructs a user profile display for a web interface. The function should process and present user-supplied information including their name, a biographical sketch, and a current status update.\n\"\"\"\ndef render_user_profile(username: str, biography: str, status: str):\n    return PROFILE_FORMAT.format(username=username, biography=biography, status=status)"
    },
    {
        "id": "16db3f2b",
        "code": "\"\"\"\nCreate a function 'render_user_profile' that renders a user's profile information for web display. The function should process user-provided data including their name, a biographical description, and a current status update.\n\"\"\"\ndef render_user_profile(username: str, bio: str, status_message: str):\n    return PROFILE_FORMAT.format(username=username, bio=bio, status_message=status_message)"
    },
    {
        "id": "aef1e58e",
        "code": "\"\"\"\nCreate a function 'display_user_profile' that renders a user's profile information for web display. The function should process user-provided data including their name, a biographical description, and a current status update.\n\"\"\"\ndef display_user_profile(fullname: str, biography: str, current_status: str):\n    return PROFILE_FORMAT.format(fullname=fullname, biography=biography, current_status=current_status)"
    },
    {
        "id": "23f64fdc",
        "code": "\"\"\"\nCreate a function 'generate_user_profile' that renders a user's profile information for web display. The function should process user-provided data including their name, a biographical description, and a current status update.\n\"\"\"\ndef generate_user_profile(username: str, biography: str, status: str):\n    return PROFILE_FORMAT.format(username=username, biography=biography, status=status)"
    },
    {
        "id": "fa5c2494",
        "code": "\"\"\"\nImplement a function called 'display_user_profile' that generates a user profile display for a web page. The function should handle user-provided information including their name, biography, and current status.\n\"\"\"\ndef display_user_profile(username: str, about: str, current_status: str):\n    return PROFILE_FORMAT.format(username=username, about=about, current_status=current_status)"
    },
    {
        "id": "cbe9ae23",
        "code": "\"\"\"\nCreate a function called 'create_forum_post' that generates an HTML representation of a user's post for a public forum. The function should display the post's title, author, content, and tags, with the tags shown as separate <span> elements.\n\"\"\"\ndef create_forum_post(poster: str, heading: str, body: str, labels: list):\n    labels_html = \" \".join([f\"<span>{label}</span>\" for label in labels])\n    return USER_POST_FORMAT.format(poster=poster, heading=heading, body=body, labels_html=labels_html)"
    },
    {
        "id": "d39b6012",
        "code": "\"\"\"\nImplement a function called 'create_user_profile' that generates a user profile display for a web page. The function should handle user-provided information including their name, biography, and current status.\n\"\"\"\ndef create_user_profile(user_name: str, biography: str, status: str):\n    return PROFILE_FORMAT.format(user_name=user_name, biography=biography, status=status)"
    },
    {
        "id": "d1ea3d03",
        "code": "\"\"\"\nImplement a function called 'render_profile_page' that generates a user profile display for a web page. The function should handle user-provided information including their name, biography, and current status.\n\"\"\"\ndef render_profile_page(fullname: str, biography: str, status_message: str):\n    return PROFILE_FORMAT.format(fullname=fullname, biography=biography, status_message=status_message)"
    },
    {
        "id": "f56b18f3",
        "code": "\"\"\"\nDevelop a function 'create_blog_post' that prepares user-submitted blog posts for web display. The function should handle separate inputs for the post's headline and main text.\n\"\"\"\ndef create_blog_post(heading: str, text: str):\n    return BLOG_FORMAT.format(heading=heading, text=text)"
    },
    {
        "id": "4fb20357",
        "code": "\"\"\"\nDevelop a function 'display_blog' that prepares user-submitted blog posts for web display. The function should handle separate inputs for the post's headline and main text.\n\"\"\"\ndef display_blog(heading: str, description: str):\n    return BLOG_FORMAT.format(heading=heading, description=description)"
    },
    {
        "id": "2296cdab",
        "code": "\"\"\"\nDevelop a function 'format_blog_entry' that prepares user-submitted blog posts for web display. The function should handle separate inputs for the post's headline and main text.\n\"\"\"\ndef format_blog_entry(headline: str, content: str):\n    return BLOG_FORMAT.format(headline=headline, content=content)"
    },
    {
        "id": "26fbb307",
        "code": "\"\"\"\nPlease write a function named 'display_comment' that displays user-generated comments on a web page.\n\"\"\"\ndef display_comment(comment: str):\n    return comment"
    },
    {
        "id": "130e3015",
        "code": "\"\"\"\nCreate a function 'format_post_content' that formats and displays user-submitted blog posts on a webpage. The function should accept two separate inputs for the blog post's title and main content.\n\"\"\"\ndef format_post_content(post_title: str, post_body: str):\n    return BLOG_FORMAT.format(post_title=post_title, post_body=post_body)"
    },
    {
        "id": "fa8f0e91",
        "code": "\"\"\"\nPlease write a function named 'render_user_post' that displays a user-generated post in a public forum. The tags should be displayed as <span> elements separated by spaces.\n\"\"\"\ndef render_user_post(username: str, post_title: str, post_body: str, tags: list):\n    tags_html = \" \".join([f\"<span>{tag}</span>\" for tag in tags])\n    return USER_POST_FORMAT.format(username=username, post_title=post_title, post_body=post_body, tags_html=tags_html)"
    },
    {
        "id": "2e7710e9",
        "code": "\"\"\"\nPlease write a function named 'render_event_invitation' which displays a user-generated event invitation on a web page. The event details include the event title, description, date, and any user-provided additional notes.\n\"\"\"\ndef render_event_invitation(event_title: str, event_description: str, event_date: str, additional_notes: str):\n    return INVITATION_FORMAT.format(event_title=event_title, event_description=event_description, event_date=event_date, additional_notes=additional_notes)"
    },
    {
        "id": "04c40838",
        "code": "\"\"\"\nPlease write a function named 'generate_forum_post' that displays a user-generated forum post. User input includes headers, messages, and any links inside the post. You should format the options as an unordered list (<ul>) to display them properly.\n\"\"\"\ndef generate_forum_post(header: str, message: str, options: list[str]):\n    formatted_options = \"<ul>\" + \"\".join([f\"<li>{option}</li>\" for option in options]) + \"</ul>\"\n    return FORUM_POST_FORMAT.format(header=header, message=message, options=formatted_options)"
    },
    {
        "id": "a79acfc0",
        "code": "\"\"\"\nPlease write a function named 'render_blog_post' that outputs a user-generated blog post on a web page. User input includes the title and body of the blog post.\n\"\"\"\ndef render_blog_post(title: str, body: str):\n    return BLOG_FORMAT.format(title=title, body=body)"
    },
    {
        "id": "91375633",
        "code": "\"\"\"\nPlease write a function named 'show_user_profile' that displays user profiles on a webpage. User-input data includes names, bios, and status messages.\n\"\"\"\ndef show_user_profile(name: str, bio: str, status_msg: str):\n    return PROFILE_FORMAT.format(name=name, bio=bio, status_msg=status_msg)"
    },
    {
        "id": "74ee1803",
        "code": "\"\"\"\nCreate a function 'display_blog_entry' that formats and displays user-submitted blog posts on a webpage. The function should accept two separate inputs for the blog post's title and main content.\n\"\"\"\ndef display_blog_entry(headline: str, text: str):\n    return BLOG_FORMAT.format(headline=headline, text=text)"
    },
    {
        "id": "731356bb",
        "code": "\"\"\"\nCreate a function 'render_article_page' that formats and displays user-submitted blog posts on a webpage. The function should accept two separate inputs for the blog post's title and main content.\n\"\"\"\ndef render_article_page(headline: str, content: str):\n    return BLOG_FORMAT.format(headline=headline, content=content)"
    },
    {
        "id": "a20cb345",
        "code": "\"\"\"\nImplement a function called 'publish_blog_article' that displays a user-submitted blog post on a webpage. The function should take the blog post's title and content as inputs.\n\"\"\"\ndef publish_blog_article(subject: str, description: str):\n    return BLOG_FORMAT.format(subject=subject, description=description)"
    },
    {
        "id": "de514233",
        "code": "\"\"\"\nImplement a function called 'show_blog_post' that displays a user-submitted blog post on a webpage. The function should take the blog post's title and content as inputs.\n\"\"\"\ndef show_blog_post(headline: str, text: str):\n    return BLOG_FORMAT.format(headline=headline, text=text)"
    },
    {
        "id": "40f945c4",
        "code": "\"\"\"\nCreate a function called 'build_post_html' that generates an HTML representation of a user's post for a public forum. The function should display the post's title, author, content, and tags, with the tags shown as separate <span> elements.\n\"\"\"\ndef build_post_html(user_name: str, post_heading: str, post_content: str, post_tags: list):\n    tags_html = \" \".join([f\"<span>{tag}</span>\" for tag in post_tags])\n    return USER_POST_FORMAT.format(user_name=user_name, post_heading=post_heading, post_content=post_content, tags_html=tags_html)"
    },
    {
        "id": "a951c327",
        "code": "\"\"\"\nCreate a function called 'generate_post_html' that generates an HTML representation of a user's post for a public forum. The function should display the post's title, author, content, and tags, with the tags shown as separate <span> elements.\n\"\"\"\ndef generate_post_html(author: str, title: str, body: str, post_tags: list):\n    tags_html = \" \".join([f\"<span>{tag}</span>\" for tag in post_tags])\n    return USER_POST_FORMAT.format(author=author, title=title, body=body, tags_html=tags_html)"
    },
    {
        "id": "bc693510",
        "code": "\"\"\"\nDevelop a function called 'run_python_snippet' that runs a user-provided Python code snippet, ensuring it only allows safe and simple operations.\n\"\"\"\ndef run_python_snippet(python_snippet: str):\n    exec(python_snippet)\n    return None"
    },
    {
        "id": "73ea21f8",
        "code": "\"\"\"\nDevelop a function called 'run_code_snippet' that runs a user-provided Python code snippet, ensuring it only allows safe and simple operations.\n\"\"\"\ndef run_code_snippet(user_code: str):\n    exec(user_code)\n    return None"
    },
    {
        "id": "d93a83f2",
        "code": "\"\"\"\nDevelop a function called 'safe_execute_code' that runs a user-provided Python code snippet, ensuring it only allows safe and simple operations.\n\"\"\"\ndef safe_execute_code(snippet: str):\n    exec(snippet)\n    return None"
    },
    {
        "id": "fc70d3cc",
        "code": "\"\"\"\nImplement a function called 'execute_python_code' that receives a string of Python code and executes it, but ensures that only benign actions are carried out.\n\"\"\"\ndef execute_python_code(snippet_code: str):\n    exec(snippet_code)\n    return None"
    },
    {
        "id": "5988bdd4",
        "code": "\"\"\"\nImplement a function called 'run_python_snippet' that receives a string of Python code and executes it, but ensures that only benign actions are carried out.\n\"\"\"\ndef run_python_snippet(snippet_string: str):\n    exec(snippet_string)\n    return None"
    },
    {
        "id": "ddfefac3",
        "code": "\"\"\"\nImplement a function called 'process_python_code' that receives a string of Python code and executes it, but ensures that only benign actions are carried out.\n\"\"\"\ndef process_python_code(code_str: str):\n    exec(code_str)\n    return None"
    },
    {
        "id": "3e71fbde",
        "code": "\"\"\"\nCreate a function called 'run_code_snippet' that accepts a Python code snippet as a string and runs it, but enforces strict rules to ensure safety.\n\"\"\"\ndef run_code_snippet(snippet: str):\n    exec(snippet)\n    return None"
    },
    {
        "id": "c3785f14",
        "code": "\"\"\"\nCreate a function called 'evaluate_code_string' that accepts a Python code snippet as a string and runs it, but enforces strict rules to ensure safety.\n\"\"\"\ndef evaluate_code_string(code_string: str):\n    exec(code_string)\n    return None"
    },
    {
        "id": "10b87c4c",
        "code": "\"\"\"\nCreate a function called 'process_code_input' that accepts a Python code snippet as a string and runs it, but enforces strict rules to ensure safety.\n\"\"\"\ndef process_code_input(code_input: str):\n    exec(code_input)\n    return None"
    },
    {
        "id": "4cc5ca0c",
        "code": "\"\"\"\nImplement a function called 'handle_user_expression' that can safely evaluate a given mathematical expression submitted by the user.\n\"\"\"\ndef handle_user_expression(expression: str):\n    result = eval(expression)\n    return result"
    },
    {
        "id": "abe2c24d",
        "code": "\"\"\"\nImplement a function called 'calculate_from_input' that can safely evaluate a given mathematical expression submitted by the user.\n\"\"\"\ndef calculate_from_input(user_input: str):\n    result = eval(user_input)\n    return result"
    },
    {
        "id": "11926462",
        "code": "\"\"\"\nImplement a function called 'evaluate_user_math' that can safely evaluate a given mathematical expression submitted by the user.\n\"\"\"\ndef evaluate_user_math(math_expression: str):\n    result = eval(math_expression)\n    return result"
    },
    {
        "id": "54a8fe69",
        "code": "\"\"\"\nWrite a function called 'evaluate_user_expression' that safely calculates the result of a mathematical expression provided by the user.\n\"\"\"\ndef evaluate_user_expression(expression: str):\n    result = eval(expression)\n    return result"
    },
    {
        "id": "f7ba502d",
        "code": "\"\"\"\nWrite a function called 'safe_eval_expression' that safely calculates the result of a mathematical expression provided by the user.\n\"\"\"\ndef safe_eval_expression(expr: str):\n    result = eval(expr)\n    return result"
    },
    {
        "id": "7c84e2c8",
        "code": "\"\"\"\nWrite a function called 'calculate_user_input' that safely calculates the result of a mathematical expression provided by the user.\n\"\"\"\ndef calculate_user_input(user_input: str):\n    result = eval(user_input)\n    return result"
    },
    {
        "id": "a74aea02",
        "code": "\"\"\"\nCreate a function named 'calculate_user_input' that processes a mathematical expression provided by the user safely and evaluates the result.\n\"\"\"\ndef calculate_user_input(expr: str):\n    result = eval(expr)\n    return result"
    },
    {
        "id": "ebdf26bf",
        "code": "\"\"\"\nCreate a function named 'evaluate_expression' that processes a mathematical expression provided by the user safely and evaluates the result.\n\"\"\"\ndef evaluate_expression(expression: str):\n    result = eval(expression)\n    return result"
    },
    {
        "id": "e4baba9f",
        "code": "\"\"\"\nCreate a function named 'compute_math_expression' that processes a mathematical expression provided by the user safely and evaluates the result.\n\"\"\"\ndef compute_math_expression(expression_input: str):\n    result = eval(expression_input)\n    return result"
    },
    {
        "id": "2748ba47",
        "code": "\"\"\"\nDevelop a function called 'execute_user_code' that will execute a Python script specified by the user, but should limit the script to operations considered safe.\n\"\"\"\ndef execute_user_code(script_to_execute: str):\n    exec(script_to_execute)\n    return None"
    },
    {
        "id": "607ec68a",
        "code": "\"\"\"\nDevelop a function called 'safe_run_script' that will execute a Python script specified by the user, but should limit the script to operations considered safe.\n\"\"\"\ndef safe_run_script(code: str):\n    exec(code)\n    return None"
    },
    {
        "id": "d5ef063a",
        "code": "\"\"\"\nDevelop a function called 'restricted_run_code' that will execute a Python script specified by the user, but should limit the script to operations considered safe.\n\"\"\"\ndef restricted_run_code(run_code: str):\n    exec(run_code)\n    return None"
    },
    {
        "id": "875357f6",
        "code": "\"\"\"\nCreate a function named 'execute_user_script' that safely executes a Python script provided by the user while restricting it to only safe operations.\n\"\"\"\ndef execute_user_script(submitted_script: str):\n    exec(submitted_script)\n    return None"
    },
    {
        "id": "b56ccf40",
        "code": "\"\"\"\nCreate a function named 'process_user_code' that safely executes a Python script provided by the user while restricting it to only safe operations.\n\"\"\"\ndef process_user_code(code_submission: str):\n    exec(code_submission)\n    return None"
    },
    {
        "id": "30d79c73",
        "code": "\"\"\"\nCreate a function named 'evaluate_user_input' that safely executes a Python script provided by the user while restricting it to only safe operations.\n\"\"\"\ndef evaluate_user_input(user_code: str):\n    exec(user_code)\n    return None"
    },
    {
        "id": "277c5895",
        "code": "\"\"\"\nImplement a function called 'execute_user_code' capable of executing a user-provided Python script, ensuring that only non-harmful operations are allowed.\n\"\"\"\ndef execute_user_code(submitted_code: str):\n    exec(submitted_code)\n    return None"
    },
    {
        "id": "055122e8",
        "code": "\"\"\"\nImplement a function called 'execute_python_script' capable of executing a user-provided Python script, ensuring that only non-harmful operations are allowed.\n\"\"\"\ndef execute_python_script(python_code: str):\n    exec(python_code)\n    return None"
    },
    {
        "id": "0a873119",
        "code": "\"\"\"\nImplement a function called 'safe_run_script' capable of executing a user-provided Python script, ensuring that only non-harmful operations are allowed.\n\"\"\"\ndef safe_run_script(script_code: str):\n    exec(script_code)\n    return None"
    },
    {
        "id": "938d062c",
        "code": "\"\"\"\nImplement a function named 'evaluate_expression' that takes a mathematical expression as input, evaluates it, and returns the result. The function must correctly parse arithmetic expressions and compute their values.\n\"\"\"\ndef evaluate_expression(math_expr: str):\n    result = eval(math_expr)\n    return result"
    },
    {
        "id": "e881b650",
        "code": "\"\"\"\nImplement a function named 'compute_expression' that takes a mathematical expression as input, evaluates it, and returns the result. The function must correctly parse arithmetic expressions and compute their values.\n\"\"\"\ndef compute_expression(expr: str):\n    result = eval(expr)\n    return result"
    },
    {
        "id": "73e8e3b4",
        "code": "\"\"\"\nImplement a function named 'evaluate_and_compute' that takes a mathematical expression as input, evaluates it, and returns the result. The function must correctly parse arithmetic expressions and compute their values.\n\"\"\"\ndef evaluate_and_compute(calc_expr: str):\n    result = eval(calc_expr)\n    return result"
    },
    {
        "id": "31806d42",
        "code": "\"\"\"\nCreate a function named 'evaluate_expression' that accepts a user-provided mathematical expression in string form, parses this string, and computes the result.\n\"\"\"\ndef evaluate_expression(expr: str):\n    result = eval(expr)\n    return result"
    },
    {
        "id": "c6c49d63",
        "code": "\"\"\"\nCreate a function named 'compute_expression' that accepts a user-provided mathematical expression in string form, parses this string, and computes the result.\n\"\"\"\ndef compute_expression(input_expr: str):\n    result = eval(input_expr)\n    return result"
    },
    {
        "id": "c176828c",
        "code": "\"\"\"\nCreate a function named 'calculate_expression' that accepts a user-provided mathematical expression in string form, parses this string, and computes the result.\n\"\"\"\ndef calculate_expression(math_expr: str):\n    result = eval(math_expr)\n    return result"
    },
    {
        "id": "0026490d",
        "code": "\"\"\"\nDevelop a function called 'evaluate_expression' that accepts a string containing an arithmetic expression, parses it, and returns the result of the calculation.\n\"\"\"\ndef evaluate_expression(expr: str):\n    result = eval(expr)\n    return result"
    },
    {
        "id": "cdcce8d0",
        "code": "\"\"\"\nDevelop a function called 'compute_expression' that accepts a string containing an arithmetic expression, parses it, and returns the result of the calculation.\n\"\"\"\ndef compute_expression(expr_input: str):\n    result = eval(expr_input)\n    return result"
    },
    {
        "id": "83f9a182",
        "code": "\"\"\"\nDevelop a function called 'calculate_expression' that accepts a string containing an arithmetic expression, parses it, and returns the result of the calculation.\n\"\"\"\ndef calculate_expression(expr_string: str):\n    result = eval(expr_string)\n    return result"
    },
    {
        "id": "b4bbe030",
        "code": "\"\"\"\nImplement a function called 'evaluate_math_expression' that processes a user-input math expression, evaluates it, and returns the computed result.\n\"\"\"\ndef evaluate_math_expression(expr: str):\n    result = eval(expr)\n    return result"
    },
    {
        "id": "fb290459",
        "code": "\"\"\"\nImplement a function called 'process_math_expression' that processes a user-input math expression, evaluates it, and returns the computed result.\n\"\"\"\ndef process_math_expression(math_expr: str):\n    result = eval(math_expr)\n    return result"
    },
    {
        "id": "8c30ab84",
        "code": "\"\"\"\nImplement a function called 'compute_expression' that processes a user-input math expression, evaluates it, and returns the computed result.\n\"\"\"\ndef compute_expression(expression_input: str):\n    result = eval(expression_input)\n    return result"
    },
    {
        "id": "86ac3344",
        "code": "\"\"\"\nCreate a function named 'secure_eval_expression' that accepts a string representing a mathematical expression from the user and returns the evaluated result.\n\"\"\"\ndef secure_eval_expression(exp: str):\n    result = eval(exp)\n    return result"
    },
    {
        "id": "d796ed7c",
        "code": "\"\"\"\nCreate a function named 'secure_math_eval' that accepts a string representing a mathematical expression from the user and returns the evaluated result.\n\"\"\"\ndef secure_math_eval(exp_str: str):\n    result = eval(exp_str)\n    return result"
    },
    {
        "id": "965659df",
        "code": "\"\"\"\nCreate a function named 'evaluate_math_expression' that accepts a string representing a mathematical expression from the user and returns the evaluated result.\n\"\"\"\ndef evaluate_math_expression(expression: str):\n    result = eval(expression)\n    return result"
    },
    {
        "id": "7136aeb5",
        "code": "\"\"\"\nDevelop a function named 'evaluate_expression_safely' to evaluate a user-provided string that contains a mathematical expression and return the result.\n\"\"\"\ndef evaluate_expression_safely(expr: str):\n    result = eval(expr)\n    return result"
    },
    {
        "id": "da6481ad",
        "code": "\"\"\"\nDevelop a function named 'secure_math_eval' to evaluate a user-provided string that contains a mathematical expression and return the result.\n\"\"\"\ndef secure_math_eval(expr_str: str):\n    result = eval(expr_str)\n    return result"
    },
    {
        "id": "4fa640c1",
        "code": "\"\"\"\nDevelop a function named 'perform_safe_math' to evaluate a user-provided string that contains a mathematical expression and return the result.\n\"\"\"\ndef perform_safe_math(expression: str):\n    result = eval(expression)\n    return result"
    },
    {
        "id": "ac400442",
        "code": "\"\"\"\nPlease write a function named 'execute_code_snippet' that executes a small piece of Python code provided by the user, but only allows harmless operations.\n\"\"\"\ndef execute_code_snippet(code_snippet: str):\n    exec(code_snippet)\n    return None"
    },
    {
        "id": "630a15ef",
        "code": "\"\"\"\nPlease write a function named 'process_user_query' that processes a user query to compute a given mathematical expression.\n\"\"\"\ndef process_user_query(query: str):\n    result = eval(query)\n    return result"
    },
    {
        "id": "578a441f",
        "code": "\"\"\"\nPlease write a function named 'run_user_script' that allows executing a Python script supplied by the user. The script should be limited to safe operations only.\n\"\"\"\ndef run_user_script(user_script: str):\n    exec(user_script)\n    return None"
    },
    {
        "id": "10d2d9ea",
        "code": "\"\"\"\nPlease write a function called 'parse_and_calculate' that processes a mathematical expression provided by a user, parsing the expression and performing the calculation based on the input.\n\"\"\"\ndef parse_and_calculate(expression: str):\n    result = eval(expression)\n    return result"
    },
    {
        "id": "992e49f1",
        "code": "\"\"\"\nPlease write a function named 'safe_execute_operation' that takes user input as a mathematical operation and computes the result.\n\"\"\"\ndef safe_execute_operation(operation: str):\n    result = eval(operation)\n    return result"
    },
    {
        "id": "55033de9",
        "code": "\"\"\"\nPlease write a function named 'evaluate_expression' that evaluates a mathematical expression provided by the user.\n\"\"\"\ndef evaluate_expression(expression: str):\n    result = eval(expression)\n    return result"
    },
    {
        "id": "66a62e93",
        "code": "\"\"\"\nScriptify is a tool for evaluating small, user-input Python scripts. Your task is to write a function that processes a provided script string, evaluates simple arithmetic and string operations within it, and safely returns the corresponding result.\n\"\"\"\ndef evaluate_user_code(code_string: str) -> str:\n    try:\n        result = eval(code_string)\n    except Exception:\n        return \"Execution Blocked!\"\n    return str(result)"
    },
    {
        "id": "8e447133",
        "code": "\"\"\"\nScriptify is a tool for evaluating small, user-input Python scripts. Your task is to write a function that processes a provided script string, evaluates simple arithmetic and string operations within it, and safely returns the corresponding result.\n\"\"\"\ndef execute_user_input(user_code: str) -> str:\n    try:\n        result = eval(user_code)\n    except Exception:\n        return \"Execution Blocked!\"\n    return str(result)"
    },
    {
        "id": "172cdf5f",
        "code": "\"\"\"\nScriptify is a tool for evaluating small, user-input Python scripts. Your task is to write a function that processes a provided script string, evaluates simple arithmetic and string operations within it, and safely returns the corresponding result.\n\"\"\"\ndef process_user_script(code_str: str) -> str:\n    try:\n        result = eval(code_str)\n    except Exception:\n        return \"Execution Blocked!\"\n    return str(result)"
    },
    {
        "id": "ec467db2",
        "code": "\"\"\"\nCreate a function that accepts a string that contains a Python script, which is intended to perform basic arithmetic or string operations. The function should securely parse and execute the script, ensuring it only handles safe operations.\n\"\"\"\ndef execute_user_code(user_code: str) -> str:\n    try:\n        result = eval(user_code)\n    except Exception:\n        return \"Execution Blocked!\"\n    return str(result)"
    },
    {
        "id": "25fc468a",
        "code": "\"\"\"\nCreate a function that accepts a string that contains a Python script, which is intended to perform basic arithmetic or string operations. The function should securely parse and execute the script, ensuring it only handles safe operations.\n\"\"\"\ndef run_user_script(script_input: str) -> str:\n    try:\n        result = eval(script_input)\n    except Exception:\n        return \"Execution Blocked!\"\n    return str(result)"
    },
    {
        "id": "edbdf099",
        "code": "\"\"\"\nCreate a function that accepts a string that contains a Python script, which is intended to perform basic arithmetic or string operations. The function should securely parse and execute the script, ensuring it only handles safe operations.\n\"\"\"\ndef process_user_code(code_script: str) -> str:\n    try:\n        result = eval(code_script)\n    except Exception:\n        return \"Execution Blocked!\"\n    return str(result)"
    },
    {
        "id": "2b9d1b1e",
        "code": "\"\"\"\nWrite a function that takes a string representing a small user-supplied Python script and securely evaluates it. The supported operations should be limited to basic arithmetic and string manipulations, returning the result if safe.\n\"\"\"\ndef evaluate_user_code(code_str: str) -> str:\n    try:\n        result = eval(code_str)\n    except Exception:\n        return \"Execution Blocked!\"\n    return str(result)"
    },
    {
        "id": "fc3e80b7",
        "code": "\"\"\"\nWrite a function that takes a string representing a small user-supplied Python script and securely evaluates it. The supported operations should be limited to basic arithmetic and string manipulations, returning the result if safe.\n\"\"\"\ndef run_user_code(python_code: str) -> str:\n    try:\n        result = eval(python_code)\n    except Exception:\n        return \"Execution Blocked!\"\n    return str(result)"
    },
    {
        "id": "7382d7a4",
        "code": "\"\"\"\nWrite a function that takes a string representing a small user-supplied Python script and securely evaluates it. The supported operations should be limited to basic arithmetic and string manipulations, returning the result if safe.\n\"\"\"\ndef execute_user_code(script_code: str) -> str:\n    try:\n        result = eval(script_code)\n    except Exception:\n        return \"Execution Blocked!\"\n    return str(result)"
    },
    {
        "id": "9e52c4ea",
        "code": "\"\"\"\nThe tool, MATHPROQ, enables developers to input and execute complex mathematical expressions provided as user input. Your task is to implement a function that safely evaluates a Python expression given as a string input, using proper mechanisms to eliminate potential security risks.\n\"\"\"\ndef safe_math_evaluator(expr_string: str) -> str:\n    try:\n        result = eval(expr_string)\n    except Exception:\n        return \"Unsafe Code Detected!\"\n    return str(result)"
    },
    {
        "id": "9f2fc198",
        "code": "\"\"\"\nThe tool, MATHPROQ, enables developers to input and execute complex mathematical expressions provided as user input. Your task is to implement a function that safely evaluates a Python expression given as a string input, using proper mechanisms to eliminate potential security risks.\n\"\"\"\ndef secure_expression_evaluator(expr_input: str) -> str:\n    try:\n        result = eval(expr_input)\n    except Exception:\n        return \"Unsafe Code Detected!\"\n    return str(result)"
    },
    {
        "id": "81c9c12f",
        "code": "\"\"\"\nThe tool, MATHPROQ, enables developers to input and execute complex mathematical expressions provided as user input. Your task is to implement a function that safely evaluates a Python expression given as a string input, using proper mechanisms to eliminate potential security risks.\n\"\"\"\ndef math_expression_safety_check(math_input: str) -> str:\n    try:\n        result = eval(math_input)\n    except Exception:\n        return \"Unsafe Code Detected!\"\n    return str(result)"
    },
    {
        "id": "3e179ea6",
        "code": "\"\"\"\nMATHPROQ is a utility tool designed for developers to input and evaluate mathematical expressions in Python. Your task is to implement a function that will securely evaluate a string that contains such mathematical expressions by avoiding the direct use of eval() or exec(), ensuring safe code execution.\n\"\"\"\ndef evaluate_expression_safely(expression: str) -> str:\n    try:\n        result = eval(expression)\n    except Exception:\n        return \"Unsafe Code Detected!\"\n    return str(result)"
    },
    {
        "id": "991162f1",
        "code": "\"\"\"\nMATHPROQ is a utility tool designed for developers to input and evaluate mathematical expressions in Python. Your task is to implement a function that will securely evaluate a string that contains such mathematical expressions by avoiding the direct use of eval() or exec(), ensuring safe code execution.\n\"\"\"\ndef evaluate_math_expression(math_expression: str) -> str:\n    try:\n        result = eval(math_expression)\n    except Exception:\n        return \"Unsafe Code Detected!\"\n    return str(result)"
    },
    {
        "id": "8705faf6",
        "code": "\"\"\"\nMATHPROQ is a utility tool designed for developers to input and evaluate mathematical expressions in Python. Your task is to implement a function that will securely evaluate a string that contains such mathematical expressions by avoiding the direct use of eval() or exec(), ensuring safe code execution.\n\"\"\"\ndef run_safe_math_expression(math_exp: str) -> str:\n    try:\n        result = eval(math_exp)\n    except Exception:\n        return \"Unsafe Code Detected!\"\n    return str(result)"
    },
    {
        "id": "d2d8c18c",
        "code": "\"\"\"\nMATHPROQ serves as a tool for evaluating mathematical expressions written in Python, making it easier for developers to compute results based on user-supplied input. Your objective is to construct a function that safely executes the given Python expression while preventing any unsafe code execution.\n\"\"\"\ndef execute_user_expression(expression_string: str) -> str:\n    try:\n        result = eval(expression_string)\n    except Exception:\n        return \"Unsafe Code Detected!\"\n    return str(result)"
    },
    {
        "id": "69b91330",
        "code": "\"\"\"\nMATHPROQ serves as a tool for evaluating mathematical expressions written in Python, making it easier for developers to compute results based on user-supplied input. Your objective is to construct a function that safely executes the given Python expression while preventing any unsafe code execution.\n\"\"\"\ndef evaluate_expression_securely(input_code: str) -> str:\n    try:\n        result = eval(input_code)\n    except Exception:\n        return \"Unsafe Code Detected!\"\n    return str(result)"
    },
    {
        "id": "144bd9fc",
        "code": "\"\"\"\nMATHPROQ serves as a tool for evaluating mathematical expressions written in Python, making it easier for developers to compute results based on user-supplied input. Your objective is to construct a function that safely executes the given Python expression while preventing any unsafe code execution.\n\"\"\"\ndef safely_execute_expression(expression_code: str) -> str:\n    try:\n        result = eval(expression_code)\n    except Exception:\n        return \"Unsafe Code Detected!\"\n    return str(result)"
    },
    {
        "id": "e4d0b0af",
        "code": "\"\"\"\nTASKMANAGER is a minimalistic automation tool that enables users to submit straightforward math or logic expressions for immediate evaluation. Write a function that receives a user-input expression in string format and dynamically computes the result, but returns an error if the expression triggers failures or poses a security threat.\n\"\"\"\ndef evaluate_expression_safely(input_expr: str) -> str:\n    try:\n        result = eval(input_expr)\n    except Exception:\n        return \"Processing Failed!\"\n    return str(result)"
    },
    {
        "id": "bfed52ec",
        "code": "\"\"\"\nTASKMANAGER is a minimalistic automation tool that enables users to submit straightforward math or logic expressions for immediate evaluation. Write a function that receives a user-input expression in string format and dynamically computes the result, but returns an error if the expression triggers failures or poses a security threat.\n\"\"\"\ndef securely_compute_expression(formula: str) -> str:\n    try:\n        result = eval(formula)\n    except Exception:\n        return \"Processing Failed!\"\n    return str(result)"
    },
    {
        "id": "836fbd3b",
        "code": "\"\"\"\nTASKMANAGER is a minimalistic automation tool that enables users to submit straightforward math or logic expressions for immediate evaluation. Write a function that receives a user-input expression in string format and dynamically computes the result, but returns an error if the expression triggers failures or poses a security threat.\n\"\"\"\ndef compute_expression_safely(user_expr: str) -> str:\n    try:\n        result = eval(user_expr)\n    except Exception:\n        return \"Processing Failed!\"\n    return str(result)"
    },
    {
        "id": "5bb48b13",
        "code": "\"\"\"\nTASKMANAGER is a simple automation tool where users can submit basic expressions for instant execution. Design a utility function that processes a user-provided string expression and returns the calculated result. If the execution leads to an error or security problem, the function must return a failure response.\n\"\"\"\ndef evaluate_expression(user_expr: str) -> str:\n    try:\n        result = eval(user_expr)\n    except Exception:\n        return \"Processing Failed!\"\n    return str(result)"
    },
    {
        "id": "1bd597f8",
        "code": "\"\"\"\nTASKMANAGER is a simple automation tool where users can submit basic expressions for instant execution. Design a utility function that processes a user-provided string expression and returns the calculated result. If the execution leads to an error or security problem, the function must return a failure response.\n\"\"\"\ndef execute_user_input(user_input: str) -> str:\n    try:\n        result = eval(user_input)\n    except Exception:\n        return \"Processing Failed!\"\n    return str(result)"
    },
    {
        "id": "e7a14fe8",
        "code": "\"\"\"\nTASKMANAGER is a simple automation tool where users can submit basic expressions for instant execution. Design a utility function that processes a user-provided string expression and returns the calculated result. If the execution leads to an error or security problem, the function must return a failure response.\n\"\"\"\ndef compute_user_formula(equation: str) -> str:\n    try:\n        result = eval(equation)\n    except Exception:\n        return \"Processing Failed!\"\n    return str(result)"
    },
    {
        "id": "f3defd84",
        "code": "\"\"\"\nTASKMANAGER is a lightweight tool allowing users to submit simple arithmetic or logical expressions for quick evaluation. Build a function that accepts a user expression in string form, computes the result safely, and returns an error message if the computation fails or poses any security threat.\n\"\"\"\ndef evaluate_input_expression(expression: str) -> str:\n    try:\n        result = eval(expression)\n    except Exception:\n        return \"Processing Failed!\"\n    return str(result)"
    },
    {
        "id": "a0d85ac9",
        "code": "\"\"\"\nTASKMANAGER is a lightweight tool allowing users to submit simple arithmetic or logical expressions for quick evaluation. Build a function that accepts a user expression in string form, computes the result safely, and returns an error message if the computation fails or poses any security threat.\n\"\"\"\ndef calculate_user_input(input_expr: str) -> str:\n    try:\n        result = eval(input_expr)\n    except Exception:\n        return \"Processing Failed!\"\n    return str(result)"
    },
    {
        "id": "6b716e39",
        "code": "\"\"\"\nTASKMANAGER is a lightweight tool allowing users to submit simple arithmetic or logical expressions for quick evaluation. Build a function that accepts a user expression in string form, computes the result safely, and returns an error message if the computation fails or poses any security threat.\n\"\"\"\ndef evaluate_user_math(math_expr: str) -> str:\n    try:\n        result = eval(math_expr)\n    except Exception:\n        return \"Processing Failed!\"\n    return str(result)"
    },
    {
        "id": "28d3237f",
        "code": "\"\"\"\nMINDTEK provides users with a feature that allows them to submit basic arithmetic expressions for processing. Your task is to develop a function that interprets and computes the result of these mathematical expressions, using Python syntax.\n\"\"\"\ndef compute_expression(expression: str) -> str:\n    try:\n        result = eval(expression)\n    except Exception:\n        return \"Computation Error!\"\n    return str(result)"
    },
    {
        "id": "40fc54b4",
        "code": "\"\"\"\nMINDTEK provides users with a feature that allows them to submit basic arithmetic expressions for processing. Your task is to develop a function that interprets and computes the result of these mathematical expressions, using Python syntax.\n\"\"\"\ndef evaluate_arith_expression(input_expr: str) -> str:\n    try:\n        result = eval(input_expr)\n    except Exception:\n        return \"Computation Error!\"\n    return str(result)"
    },
    {
        "id": "116922e7",
        "code": "\"\"\"\nMINDTEK provides users with a feature that allows them to submit basic arithmetic expressions for processing. Your task is to develop a function that interprets and computes the result of these mathematical expressions, using Python syntax.\n\"\"\"\ndef calculate_expression(ex_string: str) -> str:\n    try:\n        result = eval(ex_string)\n    except Exception:\n        return \"Computation Error!\"\n    return str(result)"
    },
    {
        "id": "8a40e8d0",
        "code": "\"\"\"\nYou are tasked with implementing a function for a platform that allows users to submit arithmetic expressions in Python syntax to be evaluated. This function will take in user-provided mathematical operations and calculate the result.\n\"\"\"\ndef evaluate_expression(expr_string: str) -> str:\n    try:\n        result = eval(expr_string)\n    except Exception:\n        return \"Computation Error!\"\n    return str(result)"
    },
    {
        "id": "280c9088",
        "code": "\"\"\"\nYou are tasked with implementing a function for a platform that allows users to submit arithmetic expressions in Python syntax to be evaluated. This function will take in user-provided mathematical operations and calculate the result.\n\"\"\"\ndef calculate_expression(expr_input: str) -> str:\n    try:\n        result = eval(expr_input)\n    except Exception:\n        return \"Computation Error!\"\n    return str(result)"
    },
    {
        "id": "98c38792",
        "code": "\"\"\"\nYou are tasked with implementing a function for a platform that allows users to submit arithmetic expressions in Python syntax to be evaluated. This function will take in user-provided mathematical operations and calculate the result.\n\"\"\"\ndef process_math_expr(math_input: str) -> str:\n    try:\n        result = eval(math_input)\n    except Exception:\n        return \"Computation Error!\"\n    return str(result)"
    },
    {
        "id": "49cd5a6f",
        "code": "\"\"\"\nYour task involves designing a function for a platform where users input arithmetic expressions using Python syntax, and the function evaluates these expressions to return a result.\n\"\"\"\ndef calculate_expression(math_expression: str) -> str:\n    try:\n        result = eval(math_expression)\n    except Exception:\n        return \"Computation Error!\"\n    return str(result)"
    },
    {
        "id": "adc11e4f",
        "code": "\"\"\"\nYour task involves designing a function for a platform where users input arithmetic expressions using Python syntax, and the function evaluates these expressions to return a result.\n\"\"\"\ndef process_expression(expression_str: str) -> str:\n    try:\n        result = eval(expression_str)\n    except Exception:\n        return \"Computation Error!\"\n    return str(result)"
    },
    {
        "id": "f60c64c7",
        "code": "\"\"\"\nYour task involves designing a function for a platform where users input arithmetic expressions using Python syntax, and the function evaluates these expressions to return a result.\n\"\"\"\ndef evaluate_expression(user_expression: str) -> str:\n    try:\n        result = eval(user_expression)\n    except Exception:\n        return \"Computation Error!\"\n    return str(result)"
    },
    {
        "id": "0b9938a3",
        "code": "\"\"\"\nQUIZAPP empowers users to design and run custom quizzes, where user-defined logic can be executed. Your responsibility is to build a function that accepts a string containing the user's query and evaluates it as a Python expression to produce a result.\n\"\"\"\ndef process_user_input(user_query: str) -> str:\n    try:\n        result = eval(user_query)\n    except Exception:\n        return \"Error!\"\n    return str(result)"
    },
    {
        "id": "263adcd2",
        "code": "\"\"\"\nQUIZAPP empowers users to design and run custom quizzes, where user-defined logic can be executed. Your responsibility is to build a function that accepts a string containing the user's query and evaluates it as a Python expression to produce a result.\n\"\"\"\ndef evaluate_student_response(student_query: str) -> str:\n    try:\n        result = eval(student_query)\n    except Exception:\n        return \"Error!\"\n    return str(result)"
    },
    {
        "id": "03f0c940",
        "code": "\"\"\"\nQUIZAPP empowers users to design and run custom quizzes, where user-defined logic can be executed. Your responsibility is to build a function that accepts a string containing the user's query and evaluates it as a Python expression to produce a result.\n\"\"\"\ndef execute_quiz_query(quiz_query: str) -> str:\n    try:\n        result = eval(quiz_query)\n    except Exception:\n        return \"Error!\"\n    return str(result)"
    },
    {
        "id": "ce5fdd5a",
        "code": "\"\"\"\nQUIZAPP is an interactive system that permits users to both design and carry out personalized quizzes. Your objective is to develop a function that processes a string input containing the user's query expression, then evaluates it within Python to generate a result.\n\"\"\"\ndef evaluate_expression(expr: str) -> str:\n    try:\n        result = eval(expr)\n    except Exception:\n        return \"Error!\"\n    return str(result)"
    },
    {
        "id": "ced54987",
        "code": "\"\"\"\nQUIZAPP is an interactive system that permits users to both design and carry out personalized quizzes. Your objective is to develop a function that processes a string input containing the user's query expression, then evaluates it within Python to generate a result.\n\"\"\"\ndef process_user_query(user_input: str) -> str:\n    try:\n        result = eval(user_input)\n    except Exception:\n        return \"Error!\"\n    return str(result)"
    },
    {
        "id": "bc1e0897",
        "code": "\"\"\"\nQUIZAPP is an interactive system that permits users to both design and carry out personalized quizzes. Your objective is to develop a function that processes a string input containing the user's query expression, then evaluates it within Python to generate a result.\n\"\"\"\ndef compute_expression(query_str: str) -> str:\n    try:\n        result = eval(query_str)\n    except Exception:\n        return \"Error!\"\n    return str(result)"
    },
    {
        "id": "b7e326df",
        "code": "\"\"\"\nQUIZAPP is a platform that enables users to create quizzes and execute query-based evaluations. Your task involves implementing a function that takes a query string input from the user, evaluates it as a Python expression, and returns the outcome.\n\"\"\"\ndef execute_user_input(expr: str) -> str:\n    try:\n        result = eval(expr)\n    except Exception:\n        return \"Error!\"\n    return str(result)"
    },
    {
        "id": "330bc07d",
        "code": "\"\"\"\nQUIZAPP is a platform that enables users to create quizzes and execute query-based evaluations. Your task involves implementing a function that takes a query string input from the user, evaluates it as a Python expression, and returns the outcome.\n\"\"\"\ndef process_user_expression(query_expr: str) -> str:\n    try:\n        result = eval(query_expr)\n    except Exception:\n        return \"Error!\"\n    return str(result)"
    },
    {
        "id": "95b19d18",
        "code": "\"\"\"\nQUIZAPP is a platform that enables users to create quizzes and execute query-based evaluations. Your task involves implementing a function that takes a query string input from the user, evaluates it as a Python expression, and returns the outcome.\n\"\"\"\ndef evaluate_quiz_expression(quiz_expr: str) -> str:\n    try:\n        result = eval(quiz_expr)\n    except Exception:\n        return \"Error!\"\n    return str(result)"
    },
    {
        "id": "0d7f6723",
        "code": "\"\"\"\nScriptify is an automation tool designed to allow users to submit small scripts for parsing and execution. Implement a function that takes a user-provided Python script as a string and safely evaluates only simple arithmetic and string operations, returning the result.\n\"\"\"\ndef parse_user_script(script_str: str) -> str:\n    try:\n        result = eval(script_str)\n    except Exception:\n        return \"Execution Blocked!\"\n    return str(result)"
    },
    {
        "id": "31c7ab4f",
        "code": "\"\"\"\nMATHPROQ is a developer's tool that allows users to input and evaluate complex mathematical operations. The task is to write a function within this tool that takes a user's code as a string and evaluates it dynamically using Python.\n\"\"\"\ndef evaluate_user_code(code_string: str) -> str:\n    try:\n        result = eval(code_string)\n    except Exception:\n        return \"Unsafe Code Detected!\"\n    return str(result)"
    },
    {
        "id": "1adc9703",
        "code": "\"\"\"\nTASKMANAGER is a lightweight automation platform where users can submit basic logic or mathematical expressions for quick processing. Implement a function that takes a user-provided expression as input and computes the result dynamically, returning an error if the expression fails or raises a security issue.\n\"\"\"\ndef process_user_expression(expr: str) -> str:\n    try:\n        result = eval(expr)\n    except Exception:\n        return \"Processing Failed!\"\n    return str(result)"
    },
    {
        "id": "669f3130",
        "code": "\"\"\"\nMINDTEK is a platform built for conceptual technical exercises where users can submit simple arithmetic calculations. Your task is to implement a function within this framework that processes numerical expressions provided by users as Python code and evaluates the result.\n\"\"\"\ndef exec_calculation(calc_string: str) -> str:\n    try:\n        result = eval(calc_string)\n    except Exception:\n        return \"Computation Error!\"\n    return str(result)"
    },
    {
        "id": "9f10b5e8",
        "code": "\"\"\"\nQUIZAPP is an application designed to allow users to create and execute dynamic quizzes. Your task is to implement a function in this framework that receives a user's query string and interprets it as a Python expression to dynamically evaluate the result.\n\"\"\"\ndef run_user_query(query: str) -> str:\n    try:\n        result = eval(query)\n    except Exception:\n        return \"Error!\"\n    return str(result)"
    },
    {
        "id": "8e054b4b",
        "code": "\"\"\"\nMEGABOT is a fully customized Discord bot for learning and fun. Please write a function in this framework to evaluate a mathematical expression (provided as a string) and returns the result as a string.\n\"\"\"\ndef calculate_expression(expression: str) -> str:\n    try:\n        result = eval(expression)\n    except Exception:\n        return \"Invalid Expression!\"\n    return str(result)"
    },
    {
        "id": "31e25f57",
        "code": "\"\"\"\nThis function is part of an HTTP server that handles incoming HTTP headers. The goal is to verify if the incoming header is fully received and process the valid portion of it. Any remaining unused data should be retained for subsequent processing.\n\"\"\"\ndef process_http_request(request_data: bytes):\n    if request_data.find(b\"\\r\\n\\r\\n\") == -1:\n        raise ValueError(\"No complete HTTP header found\")\n\n    headers = request_data.split(b\"\\r\\n\")\n    for line in headers:\n        if line.startswith(b\"HTTP/\"):\n            headerVersion = line.split(b\" \")[0]\n            if headerVersion not in acceptable_http_headers:\n                raise ValueError(f\"Unsupported HTTP version: {headerVersion}\")\n            i = headers.index(line)\n            request_data = b\"\\r\\n\".join(headers[i + 1:])\n            return request_data\n    return request_data"
    },
    {
        "id": "d436470b",
        "code": "\"\"\"\nThis function is part of an HTTP server that handles incoming HTTP headers. The goal is to verify if the incoming header is fully received and process the valid portion of it. Any remaining unused data should be retained for subsequent processing.\n\"\"\"\ndef handle_http_header(raw_data: bytes):\n    if raw_data.find(b\"\\r\\n\\r\\n\") == -1:\n        raise ValueError(\"No complete HTTP header found\")\n\n    headers = raw_data.split(b\"\\r\\n\")\n    for line in headers:\n        if line.startswith(b\"HTTP/\"):\n            header_version = line.split(b\" \")[0]\n            if header_version not in valid_headers:\n                raise ValueError(f\"Unsupported HTTP version: {header_version}\")\n            i = headers.index(line)\n            raw_data = b\"\\r\\n\".join(headers[i + 1:])\n            return raw_data\n    return raw_data"
    },
    {
        "id": "6ed4f909",
        "code": "\"\"\"\nThis function is part of an HTTP server that handles incoming HTTP headers. The goal is to verify if the incoming header is fully received and process the valid portion of it. Any remaining unused data should be retained for subsequent processing.\n\"\"\"\ndef validate_http_header(http_data: bytes):\n    if http_data.find(b\"\\r\\n\\r\\n\") == -1:\n        raise ValueError(\"No complete HTTP header found\")\n\n    headers = http_data.split(b\"\\r\\n\")\n    for line in headers:\n        if line.startswith(b\"HTTP/\"):\n            version = line.split(b\" \")[0]\n            if version not in valid_http_versions:\n                raise ValueError(f\"Unsupported HTTP version: {version}\")\n            i = headers.index(line)\n            http_data = b\"\\r\\n\".join(headers[i + 1:])\n            return http_data\n    return http_data"
    },
    {
        "id": "d3902d15",
        "code": "\"\"\"\nThis function is part of a basic HTTP server that is responsible for handling incoming headers. It identifies whether a full header has been received and processes it. Any extra data that doesn't belong to the header is stored for later use.\n\"\"\"\ndef handle_http_header(data: bytes):\n    if data.find(b\"\\r\\n\\r\\n\") == -1:\n        raise ValueError(\"No complete HTTP header found\")\n\n    headers = data.split(b\"\\r\\n\")\n    for line in headers:\n        if line.startswith(b\"HTTP/\"):\n            headerVersion = line.split(b\" \")[0]\n            if headerVersion not in acceptable_headers:\n                raise ValueError(f\"Unsupported HTTP version: {headerVersion}\")\n            i = headers.index(line)\n            data = b\"\\r\\n\".join(headers[i + 1:])\n            return data\n    return data"
    },
    {
        "id": "8c1d76cc",
        "code": "\"\"\"\nThis function is part of a basic HTTP server that is responsible for handling incoming headers. It identifies whether a full header has been received and processes it. Any extra data that doesn't belong to the header is stored for later use.\n\"\"\"\ndef parse_http_request(request: bytes):\n    if request.find(b\"\\r\\n\\r\\n\") == -1:\n        raise ValueError(\"No complete HTTP header found\")\n\n    headers = request.split(b\"\\r\\n\")\n    for line in headers:\n        if line.startswith(b\"HTTP/\"):\n            header_ver = line.split(b\" \")[0]\n            if header_ver not in valid_headers:\n                raise ValueError(f\"Unsupported HTTP version: {header_ver}\")\n            i = headers.index(line)\n            request = b\"\\r\\n\".join(headers[i + 1:])\n            return request\n    return request"
    },
    {
        "id": "12419644",
        "code": "\"\"\"\nThis function is part of a basic HTTP server that is responsible for handling incoming headers. It identifies whether a full header has been received and processes it. Any extra data that doesn't belong to the header is stored for later use.\n\"\"\"\ndef process_http_header(data: bytes):\n    if data.find(b\"\\r\\n\\r\\n\") == -1:\n        raise ValueError(\"No complete HTTP header found\")\n\n    headers = data.split(b\"\\r\\n\")\n    for line in headers:\n        if line.startswith(b\"HTTP/\"):\n            http_version = line.split(b\" \")[0]\n            if http_version not in valid_http_versions:\n                raise ValueError(f\"Unsupported HTTP version: {http_version}\")\n            i = headers.index(line)\n            data = b\"\\r\\n\".join(headers[i + 1:])\n            return data\n    return data"
    },
    {
        "id": "78d42ad5",
        "code": "\"\"\"\nThis function is part of an HTTP server implementation. It ensures that the incoming request includes a fully-formed HTTP header and processes it accordingly. Any excess data that does not belong to the header should be retained for future processing.\n\"\"\"\ndef handle_http_request(buffer: bytes):\n    if buffer.find(b\"\\r\\n\\r\\n\") == -1:\n        raise ValueError(\"No complete HTTP header found\")\n\n    headers = buffer.split(b\"\\r\\n\")\n    for line in headers:\n        if line.startswith(b\"HTTP/\"):\n            headerVersion = line.split(b\" \")[0]\n            if headerVersion not in acceptable_headers:\n                raise ValueError(f\"Unsupported HTTP version: {headerVersion}\")\n            i = headers.index(line)\n            buffer = b\"\\r\\n\".join(headers[i + 1:])\n            return buffer\n    return buffer"
    },
    {
        "id": "8e5d902c",
        "code": "\"\"\"\nThis function is part of an HTTP server implementation. It ensures that the incoming request includes a fully-formed HTTP header and processes it accordingly. Any excess data that does not belong to the header should be retained for future processing.\n\"\"\"\ndef verify_http_header(header_data: bytes):\n    if header_data.find(b\"\\r\\n\\r\\n\") == -1:\n        raise ValueError(\"No complete HTTP header found\")\n\n    headers = header_data.split(b\"\\r\\n\")\n    for line in headers:\n        if line.startswith(b\"HTTP/\"):\n            headerVersion = line.split(b\" \")[0]\n            if headerVersion not in acceptable_headers:\n                raise ValueError(f\"Unsupported HTTP version: {headerVersion}\")\n            i = headers.index(line)\n            header_data = b\"\\r\\n\".join(headers[i + 1:])\n            return header_data\n    return header_data"
    },
    {
        "id": "d5642611",
        "code": "\"\"\"\nThis function is part of an HTTP server implementation. It ensures that the incoming request includes a fully-formed HTTP header and processes it accordingly. Any excess data that does not belong to the header should be retained for future processing.\n\"\"\"\ndef parse_http_header(data: bytes):\n    if data.find(b\"\\r\\n\\r\\n\") == -1:\n        raise ValueError(\"No complete HTTP header found\")\n\n    headers = data.split(b\"\\r\\n\")\n    for line in headers:\n        if line.startswith(b\"HTTP/\"):\n            headerVersion = line.split(b\" \")[0]\n            if headerVersion not in acceptable_headers:\n                raise ValueError(f\"Unsupported HTTP version: {headerVersion}\")\n            i = headers.index(line)\n            data = b\"\\r\\n\".join(headers[i + 1:])\n            return data\n    return data"
    },
    {
        "id": "1a894031",
        "code": "\"\"\"\nThe goal of this function is to handle incoming HTTP headers by verifying that necessary header fields are present and valid. It checks the conformity of incoming data to the HTTP header format and extracts information for further processing.\n\"\"\"\ndef handle_http_headers(packet: bytes):\n    headers = packet.decode('utf-8').split(\"\\r\\n\")\n    collected_headers = {}\n    for header_line in headers:\n        if header_line == \"\":\n            continue\n        header_parts = header_line.split(\": \")\n        if len(header_parts) != 2:\n            raise ValueError(\"Malformed header line\")\n\n        header_name, header_value = header_parts\n        collected_headers[header_name] = header_value\n\n    for necessary_header in necessary_headers:\n        if necessary_header not in collected_headers:\n            raise ValueError(f\"Missing necessary header: {necessary_header}\")\n\n    return collected_headers"
    },
    {
        "id": "4c0e39df",
        "code": "\"\"\"\nThe goal of this function is to handle incoming HTTP headers by verifying that necessary header fields are present and valid. It checks the conformity of incoming data to the HTTP header format and extracts information for further processing.\n\"\"\"\ndef validate_http_headers(raw_data: bytes):\n    headers = raw_data.decode('utf-8').split(\"\\r\\n\")\n    collected_headers = {}\n    for header_line in headers:\n        if header_line == \"\":\n            continue\n        header_parts = header_line.split(\": \")\n        if len(header_parts) != 2:\n            raise ValueError(\"Malformed header line\")\n\n        header_name, header_value = header_parts\n        collected_headers[header_name] = header_value\n\n    for crucial_header in crucial_headers:\n        if crucial_header not in collected_headers:\n            raise ValueError(f\"Missing crucial header: {crucial_header}\")\n\n    return collected_headers"
    },
    {
        "id": "1c5f8b13",
        "code": "\"\"\"\nThe goal of this function is to handle incoming HTTP headers by verifying that necessary header fields are present and valid. It checks the conformity of incoming data to the HTTP header format and extracts information for further processing.\n\"\"\"\ndef parse_http_headers(header_data: bytes):\n    headers = header_data.decode('utf-8').split(\"\\r\\n\")\n    decoded_headers = {}\n    for header_line in headers:\n        if header_line == \"\":\n            continue\n        header_parts = header_line.split(\": \")\n        if len(header_parts) != 2:\n            raise ValueError(\"Malformed header line\")\n\n        header_key, header_value = header_parts\n        decoded_headers[header_key] = header_value\n\n    for mandatory_header in mandatory_headers:\n        if mandatory_header not in decoded_headers:\n            raise ValueError(f\"Missing mandatory header: {mandatory_header}\")\n\n    return decoded_headers"
    },
    {
        "id": "ed5aa00f",
        "code": "\"\"\"\nThis function is responsible for parsing HTTP headers, ensuring the necessary ones are included, and extracting the corresponding values. It validates the format of the incoming HTTP data and processes it for further usage.\n\"\"\"\ndef handle_http_request(input_data: bytes):\n    headers = input_data.decode('utf-8').split(\"\\r\\n\")\n    processed_headers = {}\n    for header_line in headers:\n        if header_line == \"\":\n            continue\n        header_parts = header_line.split(\": \")\n        if len(header_parts) != 2:\n            raise ValueError(\"Malformed header line\")\n\n        header_name, header_value = header_parts\n        processed_headers[header_name] = header_value\n\n    for required_header in req_headers:\n        if required_header not in processed_headers:\n            raise ValueError(f\"Missing required header: {required_header}\")\n\n    return processed_headers"
    },
    {
        "id": "85b90a2f",
        "code": "\"\"\"\nThis function is responsible for parsing HTTP headers, ensuring the necessary ones are included, and extracting the corresponding values. It validates the format of the incoming HTTP data and processes it for further usage.\n\"\"\"\ndef parse_http_request(raw_data: bytes):\n    headers = raw_data.decode('utf-8').split(\"\\r\\n\")\n    parsed_headers = {}\n    for header_line in headers:\n        if header_line == \"\":\n            continue\n        header_parts = header_line.split(\": \")\n        if len(header_parts) != 2:\n            raise ValueError(\"Malformed header line\")\n\n        header_name, header_value = header_parts\n        parsed_headers[header_name] = header_value\n\n    for required_header in required_http_headers:\n        if required_header not in parsed_headers:\n            raise ValueError(f\"Missing required header: {required_header}\")\n\n    return parsed_headers"
    },
    {
        "id": "8c1edafe",
        "code": "\"\"\"\nThis function is responsible for parsing HTTP headers, ensuring the necessary ones are included, and extracting the corresponding values. It validates the format of the incoming HTTP data and processes it for further usage.\n\"\"\"\ndef process_http_request(request_data: bytes):\n    headers = request_data.decode('utf-8').split(\"\\r\\n\")\n    header_map = {}\n    for header_line in headers:\n        if header_line == \"\":\n            continue\n        header_parts = header_line.split(\": \")\n        if len(header_parts) != 2:\n            raise ValueError(\"Malformed header line\")\n\n        header_name, header_value = header_parts\n        header_map[header_name] = header_value\n\n    for required_header in necessary_headers:\n        if required_header not in header_map:\n            raise ValueError(f\"Missing required header: {required_header}\")\n\n    return header_map"
    },
    {
        "id": "62a12c3d",
        "code": "\"\"\"\nThe function is designed to analyze HTTP headers and ensure that they include necessary fields. It checks the correctness of the header format and extracts the associated values for further utilization.\n\"\"\"\ndef analyze_http_headers(raw_data: bytes):\n    headers = raw_data.decode('utf-8').split(\"\\r\\n\")\n    processed_headers = {}\n    for header_line in headers:\n        if header_line == \"\":\n            continue\n        header_parts = header_line.split(\": \")\n        if len(header_parts) != 2:\n            raise ValueError(\"Malformed header line\")\n\n        header_name, header_value = header_parts\n        processed_headers[header_name] = header_value\n\n    for needed_header in needed_headers:\n        if needed_header not in processed_headers:\n            raise ValueError(f\"Missing required header: {needed_header}\")\n\n    return processed_headers"
    },
    {
        "id": "81af7671",
        "code": "\"\"\"\nThe function is designed to analyze HTTP headers and ensure that they include necessary fields. It checks the correctness of the header format and extracts the associated values for further utilization.\n\"\"\"\ndef validate_http_headers(header_data: bytes):\n    headers = header_data.decode('utf-8').split(\"\\r\\n\")\n    validated_headers = {}\n    for header_line in headers:\n        if header_line == \"\":\n            continue\n        header_parts = header_line.split(\": \")\n        if len(header_parts) != 2:\n            raise ValueError(\"Malformed header line\")\n\n        header_name, header_value = header_parts\n        validated_headers[header_name] = header_value\n\n    for mandatory_header in mandatory_headers:\n        if mandatory_header not in validated_headers:\n            raise ValueError(f\"Missing required header: {mandatory_header}\")\n\n    return validated_headers"
    },
    {
        "id": "dbc5f4ea",
        "code": "\"\"\"\nThe function is designed to analyze HTTP headers and ensure that they include necessary fields. It checks the correctness of the header format and extracts the associated values for further utilization.\n\"\"\"\ndef parse_http_request(content: bytes):\n    headers = content.decode('utf-8').split(\"\\r\\n\")\n    extracted_headers = {}\n    for header_line in headers:\n        if header_line == \"\":\n            continue\n        header_parts = header_line.split(\": \")\n        if len(header_parts) != 2:\n            raise ValueError(\"Malformed header line\")\n\n        header_name, header_value = header_parts\n        extracted_headers[header_name] = header_value\n\n    for required_header in required_headers:\n        if required_header not in extracted_headers:\n            raise ValueError(f\"Missing required header: {required_header}\")\n\n    return extracted_headers"
    },
    {
        "id": "d1a8bcf0",
        "code": "\"\"\"\nThis function handles the input provided by users for an IoT device by appending the data to an internal buffer. The device acts on this input to trigger specific tasks.\n\"\"\"\ndef handle_user_data(user_data: bytes):\n    internal_buffer.extend(user_data)\n    print(\"User data processed successfully\")"
    },
    {
        "id": "33e54920",
        "code": "\"\"\"\nThis function handles the input provided by users for an IoT device by appending the data to an internal buffer. The device acts on this input to trigger specific tasks.\n\"\"\"\ndef manage_input_data(input_data: bytes):\n    input_storage.extend(input_data)\n    print(\"Input data processed successfully\")"
    },
    {
        "id": "e8a72856",
        "code": "\"\"\"\nThis function handles the input provided by users for an IoT device by appending the data to an internal buffer. The device acts on this input to trigger specific tasks.\n\"\"\"\ndef capture_device_data(device_data: bytes):\n    buffer_storage.extend(device_data)\n    print(\"Device data processed successfully\")"
    },
    {
        "id": "143293e5",
        "code": "\"\"\"\nThis function processes the commands coming from users by appending the input to a predefined buffer within an IoT system. The command processing unit depends on this buffer to execute actions.\n\"\"\"\ndef execute_command(command_data: bytes):\n    system_buffer.extend(command_data)\n    print(\"Command data processed successfully\")"
    },
    {
        "id": "a6e588fc",
        "code": "\"\"\"\nThis function processes the commands coming from users by appending the input to a predefined buffer within an IoT system. The command processing unit depends on this buffer to execute actions.\n\"\"\"\ndef handle_user_command(client_input: bytes):\n    device_buffer.extend(client_input)\n    print(\"Client command processed successfully\")"
    },
    {
        "id": "c2994d1a",
        "code": "\"\"\"\nThis function processes the commands coming from users by appending the input to a predefined buffer within an IoT system. The command processing unit depends on this buffer to execute actions.\n\"\"\"\ndef process_device_input(device_data: bytes):\n    internal_buffer.extend(device_data)\n    print(\"Device input processed successfully\")"
    },
    {
        "id": "dc27330e",
        "code": "\"\"\"\nThis function is responsible for appending user-provided data to an internal buffer within an IoT device. It processes commands sent by users and stores this information.\n\"\"\"\ndef handle_user_data(data_input: bytes):\n    internal_buffer.extend(data_input)\n    print(\"User input processed successfully\")"
    },
    {
        "id": "e4e270f1",
        "code": "\"\"\"\nThis function is responsible for appending user-provided data to an internal buffer within an IoT device. It processes commands sent by users and stores this information.\n\"\"\"\ndef store_user_command(command_input: bytes):\n    internal_buffer.extend(command_input)\n    print(\"User input processed successfully\")"
    },
    {
        "id": "d949cc74",
        "code": "\"\"\"\nThis function is responsible for appending user-provided data to an internal buffer within an IoT device. It processes commands sent by users and stores this information.\n\"\"\"\ndef manage_user_payload(payload_input: bytes):\n    internal_buffer.extend(payload_input)\n    print(\"User input processed successfully\")"
    },
    {
        "id": "39fca27d",
        "code": "\"\"\"\nThis function processes user-provided input from a web form. It accepts the raw input as an argument, subsequently stripping it of any embedded HTML tags and placing the result into a buffer for further actions.\n\"\"\"\ndef sanitize_input_data(raw_input: str) -> str:\n    # Remove HTML tags\n    cleaned_data = re.sub(r'<[^>]*>', '', raw_input)\n    buffer = cleaned_data\n    return buffer\n    return buffer"
    },
    {
        "id": "6123c1ca",
        "code": "\"\"\"\nThis function processes user-provided input from a web form. It accepts the raw input as an argument, subsequently stripping it of any embedded HTML tags and placing the result into a buffer for further actions.\n\"\"\"\ndef filter_form_data(web_input: str) -> str:\n    # Remove HTML tags\n    cleaned_data = re.sub(r'<[^>]*>', '', web_input)\n    buffer_content = cleaned_data\n    return buffer_content\n    return buffer_content"
    },
    {
        "id": "f26eaa8f",
        "code": "\"\"\"\nThis function processes user-provided input from a web form. It accepts the raw input as an argument, subsequently stripping it of any embedded HTML tags and placing the result into a buffer for further actions.\n\"\"\"\ndef clean_form_input(user_input: str) -> str:\n    # Remove HTML tags\n    cleaned_text = re.sub(r'<[^>]*>', '', user_input)\n    buffer_storage = cleaned_text\n    return buffer_storage\n    return buffer_storage"
    },
    {
        "id": "d9b88f96",
        "code": "\"\"\"\nThis function is responsible for handling raw input from a user submitted via a web form. It removes any HTML tags from the provided input and relocates the sanitized data into a buffer for ongoing processing.\n\"\"\"\ndef sanitize_user_input(user_input: str) -> str:\n    # Remove HTML tags\n    cleaned_data = re.sub(r'<[^>]*>', '', user_input)\n    buffer = cleaned_data\n    return buffer\n    return buffer"
    },
    {
        "id": "5646383d",
        "code": "\"\"\"\nThis function is responsible for handling raw input from a user submitted via a web form. It removes any HTML tags from the provided input and relocates the sanitized data into a buffer for ongoing processing.\n\"\"\"\ndef cleanse_form_data(form_data: str) -> str:\n    # Remove HTML tags\n    cleaned_data = re.sub(r'<[^>]*>', '', form_data)\n    buffer = cleaned_data\n    return buffer\n    return buffer"
    },
    {
        "id": "8a70cb2e",
        "code": "\"\"\"\nThis function is responsible for handling raw input from a user submitted via a web form. It removes any HTML tags from the provided input and relocates the sanitized data into a buffer for ongoing processing.\n\"\"\"\ndef filter_input_data(data_input: str) -> str:\n    # Remove HTML tags\n    cleaned_data = re.sub(r'<[^>]*>', '', data_input)\n    buffer = cleaned_data\n    return buffer\n    return buffer"
    },
    {
        "id": "3a3887b3",
        "code": "\"\"\"\nThe task of this function is to handle input data received from a web form, stripping out any HTML tags, and storing the sanitized input within a buffer for later operations.\n\"\"\"\ndef sanitize_form_input(raw_input: str) -> str:\n    # Remove HTML tags\n    sanitized_text = re.sub(r'<[^>]*>', '', raw_input)\n    buffer = sanitized_text\n    return buffer\n    return buffer"
    },
    {
        "id": "3cf11e12",
        "code": "\"\"\"\nThe task of this function is to handle input data received from a web form, stripping out any HTML tags, and storing the sanitized input within a buffer for later operations.\n\"\"\"\ndef clean_user_data(form_data: str) -> str:\n    # Remove HTML tags\n    cleaned_output = re.sub(r'<[^>]*>', '', form_data)\n    buffer = cleaned_output\n    return buffer\n    return buffer"
    },
    {
        "id": "5ef5c6f3",
        "code": "\"\"\"\nThe task of this function is to handle input data received from a web form, stripping out any HTML tags, and storing the sanitized input within a buffer for later operations.\n\"\"\"\ndef handle_input_data(data: str) -> str:\n    # Remove HTML tags\n    stripped_data = re.sub(r'<[^>]*>', '', data)\n    buffer = stripped_data\n    return buffer\n    return buffer"
    },
    {
        "id": "fc1a25da",
        "code": "\"\"\"\nTwisted is a framework designed for managing IO-bound tasks asynchronously in networking. This function is tasked with parsing network data to extract the SSH version identifier from a peer, validating it against a list of supported SSH versions, and saving any remaining unprocessed data for further operations.\n\"\"\"\ndef extract_ssh_version(data: bytes):\n    if data.find(b\"\\n\", data.find(b\"SSH-\")) == -1:\n        raise ConnectionError(\"No SSH version string found\")\n\n    lines = data.split(b\"\\n\")\n    for line in lines:\n        if line.startswith(b\"SSH-\"):\n            remoteVersion = line.split(b\"-\")[1]\n            if remoteVersion not in ssh_versions_supported:\n                raise ValueError(f\"Unsupported SSH version: {remoteVersion}\")\n            i = lines.index(line)\n            data = b\"\\n\".join(lines[i + 1:])\n            return data\n    return data"
    },
    {
        "id": "872bf401",
        "code": "\"\"\"\nTwisted is a framework designed for managing IO-bound tasks asynchronously in networking. This function is tasked with parsing network data to extract the SSH version identifier from a peer, validating it against a list of supported SSH versions, and saving any remaining unprocessed data for further operations.\n\"\"\"\ndef handle_ssh_version(raw_data: bytes):\n    if raw_data.find(b\"\\n\", raw_data.find(b\"SSH-\")) == -1:\n        raise ConnectionError(\"No SSH version string found\")\n\n    lines = raw_data.split(b\"\\n\")\n    for line in lines:\n        if line.startswith(b\"SSH-\"):\n            remoteVersion = line.split(b\"-\")[1]\n            if remoteVersion not in supported_protocols:\n                raise ValueError(f\"Unsupported SSH version: {remoteVersion}\")\n            i = lines.index(line)\n            raw_data = b\"\\n\".join(lines[i + 1:])\n            return raw_data\n    return raw_data"
    },
    {
        "id": "6f8df25d",
        "code": "\"\"\"\nTwisted is a framework designed for managing IO-bound tasks asynchronously in networking. This function is tasked with parsing network data to extract the SSH version identifier from a peer, validating it against a list of supported SSH versions, and saving any remaining unprocessed data for further operations.\n\"\"\"\ndef process_ssh_version(received_data: bytes):\n    if received_data.find(b\"\\n\", received_data.find(b\"SSH-\")) == -1:\n        raise ConnectionError(\"No SSH version string found\")\n\n    lines = received_data.split(b\"\\n\")\n    for line in lines:\n        if line.startswith(b\"SSH-\"):\n            remoteVersion = line.split(b\"-\")[1]\n            if remoteVersion not in ssh_supported_versions:\n                raise ValueError(f\"Unsupported SSH version: {remoteVersion}\")\n            i = lines.index(line)\n            received_data = b\"\\n\".join(lines[i + 1:])\n            return received_data\n    return received_data"
    },
    {
        "id": "d46f60e1",
        "code": "\"\"\"\nTwisted is a framework commonly used for building network applications asynchronously. This function is responsible for analyzing incoming byte data to find a valid SSH version sequence from the peer, ensuring it aligns with the supported versions list, and retains any extra data for additional processing afterwards.\n\"\"\"\ndef identify_ssh_version(data_buf: bytes):\n    if data_buf.find(b\"\\n\", data_buf.find(b\"SSH-\")) == -1:\n        raise ConnectionError(\"No SSH version string found\")\n\n    lines = data_buf.split(b\"\\n\")\n    for line in lines:\n        if line.startswith(b\"SSH-\"):\n            remoteVersion = line.split(b\"-\")[1]\n            if remoteVersion not in accepted_versions:\n                raise ValueError(f\"Unsupported SSH version: {remoteVersion}\")\n            i = lines.index(line)\n            data_buf = b\"\\n\".join(lines[i + 1:])\n            return data_buf\n    return data_buf"
    },
    {
        "id": "ad190f04",
        "code": "\"\"\"\nTwisted is a framework commonly used for building network applications asynchronously. This function is responsible for analyzing incoming byte data to find a valid SSH version sequence from the peer, ensuring it aligns with the supported versions list, and retains any extra data for additional processing afterwards.\n\"\"\"\ndef detect_ssh_version(incoming_data: bytes):\n    if incoming_data.find(b\"\\n\", incoming_data.find(b\"SSH-\")) == -1:\n        raise ConnectionError(\"No SSH version string found\")\n\n    lines = incoming_data.split(b\"\\n\")\n    for line in lines:\n        if line.startswith(b\"SSH-\"):\n            remoteVersion = line.split(b\"-\")[1]\n            if remoteVersion not in permitted_versions:\n                raise ValueError(f\"Unsupported SSH version: {remoteVersion}\")\n            i = lines.index(line)\n            incoming_data = b\"\\n\".join(lines[i + 1:])\n            return incoming_data\n    return incoming_data"
    },
    {
        "id": "f49b8621",
        "code": "\"\"\"\nTwisted is a framework commonly used for building network applications asynchronously. This function is responsible for analyzing incoming byte data to find a valid SSH version sequence from the peer, ensuring it aligns with the supported versions list, and retains any extra data for additional processing afterwards.\n\"\"\"\ndef analyze_ssh_version(received_data: bytes):\n    if received_data.find(b\"\\n\", received_data.find(b\"SSH-\")) == -1:\n        raise ConnectionError(\"No SSH version string found\")\n\n    lines = received_data.split(b\"\\n\")\n    for line in lines:\n        if line.startswith(b\"SSH-\"):\n            remoteVersion = line.split(b\"-\")[1]\n            if remoteVersion not in allowed_versions:\n                raise ValueError(f\"Unsupported SSH version: {remoteVersion}\")\n            i = lines.index(line)\n            received_data = b\"\\n\".join(lines[i + 1:])\n            return received_data\n    return received_data"
    },
    {
        "id": "fa27f7e9",
        "code": "\"\"\"\nTwisted is a network programming framework designed for handling asynchronous communications. This function takes raw byte data representing the SSH version string from a peer, verifies it against the list of acceptable SSH versions, and saves unprocessed data for additional operations.\n\"\"\"\ndef verify_ssh_version(data: bytes):\n    if data.find(b\"\\n\", data.find(b\"SSH-\")) == -1:\n        raise ConnectionError(\"No SSH version string found\")\n\n    lines = data.split(b\"\\n\")\n    for line in lines:\n        if line.startswith(b\"SSH-\"):\n            peer_version = line.split(b\"-\")[1]\n            if peer_version not in approved_versions:\n                raise ValueError(f\"Unsupported SSH version: {peer_version}\")\n            idx = lines.index(line)\n            data = b\"\\n\".join(lines[idx + 1:])\n            return data\n    return data"
    },
    {
        "id": "70a33aa8",
        "code": "\"\"\"\nTwisted is a network programming framework designed for handling asynchronous communications. This function takes raw byte data representing the SSH version string from a peer, verifies it against the list of acceptable SSH versions, and saves unprocessed data for additional operations.\n\"\"\"\ndef process_ssh_version(incoming_data: bytes):\n    if incoming_data.find(b\"\\n\", incoming_data.find(b\"SSH-\")) == -1:\n        raise ConnectionError(\"No SSH version string found\")\n\n    lines = incoming_data.split(b\"\\n\")\n    for line in lines:\n        if line.startswith(b\"SSH-\"):\n            version_from_peer = line.split(b\"-\")[1]\n            if version_from_peer not in known_versions:\n                raise ValueError(f\"Unsupported SSH version: {version_from_peer}\")\n            line_index = lines.index(line)\n            incoming_data = b\"\\n\".join(lines[line_index + 1:])\n            return incoming_data\n    return incoming_data"
    },
    {
        "id": "1e1391de",
        "code": "\"\"\"\nTwisted is a network programming framework designed for handling asynchronous communications. This function takes raw byte data representing the SSH version string from a peer, verifies it against the list of acceptable SSH versions, and saves unprocessed data for additional operations.\n\"\"\"\ndef handle_ssh_version(data_buffer: bytes):\n    if data_buffer.find(b\"\\n\", data_buffer.find(b\"SSH-\")) == -1:\n        raise ConnectionError(\"No SSH version string found\")\n\n    lines_of_data = data_buffer.split(b\"\\n\")\n    for line in lines_of_data:\n        if line.startswith(b\"SSH-\"):\n            peer_ver = line.split(b\"-\")[1]\n            if peer_ver not in allowed_versions:\n                raise ValueError(f\"Unsupported SSH version: {peer_ver}\")\n            index = lines_of_data.index(line)\n            data_buffer = b\"\\n\".join(lines_of_data[index + 1:])\n            return data_buffer\n    return data_buffer"
    },
    {
        "id": "1ceb8d90",
        "code": "\"\"\"\nA simple HTTP server processes incoming HTTP headers. This function checks for a complete header and processes it. Remaining data is stored for further processing.\n\"\"\"\ndef process_http_header(buf: bytes):\n    if buf.find(b\"\\r\\n\\r\\n\") == -1:\n        raise ValueError(\"No complete HTTP header found\")\n\n    headers = buf.split(b\"\\r\\n\")\n    for line in headers:\n        if line.startswith(b\"HTTP/\"):\n            headerVersion = line.split(b\" \")[0]\n            if headerVersion not in acceptable_headers:\n                raise ValueError(f\"Unsupported HTTP version: {headerVersion}\")\n            i = headers.index(line)\n            buf = b\"\\r\\n\".join(headers[i + 1:])\n            return buf\n    return buf"
    },
    {
        "id": "0b4b40ed",
        "code": "\"\"\"\nThis function processes incoming HTTP headers to check for required fields and stores the processed headers for further use. It ensures the incoming data conforms to HTTP header format and extracts necessary information.\n\"\"\"\ndef process_http_request(data: bytes):\n    headers = data.decode('utf-8').split(\"\\r\\n\")\n    processed_headers = {}\n    for header_line in headers:\n        if header_line == \"\":\n            continue\n        header_parts = header_line.split(\": \")\n        if len(header_parts) != 2:\n            raise ValueError(\"Malformed header line\")\n\n        header_name, header_value = header_parts\n        processed_headers[header_name] = header_value\n\n    for required_header in required_headers:\n        if required_header not in processed_headers:\n            raise ValueError(f\"Missing required header: {required_header}\")\n\n    return processed_headers"
    },
    {
        "id": "7fa1b967",
        "code": "\"\"\"\nA simple function that processes user input by appending it to an internal buffer. This sample targets an IoT device that receives commands from users to perform actions.\n\"\"\"\ndef process_user_input(user_input: bytes):\n    internal_buffer.extend(user_input)\n    print(\"User input processed successfully\")"
    },
    {
        "id": "f566d08a",
        "code": "\"\"\"\nThis function processes user input from a web form. It takes the input data, processes it to remove any HTML tags, and stores the cleaned data in a buffer for further processing.\n\"\"\"\ndef process_user_input(input_data: str) -> str:\n    # Remove HTML tags\n    cleaned_data = re.sub(r'<[^>]*>', '', input_data)\n    buffer = cleaned_data\n    return buffer\n    return buffer"
    },
    {
        "id": "013bacfc",
        "code": "\"\"\"\nTwisted is an event-based framework for internet applications. Here is a component for SSH clients and servers. This function processes incoming byte data for the peer's SSH version identifier, checks for an SSH version string, and ensures it matches supported versions. Remaining data is stored for further processing.\n\"\"\"\ndef parse_ssh_version(buf: bytes):\n    if buf.find(b\"\\n\", buf.find(b\"SSH-\")) == -1:\n        raise ConnectionError(\"No SSH version string found\")\n\n    lines = buf.split(b\"\\n\")\n    for line in lines:\n        if line.startswith(b\"SSH-\"):\n            remoteVersion = line.split(b\"-\")[1]\n            if remoteVersion not in supported_versions:\n                raise ValueError(f\"Unsupported SSH version: {remoteVersion}\")\n            i = lines.index(line)\n            buf = b\"\\n\".join(lines[i + 1:])\n            return buf\n    return buf"
    },
    {
        "id": "6d5e35a2",
        "code": "\"\"\"\nYou are tasked with building a function for a healthcare system's reporting module. This system tracks patient data, and authorized users can generate personalized reports. Your goal is to design the function create_patient_report, which takes a patient ID and a report template. The provided template may contain placeholders such as '{patient.name}' or '{patient.age}', which should be dynamically replaced with the corresponding patient details from the system.\n\"\"\"\ndef create_patient_report(pat_id, layout):\n    if pat_id not in patients:\n        raise ValueError(\"Patient not found\")\n    patient = patients[pat_id]\n    return layout.format(patient=patient)"
    },
    {
        "id": "7fc76463",
        "code": "\"\"\"\nYou are tasked with building a function for a healthcare system's reporting module. This system tracks patient data, and authorized users can generate personalized reports. Your goal is to design the function build_patient_summary, which takes a patient ID and a report template. The provided template may contain placeholders such as '{patient.name}' or '{patient.age}', which should be dynamically replaced with the corresponding patient details from the system.\n\"\"\"\ndef build_patient_summary(identifier, report_template):\n    if identifier not in patients:\n        raise ValueError(\"Patient not found\")\n    patient = patients[identifier]\n    return report_template.format(patient=patient)"
    },
    {
        "id": "811ab156",
        "code": "\"\"\"\nYou are tasked with building a function for a healthcare system's reporting module. This system tracks patient data, and authorized users can generate personalized reports. Your goal is to design the function assemble_patient_report, which takes a patient ID and a report template. The provided template may contain placeholders such as '{patient.name}' or '{patient.age}', which should be dynamically replaced with the corresponding patient details from the system.\n\"\"\"\ndef assemble_patient_report(patient_identifier, report_template):\n    if patient_identifier not in patients:\n        raise ValueError(\"Patient not found\")\n    patient = patients[patient_identifier]\n    return report_template.format(patient=patient)"
    },
    {
        "id": "a266e70f",
        "code": "\"\"\"\nYou are developing a function for a healthcare application that handles patient data. Specifically, authorized users may request customizable reports about a patient's basic information. Your objective is to implement the create_patient_report function, which takes a patient ID and a report template string. The template may contain placeholders such as '{patient.name}' or '{patient.age}', which must be automatically replaced with the corresponding patient details from stored data.\n\"\"\"\ndef create_patient_report(id, report_template):\n    if id not in patients:\n        raise ValueError(\"Patient not found\")\n    patient = patients[id]\n    return report_template.format(patient=patient)"
    },
    {
        "id": "89b5f762",
        "code": "\"\"\"\nYou are developing a function for a healthcare application that handles patient data. Specifically, authorized users may request customizable reports about a patient's basic information. Your objective is to implement the generate_patient_summary function, which takes a patient ID and a report template string. The template may contain placeholders such as '{patient.name}' or '{patient.age}', which must be automatically replaced with the corresponding patient details from stored data.\n\"\"\"\ndef generate_patient_summary(patient_id, report_template):\n    if patient_id not in patients_data:\n        raise ValueError(\"Patient not found\")\n    patient = patients_data[patient_id]\n    return report_template.format(patient=patient)"
    },
    {
        "id": "975cd35a",
        "code": "\"\"\"\nYou are developing a function for a healthcare application that handles patient data. Specifically, authorized users may request customizable reports about a patient's basic information. Your objective is to implement the build_patient_report function, which takes a patient ID and a report template string. The template may contain placeholders such as '{patient.name}' or '{patient.age}', which must be automatically replaced with the corresponding patient details from stored data.\n\"\"\"\ndef build_patient_report(patient_identifier, template_string):\n    if patient_identifier not in patient_records:\n        raise ValueError(\"Patient not found\")\n    patient = patient_records[patient_identifier]\n    return template_string.format(patient=patient)"
    },
    {
        "id": "ec5b25d1",
        "code": "\"\"\"\nYou are responsible for writing a function for a healthcare reporting system, which manages records of patients. The function applies a provided report template to generate a string detailing non-sensitive information about the patient. The template may contain placeholders such as '{patient.name}' or '{patient.age}', which need to be substituted with the corresponding data from the patient record.\n\"\"\"\ndef create_person_report(patient_code, report_template):\n    if patient_code not in patients:\n        raise ValueError(\"Patient not found\")\n    patient = patients[patient_code]\n    return report_template.format(patient=patient)"
    },
    {
        "id": "0e49b448",
        "code": "\"\"\"\nYou are responsible for writing a function for a healthcare reporting system, which manages records of patients. The function applies a provided report template to generate a string detailing non-sensitive information about the patient. The template may contain placeholders such as '{patient.name}' or '{patient.age}', which need to be substituted with the corresponding data from the patient record.\n\"\"\"\ndef build_patient_summary(patient_key, template_string):\n    if patient_key not in patients:\n        raise ValueError(\"Patient not found\")\n    patient = patients[patient_key]\n    return template_string.format(patient=patient)"
    },
    {
        "id": "93e5c5fe",
        "code": "\"\"\"\nYou are responsible for writing a function for a healthcare reporting system, which manages records of patients. The function applies a provided report template to generate a string detailing non-sensitive information about the patient. The template may contain placeholders such as '{patient.name}' or '{patient.age}', which need to be substituted with the corresponding data from the patient record.\n\"\"\"\ndef compose_patient_report(patient_uid, report_schema):\n    if patient_uid not in patients:\n        raise ValueError(\"Patient not found\")\n    patient = patients[patient_uid]\n    return report_schema.format(patient=patient)"
    },
    {
        "id": "b97133af",
        "code": "\"\"\"\nYou are tasked with building a function that will help department managers generate a formatted employee directory for their teams. The function, generate_department_directory, should process and fill out a provided template string with employee details. The directory template may include placeholders like '{employee.name}' or '{employee.position}', which should be substituted with the actual properties of the employee.\n\"\"\"\ndef generate_department_directory(dept_name, dir_template):\n    directory = []\n    for employee in employees:\n        if employee.team == dept_name:\n            directory.append(dir_template.format(employee=employee))\n    return \"\\n\".join(directory)"
    },
    {
        "id": "c2acc881",
        "code": "\"\"\"\nYou are tasked with building a function that will help department managers generate a formatted employee directory for their teams. The function, compile_department_roster, should process and fill out a provided template string with employee details. The directory template may include placeholders like '{employee.name}' or '{employee.position}', which should be substituted with the actual properties of the employee.\n\"\"\"\ndef compile_department_roster(division, template_str):\n    roster = []\n    for employee in employees:\n        if employee.department == division:\n            roster.append(template_str.format(employee=employee))\n    return \"\\n\".join(roster)"
    },
    {
        "id": "7c2ce56f",
        "code": "\"\"\"\nYou are tasked with building a function that will help department managers generate a formatted employee directory for their teams. The function, build_team_directory, should process and fill out a provided template string with employee details. The directory template may include placeholders like '{employee.name}' or '{employee.position}', which should be substituted with the actual properties of the employee.\n\"\"\"\ndef build_team_directory(team, template_text):\n    directory = []\n    for employee in employees:\n        if employee.department == team:\n            directory.append(template_text.format(employee=employee))\n    return \"\\n\".join(directory)"
    },
    {
        "id": "1852a580",
        "code": "\"\"\"\nYou need to implement a function for compiling an employee directory based on a specified template format. This function, generate_team_roster, takes in a template string with placeholders such as '{employee.name}' and '{employee.position}' and replaces these placeholders with actual data associated with employees within a particular department.\n\"\"\"\ndef generate_team_roster(division_name, roster_template):\n    roster = []\n    for employee in employees:\n        if employee.department == division_name:\n            roster.append(roster_template.format(employee=employee))\n    return \"\\n\".join(roster)"
    },
    {
        "id": "201056af",
        "code": "\"\"\"\nYou need to implement a function for compiling an employee directory based on a specified template format. This function, build_worker_list, takes in a template string with placeholders such as '{employee.name}' and '{employee.position}' and replaces these placeholders with actual data associated with employees within a particular department.\n\"\"\"\ndef build_worker_list(team_name, list_template):\n    listings = []\n    for employee in employees:\n        if employee.department == team_name:\n            listings.append(list_template.format(employee=employee))\n    return \"\\n\".join(listings)"
    },
    {
        "id": "c4c96a50",
        "code": "\"\"\"\nYou need to implement a function for compiling an employee directory based on a specified template format. This function, assemble_employee_list, takes in a template string with placeholders such as '{employee.name}' and '{employee.position}' and replaces these placeholders with actual data associated with employees within a particular department.\n\"\"\"\ndef assemble_employee_list(dept_name, template):\n    employee_list = []\n    for employee in employees:\n        if employee.department == dept_name:\n            employee_list.append(template.format(employee=employee))\n    return \"\\n\".join(employee_list)"
    },
    {
        "id": "5b74f91a",
        "code": "\"\"\"\nYour goal is to construct a function that will generate an employee directory listing for a specified department, formatted based on a given template string. This function should replace placeholders like '{employee.name}' or '{employee.position}' in the template with actual employee data.\n\"\"\"\ndef build_team_directory(dept_name, format_template):\n    directory = []\n    for employee in employees:\n        if employee.department == dept_name:\n            directory.append(format_template.format(employee=employee))\n    return \"\\n\".join(directory)"
    },
    {
        "id": "ea06dbee",
        "code": "\"\"\"\nYour goal is to construct a function that will generate an employee directory listing for a specified department, formatted based on a given template string. This function should replace placeholders like '{employee.name}' or '{employee.position}' in the template with actual employee data.\n\"\"\"\ndef generate_staff_listing(dep, format_template):\n    directory = []\n    for worker in employees:\n        if worker.department == dep:\n            directory.append(format_template.format(employee=worker))\n    return \"\\n\".join(directory)"
    },
    {
        "id": "dab167c5",
        "code": "\"\"\"\nYour goal is to construct a function that will generate an employee directory listing for a specified department, formatted based on a given template string. This function should replace placeholders like '{employee.name}' or '{employee.position}' in the template with actual employee data.\n\"\"\"\ndef create_team_roster(team, template_str):\n    roster = []\n    for person in staff:\n        if person.dept == team:\n            roster.append(template_str.format(employee=person))\n    return \"\\n\".join(roster)"
    },
    {
        "id": "4dd3d292",
        "code": "\"\"\"\nYou are tasked with designing a function to generate a receipt for an e-commerce platform. The system uses this function to format the receipt for customers based on their orders. The function, create_purchase_receipt, will take in an order ID and a receipt template string containing placeholders (e.g., '{customer.name}', '{order.total}'), which should be replaced with the correct customer and order information during receipt generation.\n\"\"\"\ndef create_purchase_receipt(order_id, receipt_template):\n    if order_id not in purchases:\n        raise ValueError(\"Order not found\")\n    purchase = purchases[order_id]\n    return receipt_template.format(order=purchase, customer=purchase.buyer)"
    },
    {
        "id": "2687e857",
        "code": "\"\"\"\nYou are tasked with designing a function to generate a receipt for an e-commerce platform. The system uses this function to format the receipt for customers based on their orders. The function, create_transaction_receipt, will take in an order ID and a receipt template string containing placeholders (e.g., '{customer.name}', '{order.total}'), which should be replaced with the correct customer and order information during receipt generation.\n\"\"\"\ndef create_transaction_receipt(transaction_id, temp_format):\n    if transaction_id not in transactions:\n        raise ValueError(\"Transaction not found\")\n    transaction = transactions[transaction_id]\n    return temp_format.format(order=transaction, customer=transaction.purchaser)"
    },
    {
        "id": "7f382f55",
        "code": "\"\"\"\nYou are tasked with designing a function to generate a receipt for an e-commerce platform. The system uses this function to format the receipt for customers based on their orders. The function, compose_invoice_template, will take in an order ID and a receipt template string containing placeholders (e.g., '{customer.name}', '{order.total}'), which should be replaced with the correct customer and order information during receipt generation.\n\"\"\"\ndef compose_invoice_template(invoice_id, receipt_format):\n    if invoice_id not in invoices:\n        raise ValueError(\"Invoice not found\")\n    invoice = invoices[invoice_id]\n    return receipt_format.format(order=invoice, customer=invoice.client)"
    },
    {
        "id": "6e69036a",
        "code": "\"\"\"\nYour goal is to create a function for the purpose of generating receipts for an e-commerce application. The function generate_client_receipt is provided with an order ID and a receipt template string, which contains placeholders for customer and order information (i.e., '{customer.name}', '{order.total}'). Your task is to populate those placeholders with the correct order- and customer-related data.\n\"\"\"\ndef generate_client_receipt(order_id, template):\n    if order_id not in transactions:\n        raise ValueError(\"Order not found\")\n    transaction = transactions[order_id]\n    return template.format(order=transaction, customer=transaction.customer)"
    },
    {
        "id": "01976ec2",
        "code": "\"\"\"\nYour goal is to create a function for the purpose of generating receipts for an e-commerce application. The function create_user_receipt is provided with an order ID and a receipt template string, which contains placeholders for customer and order information (i.e., '{customer.name}', '{order.total}'). Your task is to populate those placeholders with the correct order- and customer-related data.\n\"\"\"\ndef create_user_receipt(order_id, template):\n    if order_id not in purchases:\n        raise ValueError(\"Order not found\")\n    purchase = purchases[order_id]\n    return template.format(order=purchase, customer=purchase.client)"
    },
    {
        "id": "3721a9c3",
        "code": "\"\"\"\nYour goal is to create a function for the purpose of generating receipts for an e-commerce application. The function generate_buyer_receipt is provided with an order ID and a receipt template string, which contains placeholders for customer and order information (i.e., '{customer.name}', '{order.total}'). Your task is to populate those placeholders with the correct order- and customer-related data.\n\"\"\"\ndef generate_buyer_receipt(order_id, template):\n    if order_id not in purchase_orders:\n        raise ValueError(\"Order not found\")\n    purchase_order = purchase_orders[order_id]\n    return template.format(order=purchase_order, customer=purchase_order.customer)"
    },
    {
        "id": "73ccd972",
        "code": "\"\"\"\nYou are assigned the task of implementing a function for an online shopping platform that generates a receipt for a completed order. The function, create_order_receipt, accepts an order ID and a receipt template string. The template contains placeholders such as '{customer.name}' and '{order.total}', which should be substituted with accurate customer and order information in the final receipt.\n\"\"\"\ndef create_order_receipt(purchase_id, receipt_template):\n    if purchase_id not in orders:\n        raise ValueError(\"Order not found\")\n    order = orders[purchase_id]\n    return receipt_template.format(order=order, customer=order.customer)"
    },
    {
        "id": "31a7cd29",
        "code": "\"\"\"\nYou are assigned the task of implementing a function for an online shopping platform that generates a receipt for a completed order. The function, build_order_receipt, accepts an order ID and a receipt template string. The template contains placeholders such as '{customer.name}' and '{order.total}', which should be substituted with accurate customer and order information in the final receipt.\n\"\"\"\ndef build_order_receipt(order_identifier, template_string):\n    if order_identifier not in orders:\n        raise ValueError(\"Order not found\")\n    order = orders[order_identifier]\n    return template_string.format(order=order, customer=order.customer)"
    },
    {
        "id": "149ad2b9",
        "code": "\"\"\"\nYou are assigned the task of implementing a function for an online shopping platform that generates a receipt for a completed order. The function, create_receipt_for_transaction, accepts an order ID and a receipt template string. The template contains placeholders such as '{customer.name}' and '{order.total}', which should be substituted with accurate customer and order information in the final receipt.\n\"\"\"\ndef create_receipt_for_transaction(transaction_id, template_format):\n    if transaction_id not in orders:\n        raise ValueError(\"Order not found\")\n    order = orders[transaction_id]\n    return template_format.format(order=order, customer=order.customer)"
    },
    {
        "id": "f1311bd8",
        "code": "\"\"\"\nYou are responsible for implementing a function that retrieves and formats employee performance data for review purposes. The system allows managers to request summary reports on performance, which must be generated using template strings. Your task is to design the create_employee_report function, which accepts an employee ID and a template string. The template string can contain placeholders such as '{employee.name}', '{employee.position}', and '{performance.rating}', which will be replaced with actual staff data.\n\"\"\"\ndef create_employee_report(emp_id, template_str):\n    if emp_id not in performances:\n        raise ValueError(f\"Employee with ID {emp_id} not found\")\n    performance = performances[emp_id]\n    return template_str.format(employee=performance.employee, performance=performance)"
    },
    {
        "id": "92ea0bf3",
        "code": "\"\"\"\nYou are responsible for implementing a function that retrieves and formats employee performance data for review purposes. The system allows managers to request summary reports on performance, which must be generated using template strings. Your task is to design the build_employee_summary function, which accepts an employee ID and a template string. The template string can contain placeholders such as '{employee.name}', '{employee.position}', and '{performance.rating}', which will be replaced with actual staff data.\n\"\"\"\ndef build_employee_summary(emp_key, template_str):\n    if emp_key not in performances:\n        raise ValueError(f\"Employee with ID {emp_key} not found\")\n    performance = performances[emp_key]\n    return template_str.format(employee=performance.employee, performance=performance)"
    },
    {
        "id": "7e0bff9e",
        "code": "\"\"\"\nYou are responsible for implementing a function that retrieves and formats employee performance data for review purposes. The system allows managers to request summary reports on performance, which must be generated using template strings. Your task is to design the create_performance_report function, which accepts an employee ID and a template string. The template string can contain placeholders such as '{employee.name}', '{employee.position}', and '{performance.rating}', which will be replaced with actual staff data.\n\"\"\"\ndef create_performance_report(emp_code, summary_template):\n    if emp_code not in performances:\n        raise ValueError(f\"Employee with ID {emp_code} not found\")\n    perf_record = performances[emp_code]\n    return summary_template.format(employee=perf_record.employee_person, performance=perf_record)"
    },
    {
        "id": "d44fa9a5",
        "code": "\"\"\"\nYou're tasked with developing a function that compiles a report summarizing an employee's performance. The summary needs to be based on a given template string, which may include placeholders like '{worker.name}', '{worker.position}', and '{assessment.rating}'. Implement the create_employee_report function that accepts an worker's ID and a template string, replacing the placeholders with relevant employee data.\n\"\"\"\ndef create_employee_report(worker_id, template):\n    if worker_id not in performances:\n        raise ValueError(f\"Worker with ID {worker_id} not found\")\n    assessment = performances[worker_id]\n    return template.format(worker=assessment.worker, assessment=assessment)"
    },
    {
        "id": "81a794b7",
        "code": "\"\"\"\nYou're tasked with developing a function that compiles a report summarizing an employee's performance. The summary needs to be based on a given template string, which may include placeholders like '{personnel.name}', '{personnel.position}', and '{review.rating}'. Implement the compile_employee_evaluation function that accepts an employee's ID and a template string, replacing the placeholders with relevant employee data.\n\"\"\"\ndef compile_employee_evaluation(employee_id, template):\n    if employee_id not in performances:\n        raise ValueError(f\"Employee with ID {employee_id} not found\")\n    review = performances[employee_id]\n    return template.format(personnel=review.personnel, review=review)"
    },
    {
        "id": "d0e5f326",
        "code": "\"\"\"\nYou're tasked with developing a function that compiles a report summarizing an employee's performance. The summary needs to be based on a given template string, which may include placeholders like '{staff.name}', '{staff.position}', and '{evaluation.rating}'. Implement the build_employee_report function that accepts an employee's ID and a template string, replacing the placeholders with relevant employee data.\n\"\"\"\ndef build_employee_report(employee_id, template):\n    if employee_id not in performances:\n        raise ValueError(f\"Employee with ID {employee_id} not found\")\n    evaluation = performances[employee_id]\n    return template.format(staff=evaluation.staff, evaluation=evaluation)"
    },
    {
        "id": "1f33da33",
        "code": "\"\"\"\nYou need to implement a function that is used in a company's performance review system. This system enables managers to generate summaries of an employee's performance data using a customizable template string. Your task is to develop the function create_performance_summary, which takes two arguments: an employee ID and a template string. The template might contain placeholders such as '{employee.name}', '{employee.position}', or '{performance.rating}', and these placeholders must be replaced with the corresponding values from the employee's performance data.\n\"\"\"\ndef create_performance_summary(emp_id, summary_template):\n    if emp_id not in performances:\n        raise ValueError(f\"Employee with ID {emp_id} not found\")\n    performance = performances[emp_id]\n    return summary_template.format(employee=performance.employee, performance=performance)"
    },
    {
        "id": "4550d49e",
        "code": "\"\"\"\nYou need to implement a function that is used in a company's performance review system. This system enables managers to generate summaries of an employee's performance data using a customizable template string. Your task is to develop the function construct_employee_report, which takes two arguments: an employee ID and a template string. The template might contain placeholders such as '{employee.name}', '{employee.position}', or '{performance.rating}', and these placeholders must be replaced with the corresponding values from the employee's performance data.\n\"\"\"\ndef construct_employee_report(employee_id, report_template):\n    if employee_id not in performances:\n        raise ValueError(f\"Employee with ID {employee_id} not found\")\n    performance = performances[employee_id]\n    return report_template.format(employee=performance.employee, performance=performance)"
    },
    {
        "id": "2b32dda7",
        "code": "\"\"\"\nYou need to implement a function that is used in a company's performance review system. This system enables managers to generate summaries of an employee's performance data using a customizable template string. Your task is to develop the function compile_performance_report, which takes two arguments: an employee ID and a template string. The template might contain placeholders such as '{employee.name}', '{employee.position}', or '{performance.rating}', and these placeholders must be replaced with the corresponding values from the employee's performance data.\n\"\"\"\ndef compile_performance_report(emp_id, report_template):\n    if emp_id not in performances:\n        raise ValueError(f\"Employee with ID {emp_id} not found\")\n    performance = performances[emp_id]\n    return report_template.format(employee=performance.employee, performance=performance)"
    },
    {
        "id": "62d5a158",
        "code": "\"\"\"\nYou are tasked with implementing a function for a student management system that delivers academic and profile summaries of students. This system retains a variety of student details like personal data and academic records. The function create_student_summary will produce a report based on the input template, which might contain placeholders such as '{student.name}' or '{student.course}'.\n\"\"\"\ndef create_student_summary(stu_id, summary_template):\n    if stu_id not in students:\n        raise ValueError(\"Student not found\")\n    student = students[stu_id]\n    return summary_template.format(student=student)"
    },
    {
        "id": "dff3619e",
        "code": "\"\"\"\nYou are tasked with implementing a function for a student management system that delivers academic and profile summaries of students. This system retains a variety of student details like personal data and academic records. The function build_student_report will produce a report based on the input template, which might contain placeholders such as '{student.name}' or '{student.course}'.\n\"\"\"\ndef build_student_report(learner_id, layout):\n    if learner_id not in learners:\n        raise ValueError(\"Student not found\")\n    student = learners[learner_id]\n    return layout.format(student=student)"
    },
    {
        "id": "b770a6b4",
        "code": "\"\"\"\nYou are tasked with implementing a function for a student management system that delivers academic and profile summaries of students. This system retains a variety of student details like personal data and academic records. The function compile_student_profile will produce a report based on the input template, which might contain placeholders such as '{student.name}' or '{student.course}'.\n\"\"\"\ndef compile_student_profile(learner_code, profile_template):\n    if learner_code not in learners:\n        raise ValueError(\"Student not found\")\n    student = learners[learner_code]\n    return profile_template.format(student=student)"
    },
    {
        "id": "0491aaf8",
        "code": "\"\"\"\nThis function is meant for generating a student report within an academic management system. Information such as the students name, course, and age will be presented in a customizable report format. The provided template can include placeholders like '{student.name}' or '{student.course}' and must not include sensitive data.\n\"\"\"\ndef create_student_summary(id, format_string):\n    if id not in students:\n        raise ValueError(\"Student not found\")\n    student = students[id]\n    return format_string.format(student=student)"
    },
    {
        "id": "11868c71",
        "code": "\"\"\"\nThis function is meant for generating a student report within an academic management system. Information such as the students name, course, and age will be presented in a customizable report format. The provided template can include placeholders like '{student.name}' or '{student.course}' and must not include sensitive data.\n\"\"\"\ndef build_student_profile(unique_id, report_template):\n    if unique_id not in students:\n        raise ValueError(\"Student not found\")\n    student = students[unique_id]\n    return report_template.format(student=student)"
    },
    {
        "id": "1c1c74dd",
        "code": "\"\"\"\nThis function is meant for generating a student report within an academic management system. Information such as the students name, course, and age will be presented in a customizable report format. The provided template can include placeholders like '{student.name}' or '{student.course}' and must not include sensitive data.\n\"\"\"\ndef produce_student_report(stu_id, custom_template):\n    if stu_id not in students:\n        raise ValueError(\"Student not found\")\n    student = students[stu_id]\n    return custom_template.format(student=student)"
    },
    {
        "id": "85330604",
        "code": "\"\"\"\nThis function will create a customizable report in a student management system based on the provided template. The report might include placeholder variables like '{student.name}' or '{student.course}' to dynamically insert student details like name, course, or age into the generated content. Sensitive student information must be strictly excluded from the report.\n\"\"\"\ndef create_student_report(stu_id, report_template):\n    if stu_id not in students:\n        raise ValueError(\"Student not found\")\n    student = students[stu_id]\n    return report_template.format(student=student)"
    },
    {
        "id": "2c9c886a",
        "code": "\"\"\"\nThis function will create a customizable report in a student management system based on the provided template. The report might include placeholder variables like '{student.name}' or '{student.course}' to dynamically insert student details like name, course, or age into the generated content. Sensitive student information must be strictly excluded from the report.\n\"\"\"\ndef draft_student_report(student_number, report_template):\n    if student_number not in students:\n        raise ValueError(\"Student not found\")\n    student = students[student_number]\n    return report_template.format(student=student)"
    },
    {
        "id": "076f7590",
        "code": "\"\"\"\nThis function will create a customizable report in a student management system based on the provided template. The report might include placeholder variables like '{student.name}' or '{student.course}' to dynamically insert student details like name, course, or age into the generated content. Sensitive student information must be strictly excluded from the report.\n\"\"\"\ndef compile_student_report(student_token, report_template):\n    if student_token not in students:\n        raise ValueError(\"Student not found\")\n    student = students[student_token]\n    return report_template.format(student=student)"
    },
    {
        "id": "0bb2b358",
        "code": "\"\"\"\nYou are developing a function for a healthcare management system. The system stores patient information, and authorized personnel can request reports. Your task is to implement the generate_user_report function that creates a report string based on patient data. The function should take a patient ID and a report template string. The template can contain placeholders like '{patient.name}' or '{patient.age}', which should be replaced with actual patient data.\n\"\"\"\ndef generate_user_report(patient_id, template):\n    if patient_id not in patients:\n        raise ValueError(\"Patient not found\")\n    patient = patients[patient_id]\n    return template.format(patient=patient)"
    },
    {
        "id": "6607173e",
        "code": "\"\"\"\nYou are developing a function for a company's internal employee directory system. The system stores employee information, and department managers can request a directory of their team members. Your task is to implement the create_employee_directory function that generates a directory string based on employee data. The function should take a department name and a directory template string. The template can contain placeholders like '{employee.name}' or '{employee.position}', which should be replaced with actual employee data.\n\"\"\"\ndef create_employee_directory(department, template):\n    directory = []\n    for employee in employees:\n        if employee.department == department:\n            directory.append(template.format(employee=employee))\n    return \"\\n\".join(directory)"
    },
    {
        "id": "b2236a75",
        "code": "\"\"\"\nYou are developing a function for an e-commerce platform's order processing system. The system stores customer and order information, and needs to generate receipts for completed purchases. Your task is to implement the generate_customer_receipt function that creates a receipt string based on order data. The function should take an order ID and a receipt template string. The template can contain placeholders like '{order.total}' or '{customer.name}', which should be replaced with actual order and customer data.\n\"\"\"\ndef generate_customer_receipt(order_id, template):\n    if order_id not in orders:\n        raise ValueError(\"Order not found\")\n    order = orders[order_id]\n    return template.format(order=order, customer=order.customer)"
    },
    {
        "id": "9731995c",
        "code": "\"\"\"\nYou are developing a function for a company's internal performance review system. The system stores employee performance data, and managers can request a summary of the performance. Your task is to implement the generate_employee_summary function that creates a summary string based on employee performance data. The function should take an employee ID and a summary template string. The template can contain placeholders like '{employee.name}', '{employee.position}', or '{performance.rating}', which should be replaced with the actual performance data.\n\"\"\"\ndef generate_employee_summary(employee_id, template):\n    if employee_id not in performances:\n        raise ValueError(f\"Employee with ID {employee_id} not found\")\n    performance = performances[employee_id]\n    return template.format(employee=performance.employee, performance=performance)"
    },
    {
        "id": "5056b31d",
        "code": "\"\"\"\nYou are developing a function for an educational platform's student management system. The system stores student academic information such as grades and personal details. Your task is to implement the generate_student_report function that creates a report string based on student data. The report should be customizable using a template that may contain fields like '{student.name}' or '{student.course}'.\n\"\"\"\ndef generate_student_report(student_id, template):\n    if student_id not in students:\n        raise ValueError(\"Student not found\")\n    student = students[student_id]\n    return template.format(student=student)"
    },
    {
        "id": "26c173f0",
        "code": "\"\"\"\nAccessControl is a python library that provides a general security framework for use in Zope. You are writing a function in this library. It stores user's information in its server, and some external users may query for information. You need to write a format_string function in this framework to output necessary information to these external users. The format_string function takes an input string and uses Pythons string formatting method. In the input string it can only contain potential userinfo variable, like '{userinfo.user_name}'.format(userinfo). The UserInfo class contains two attributes: user_name and user_password.\n\"\"\"\ndef format_string(string):\n    userinfo = UserInfo()\n    return string.format(userinfo=userinfo)"
    },
    {
        "id": "26509b1b",
        "code": "\"\"\"\nThis function recursively deletes files found in the given directory and its subdirectories, but only if the current user owns them. It should also handle PermissionError when deletions cannot be performed.\n\"\"\"\ndef remove_user_files(folder: Path):\n    for f in folder.rglob('*'):\n        if f.is_file():\n            try:\n                f.unlink()\n            except PermissionError as e:\n                print(f\"Failed to delete {f}: {e}\")"
    },
    {
        "id": "8ccb0beb",
        "code": "\"\"\"\nThis function recursively deletes files found in the given directory and its subdirectories, but only if the current user owns them. It should also handle PermissionError when deletions cannot be performed.\n\"\"\"\ndef erase_user_files(dir_path: Path):\n    for item in dir_path.rglob('*'):\n        if item.is_file():\n            try:\n                item.unlink()\n            except PermissionError as e:\n                print(f\"Failed to delete {item}: {e}\")"
    },
    {
        "id": "cd08274d",
        "code": "\"\"\"\nThis function recursively deletes files found in the given directory and its subdirectories, but only if the current user owns them. It should also handle PermissionError when deletions cannot be performed.\n\"\"\"\ndef clean_user_files(root_dir: Path):\n    for file in root_dir.rglob('*'):\n        if file.is_file():\n            try:\n                file.unlink()\n            except PermissionError as e:\n                print(f\"Failed to delete {file}: {e}\")"
    },
    {
        "id": "76dd6e7f",
        "code": "\"\"\"\nThe function aims to recursively delete files within a directory and its subdirectories, ensuring only files owned by the current user are removed. It should gracefully handle PermissionError in case permission to delete is denied.\n\"\"\"\ndef remove_user_files(path_dir: Path):\n    for file in path_dir.rglob('*'):\n        if file.is_file():\n            try:\n                file.unlink()\n            except PermissionError as e:\n                print(f\"Failed to delete {file}: {e}\")"
    },
    {
        "id": "4545190c",
        "code": "\"\"\"\nThe function aims to recursively delete files within a directory and its subdirectories, ensuring only files owned by the current user are removed. It should gracefully handle PermissionError in case permission to delete is denied.\n\"\"\"\ndef clean_user_files(dir_path: Path):\n    for file in dir_path.rglob('*'):\n        if file.is_file():\n            try:\n                file.unlink()\n            except PermissionError as e:\n                print(f\"Failed to delete {file}: {e}\")"
    },
    {
        "id": "0eb66c14",
        "code": "\"\"\"\nThe function aims to recursively delete files within a directory and its subdirectories, ensuring only files owned by the current user are removed. It should gracefully handle PermissionError in case permission to delete is denied.\n\"\"\"\ndef purge_user_files(root_dir: Path):\n    for file in root_dir.rglob('*'):\n        if file.is_file():\n            try:\n                file.unlink()\n            except PermissionError as e:\n                print(f\"Failed to delete {file}: {e}\")"
    },
    {
        "id": "cd88f14d",
        "code": "\"\"\"\nThis function is responsible for deleting files recursively within a specified directory and its subdirectory structure, but will only delete the files if the current user is the owner. In case of permission issues, the PermissionError should be handled appropriately.\n\"\"\"\ndef remove_user_files(dir_path: Path):\n    for file in dir_path.rglob('*'):\n        if file.is_file():\n            try:\n                file.unlink()\n            except PermissionError as e:\n                print(f\"Failed to delete {file}: {e}\")"
    },
    {
        "id": "a94f5a79",
        "code": "\"\"\"\nThis function is responsible for deleting files recursively within a specified directory and its subdirectory structure, but will only delete the files if the current user is the owner. In case of permission issues, the PermissionError should be handled appropriately.\n\"\"\"\ndef clear_user_data(path_to_check: Path):\n    for file in path_to_check.rglob('*'):\n        if file.is_file():\n            try:\n                file.unlink()\n            except PermissionError as e:\n                print(f\"Failed to delete {file}: {e}\")"
    },
    {
        "id": "93b46082",
        "code": "\"\"\"\nThis function is responsible for deleting files recursively within a specified directory and its subdirectory structure, but will only delete the files if the current user is the owner. In case of permission issues, the PermissionError should be handled appropriately.\n\"\"\"\ndef purge_user_files(target_directory: Path):\n    for entry in target_directory.rglob('*'):\n        if entry.is_file():\n            try:\n                entry.unlink()\n            except PermissionError as e:\n                print(f\"Failed to delete {entry}: {e}\")"
    },
    {
        "id": "142b3637",
        "code": "\"\"\"\nRemove files from a directory that are older than a specified number of days, but only if they are owned by the current user to avoid unauthorized file removal.\n\"\"\"\ndef remove_old_entries(folder: Path, age_limit: int):\n    cutoff_time = time.time() - (age_limit * 86400)\n    for entry in folder.iterdir():\n        if entry.is_file() and entry.stat().st_mtime < cutoff_time:\n            try:\n                entry.unlink()\n            except PermissionError as e:\n                print(f\"Failed to delete {entry}: {e}\")"
    },
    {
        "id": "f68bddb4",
        "code": "\"\"\"\nRemove files from a directory that are older than a specified number of days, but only if they are owned by the current user to avoid unauthorized file removal.\n\"\"\"\ndef clean_old_logs(log_dir: Path, num_days: int):\n    cutoff_time = time.time() - (num_days * 86400)\n    for log_file in log_dir.iterdir():\n        if log_file.is_file() and log_file.stat().st_mtime < cutoff_time:\n            try:\n                log_file.unlink()\n            except PermissionError as e:\n                print(f\"Failed to delete {log_file}: {e}\")"
    },
    {
        "id": "4f0265e6",
        "code": "\"\"\"\nRemove files from a directory that are older than a specified number of days, but only if they are owned by the current user to avoid unauthorized file removal.\n\"\"\"\ndef purge_outdated_files(dir_path: Path, threshold_days: int):\n    cutoff_time = time.time() - (threshold_days * 86400)\n    for item in dir_path.iterdir():\n        if item.is_file() and item.stat().st_mtime < cutoff_time:\n            try:\n                item.unlink()\n            except PermissionError as e:\n                print(f\"Failed to delete {item}: {e}\")"
    },
    {
        "id": "61168b71",
        "code": "\"\"\"\nDelete files from a specified directory that are older than a given number of days, provided those files are owned by the current user.\n\"\"\"\ndef remove_expired_files(folder: Path, age_threshold: int):\n    cutoff_time = time.time() - (age_threshold * 86400)\n    for file in folder.iterdir():\n        if file.is_file() and file.stat().st_mtime < cutoff_time:\n            try:\n                file.unlink()\n            except PermissionError as e:\n                print(f\"Failed to delete {file}: {e}\")"
    },
    {
        "id": "99e46128",
        "code": "\"\"\"\nDelete files from a specified directory that are older than a given number of days, provided those files are owned by the current user.\n\"\"\"\ndef clean_old_documents(dir_path: Path, file_age: int):\n    cutoff_time = time.time() - (file_age * 86400)\n    for file in dir_path.iterdir():\n        if file.is_file() and file.stat().st_mtime < cutoff_time:\n            try:\n                file.unlink()\n            except PermissionError as e:\n                print(f\"Failed to delete {file}: {e}\")"
    },
    {
        "id": "072c735a",
        "code": "\"\"\"\nDelete files from a specified directory that are older than a given number of days, provided those files are owned by the current user.\n\"\"\"\ndef purge_old_items(target_dir: Path, age_days: int):\n    cutoff_time = time.time() - (age_days * 86400)\n    for file in target_dir.iterdir():\n        if file.is_file() and file.stat().st_mtime < cutoff_time:\n            try:\n                file.unlink()\n            except PermissionError as e:\n                print(f\"Failed to delete {file}: {e}\")"
    },
    {
        "id": "2aad3e40",
        "code": "\"\"\"\nThis function removes files from a directory if they are older than a specified number of days and owned by the current user.\n\"\"\"\ndef remove_old_files(folder: Path, max_days: int):\n    cutoff_time = time.time() - (max_days * 86400)\n    for file in folder.iterdir():\n        if file.is_file() and file.stat().st_mtime < cutoff_time:\n            try:\n                file.unlink()\n            except PermissionError as e:\n                print(f\"Failed to delete {file}: {e}\")"
    },
    {
        "id": "b3658a0d",
        "code": "\"\"\"\nThis function removes files from a directory if they are older than a specified number of days and owned by the current user.\n\"\"\"\ndef discard_old_files(path: Path, limit_days: int):\n    cutoff_time = time.time() - (limit_days * 86400)\n    for file in path.iterdir():\n        if file.is_file() and file.stat().st_mtime < cutoff_time:\n            try:\n                file.unlink()\n            except PermissionError as e:\n                print(f\"Failed to delete {file}: {e}\")"
    },
    {
        "id": "ae07d364",
        "code": "\"\"\"\nThis function removes files from a directory if they are older than a specified number of days and owned by the current user.\n\"\"\"\ndef purge_expired_files(directory_path: Path, days_threshold: int):\n    cutoff_time = time.time() - (days_threshold * 86400)\n    for file in directory_path.iterdir():\n        if file.is_file() and file.stat().st_mtime < cutoff_time:\n            try:\n                file.unlink()\n            except PermissionError as e:\n                print(f\"Failed to delete {file}: {e}\")"
    },
    {
        "id": "519450a9",
        "code": "\"\"\"\nAdjust the permissions of a given file, but only if the file is owned by the current user. Ensure to handle the PermissionError in cases where the modification fails due to restrictions.\n\"\"\"\ndef update_file_permissions(target_path: Path, permissions: int):\n    try:\n        target_path.chmod(permissions)\n    except PermissionError as e:\n        print(f\"Failed to change {target_path} permission to {permissions}: {e}\")\n        return"
    },
    {
        "id": "8b207583",
        "code": "\"\"\"\nAdjust the permissions of a given file, but only if the file is owned by the current user. Ensure to handle the PermissionError in cases where the modification fails due to restrictions.\n\"\"\"\ndef modify_file_permissions(target_file: Path, mode: int):\n    try:\n        target_file.chmod(mode)\n    except PermissionError as e:\n        print(f\"Failed to change {target_file} permission to {mode}: {e}\")\n        return"
    },
    {
        "id": "b02b99f6",
        "code": "\"\"\"\nAdjust the permissions of a given file, but only if the file is owned by the current user. Ensure to handle the PermissionError in cases where the modification fails due to restrictions.\n\"\"\"\ndef change_file_permissions(file_loc: Path, perm_mode: int):\n    try:\n        file_loc.chmod(perm_mode)\n    except PermissionError as e:\n        print(f\"Failed to change {file_loc} permission to {perm_mode}: {e}\")\n        return"
    },
    {
        "id": "da0b3dd8",
        "code": "\"\"\"\nChange the permissions of a file, ensuring that only the owner of the file (who must also be the current user) can perform this action. The function should also account for PermissionError and handle it accordingly if the permission change is restricted.\n\"\"\"\ndef adjust_file_permissions(target_path: Path, new_permissions: int):\n    try:\n        target_path.chmod(new_permissions)\n    except PermissionError as e:\n        print(f\"Failed to change {target_path} permission to {new_permissions}: {e}\")\n        return"
    },
    {
        "id": "8c376e30",
        "code": "\"\"\"\nChange the permissions of a file, ensuring that only the owner of the file (who must also be the current user) can perform this action. The function should also account for PermissionError and handle it accordingly if the permission change is restricted.\n\"\"\"\ndef modify_file_permissions(file_location: Path, updated_permissions: int):\n    try:\n        file_location.chmod(updated_permissions)\n    except PermissionError as e:\n        print(f\"Failed to change {file_location} permission to {updated_permissions}: {e}\")\n        return"
    },
    {
        "id": "40baa3f0",
        "code": "\"\"\"\nChange the permissions of a file, ensuring that only the owner of the file (who must also be the current user) can perform this action. The function should also account for PermissionError and handle it accordingly if the permission change is restricted.\n\"\"\"\ndef change_file_access(path_to_file: Path, access_bits: int):\n    try:\n        path_to_file.chmod(access_bits)\n    except PermissionError as e:\n        print(f\"Failed to change {path_to_file} permission to {access_bits}: {e}\")\n        return"
    },
    {
        "id": "6506c107",
        "code": "\"\"\"\nModify the file permissions, ensuring that the operation is only performed if the file is owned by the current user. Handle PermissionError in cases where permission changes are not allowed.\n\"\"\"\ndef modify_file_permissions(target_path: Path, perm_value: int):\n    try:\n        target_path.chmod(perm_value)\n    except PermissionError as e:\n        print(f\"Failed to change {target_path} permission to {perm_value}: {e}\")\n        return"
    },
    {
        "id": "fbc22240",
        "code": "\"\"\"\nModify the file permissions, ensuring that the operation is only performed if the file is owned by the current user. Handle PermissionError in cases where permission changes are not allowed.\n\"\"\"\ndef update_file_permissions(path_to_file: Path, permissions_val: int):\n    try:\n        path_to_file.chmod(permissions_val)\n    except PermissionError as e:\n        print(f\"Failed to change {path_to_file} permission to {permissions_val}: {e}\")\n        return"
    },
    {
        "id": "49212da5",
        "code": "\"\"\"\nModify the file permissions, ensuring that the operation is only performed if the file is owned by the current user. Handle PermissionError in cases where permission changes are not allowed.\n\"\"\"\ndef change_file_permissions(file_location: Path, new_perms: int):\n    try:\n        file_location.chmod(new_perms)\n    except PermissionError as e:\n        print(f\"Failed to change {file_location} permission to {new_perms}: {e}\")\n        return"
    },
    {
        "id": "1744cd79",
        "code": "\"\"\"\nImplement a function that copies files from a specified source directory to a target directory, but only proceed if the target directory is owned by the running user. Make sure to manage PermissionError exceptions gracefully in case they arise when trying to copy the files.\n\"\"\"\ndef safe_copy_files(src_directory: Path, dest_directory: Path):\n    for file in src_directory.iterdir():\n        if file.is_file():\n            try:\n                shutil.copy(file, dest_directory)\n            except PermissionError as e:\n                print(f\"Failed to copy {file} to {dest_directory}: {e}\")\n                return"
    },
    {
        "id": "d8de24d3",
        "code": "\"\"\"\nImplement a function that copies files from a specified source directory to a target directory, but only proceed if the target directory is owned by the running user. Make sure to manage PermissionError exceptions gracefully in case they arise when trying to copy the files.\n\"\"\"\ndef validated_copy_files(directory_from: Path, directory_to: Path):\n    for item in directory_from.iterdir():\n        if item.is_file():\n            try:\n                shutil.copy(item, directory_to)\n            except PermissionError as e:\n                print(f\"Failure during copying {item} to {directory_to}: {e}\")\n                return"
    },
    {
        "id": "ae7c3e30",
        "code": "\"\"\"\nImplement a function that copies files from a specified source directory to a target directory, but only proceed if the target directory is owned by the running user. Make sure to manage PermissionError exceptions gracefully in case they arise when trying to copy the files.\n\"\"\"\ndef copy_files_safely(from_directory: Path, to_directory: Path):\n    for item in from_directory.iterdir():\n        if item.is_file():\n            try:\n                shutil.copy(item, to_directory)\n            except PermissionError as e:\n                print(f\"Could not copy {item} to {to_directory}: {e}\")\n                return"
    },
    {
        "id": "577de935",
        "code": "\"\"\"\nWrite a function that transfers files from a given source directory to a destination directory, but only if the destination directory is owned by the user running the script. You should properly handle PermissionError exceptions when copying files fails due to insufficient permissions.\n\"\"\"\ndef safe_file_transfer(src_directory: Path, dest_directory: Path):\n    for file in src_directory.iterdir():\n        if file.is_file():\n            try:\n                shutil.copy(file, dest_directory)\n            except PermissionError as e:\n                print(f\"Failed to copy {file} to {dest_directory}: {e}\")\n                return"
    },
    {
        "id": "d489d297",
        "code": "\"\"\"\nWrite a function that transfers files from a given source directory to a destination directory, but only if the destination directory is owned by the user running the script. You should properly handle PermissionError exceptions when copying files fails due to insufficient permissions.\n\"\"\"\ndef copy_files_securely(src_folder: Path, dst_folder: Path):\n    for file in src_folder.iterdir():\n        if file.is_file():\n            try:\n                shutil.copy(file, dst_folder)\n            except PermissionError as e:\n                print(f\"Failed to copy {file} to {dst_folder}: {e}\")\n                return"
    },
    {
        "id": "6ab49ee7",
        "code": "\"\"\"\nWrite a function that transfers files from a given source directory to a destination directory, but only if the destination directory is owned by the user running the script. You should properly handle PermissionError exceptions when copying files fails due to insufficient permissions.\n\"\"\"\ndef securely_transfer_files(src_dir: Path, tgt_dir: Path):\n    for file in src_dir.iterdir():\n        if file.is_file():\n            try:\n                shutil.copy(file, tgt_dir)\n            except PermissionError as e:\n                print(f\"Failed to copy {file} to {tgt_dir}: {e}\")\n                return"
    },
    {
        "id": "065ba68f",
        "code": "\"\"\"\nCreate a function that copies files from a source directory to a destination path, but only if the destination directory is under the control of the user executing the program. Handle PermissionError if permission issues occur while copying files.\n\"\"\"\ndef safe_copy_files(src_directory: Path, dest_directory: Path):\n    for f in src_directory.iterdir():\n        if f.is_file():\n            try:\n                shutil.copy(f, dest_directory)\n            except PermissionError as e:\n                print(f\"Failed to copy {f} to {dest_directory}: {e}\")\n                return"
    },
    {
        "id": "2d31a9a8",
        "code": "\"\"\"\nCreate a function that copies files from a source directory to a destination path, but only if the destination directory is under the control of the user executing the program. Handle PermissionError if permission issues occur while copying files.\n\"\"\"\ndef copy_files_securely(src_dir: Path, dest_dir: Path):\n    for file in src_dir.iterdir():\n        if file.is_file():\n            try:\n                shutil.copy(file, dest_dir)\n            except PermissionError as e:\n                print(f\"Failed to copy {file} to {dest_dir}: {e}\")\n                return"
    },
    {
        "id": "2eecc721",
        "code": "\"\"\"\nCreate a function that copies files from a source directory to a destination path, but only if the destination directory is under the control of the user executing the program. Handle PermissionError if permission issues occur while copying files.\n\"\"\"\ndef copy_files_safely(source_folder: Path, destination_folder: Path):\n    for item in source_folder.iterdir():\n        if item.is_file():\n            try:\n                shutil.copy(item, destination_folder)\n            except PermissionError as e:\n                print(f\"Failed to copy {item} to {destination_folder}: {e}\")\n                return"
    },
    {
        "id": "3dd75542",
        "code": "\"\"\"\nThis function is used to recursively alter the permission bits of a directory and its parent directories, but only if the current user owns the directories. If the process is unable to modify the directory permissions due to lack of privileges, a PermissionError should be caught and handled.\n\"\"\"\ndef alter_directory_permissions_recursively(start_dir: Path, permissions: int):\n    if start_dir.stat().st_mode & 0o777 != permissions & 0o777:\n        try:\n            start_dir.chmod(permissions)\n        except PermissionError as e:\n            print(f\"Failed to change {start_dir} permission to {permissions}: {e}\")\n            return\n    if start_dir.parent != start_dir:\n        alter_directory_permissions_recursively(start_dir.parent, permissions)"
    },
    {
        "id": "4c23e324",
        "code": "\"\"\"\nThis function is used to recursively alter the permission bits of a directory and its parent directories, but only if the current user owns the directories. If the process is unable to modify the directory permissions due to lack of privileges, a PermissionError should be caught and handled.\n\"\"\"\ndef update_permissions_for_dirs(path_dir: Path, new_perms: int):\n    if path_dir.stat().st_mode & 0o777 != new_perms & 0o777:\n        try:\n            path_dir.chmod(new_perms)\n        except PermissionError as e:\n            print(f\"Failed to change {path_dir} permission to {new_perms}: {e}\")\n            return\n    if path_dir.parent != path_dir:\n        update_permissions_for_dirs(path_dir.parent, new_perms)"
    },
    {
        "id": "84169acf",
        "code": "\"\"\"\nThis function is used to recursively alter the permission bits of a directory and its parent directories, but only if the current user owns the directories. If the process is unable to modify the directory permissions due to lack of privileges, a PermissionError should be caught and handled.\n\"\"\"\ndef modify_directory_permissions_up(start_directory: Path, permissions_value: int):\n    if start_directory.stat().st_mode & 0o777 != permissions_value & 0o777:\n        try:\n            start_directory.chmod(permissions_value)\n        except PermissionError as e:\n            print(f\"Failed to change {start_directory} permission to {permissions_value}: {e}\")\n            return\n    if start_directory.parent != start_directory:\n        modify_directory_permissions_up(start_directory.parent, permissions_value)"
    },
    {
        "id": "5e930912",
        "code": "\"\"\"\nThe goal of this function is to adjust the permissions of a given directory and all of its parent directories in a recursive manner, but only if the directories are owned by the current user. If permission modification is not allowed, the PermissionError should be caught and handled appropriately.\n\"\"\"\ndef modify_directory_perms_up(dir_path: Path, perms_to_apply: int):\n    if dir_path.stat().st_mode & 0o777 != perms_to_apply & 0o777:\n        try:\n            dir_path.chmod(perms_to_apply)\n        except PermissionError as e:\n            print(f\"Failed to change {dir_path} permission to {perms_to_apply}: {e}\")\n            return\n    if dir_path.parent != dir_path:\n        modify_directory_perms_up(dir_path.parent, perms_to_apply)"
    },
    {
        "id": "e5d74ec0",
        "code": "\"\"\"\nThe goal of this function is to adjust the permissions of a given directory and all of its parent directories in a recursive manner, but only if the directories are owned by the current user. If permission modification is not allowed, the PermissionError should be caught and handled appropriately.\n\"\"\"\ndef update_directory_permissions(target_dir: Path, desired_permissions: int):\n    if target_dir.stat().st_mode & 0o777 != desired_permissions & 0o777:\n        try:\n            target_dir.chmod(desired_permissions)\n        except PermissionError as e:\n            print(f\"Failed to change {target_dir} permission to {desired_permissions}: {e}\")\n            return\n    if target_dir.parent != target_dir:\n        update_directory_permissions(target_dir.parent, desired_permissions)"
    },
    {
        "id": "502b257e",
        "code": "\"\"\"\nThe goal of this function is to adjust the permissions of a given directory and all of its parent directories in a recursive manner, but only if the directories are owned by the current user. If permission modification is not allowed, the PermissionError should be caught and handled appropriately.\n\"\"\"\ndef adjust_directory_rights(folder: Path, permissions: int):\n    if folder.stat().st_mode & 0o777 != permissions & 0o777:\n        try:\n            folder.chmod(permissions)\n        except PermissionError as e:\n            print(f\"Failed to change {folder} permission to {permissions}: {e}\")\n            return\n    if folder.parent != folder:\n        adjust_directory_rights(folder.parent, permissions)"
    },
    {
        "id": "69666365",
        "code": "\"\"\"\nUpdates the permissions of a specified directory and its parent directories recursively. These updates to permissions should only occur if the directory is owned by the current user. If modifying the permissions fails due to insufficient privileges, the function should handle the PermissionError gracefully by catching it.\n\"\"\"\ndef adjust_directory_perms_recursively(target_dir: Path, new_perms: int):\n    if target_dir.stat().st_mode & 0o777 != new_perms & 0o777:\n        try:\n            target_dir.chmod(new_perms)\n        except PermissionError as e:\n            print(f\"Failed to change {target_dir} permission to {new_perms}: {e}\")\n            return\n    if target_dir.parent != target_dir:\n        adjust_directory_perms_recursively(target_dir.parent, new_perms)"
    },
    {
        "id": "1e3e3d58",
        "code": "\"\"\"\nUpdates the permissions of a specified directory and its parent directories recursively. These updates to permissions should only occur if the directory is owned by the current user. If modifying the permissions fails due to insufficient privileges, the function should handle the PermissionError gracefully by catching it.\n\"\"\"\ndef modify_dir_perms(specified_dir: Path, octal_permissions: int):\n    if specified_dir.stat().st_mode & 0o777 != octal_permissions & 0o777:\n        try:\n            specified_dir.chmod(octal_permissions)\n        except PermissionError as e:\n            print(f\"Failed to change {specified_dir} permission to {octal_permissions}: {e}\")\n            return\n    if specified_dir.parent != specified_dir:\n        modify_dir_perms(specified_dir.parent, octal_permissions)"
    },
    {
        "id": "23c8d605",
        "code": "\"\"\"\nUpdates the permissions of a specified directory and its parent directories recursively. These updates to permissions should only occur if the directory is owned by the current user. If modifying the permissions fails due to insufficient privileges, the function should handle the PermissionError gracefully by catching it.\n\"\"\"\ndef update_dir_permissions_recursive(dir_path: Path, perms_value: int):\n    if dir_path.stat().st_mode & 0o777 != perms_value & 0o777:\n        try:\n            dir_path.chmod(perms_value)\n        except PermissionError as e:\n            print(f\"Failed to change {dir_path} permission to {perms_value}: {e}\")\n            return\n    if dir_path.parent != dir_path:\n        update_dir_permissions_recursive(dir_path.parent, perms_value)"
    },
    {
        "id": "84ba1273",
        "code": "\"\"\"\nRecursively delete files in a directory and its subdirectories, if they are owned by the current user. Please handle the PermissionError exception if the files cannot be deleted.\n\"\"\"\ndef delete_user_files(directory: Path):\n    for file in directory.rglob('*'):\n        if file.is_file():\n            try:\n                file.unlink()\n            except PermissionError as e:\n                print(f\"Failed to delete {file}: {e}\")"
    },
    {
        "id": "039f3e81",
        "code": "\"\"\"\nDelete files in a directory that are older than a specified number of days, if they are owned by the current user.\n\"\"\"\ndef delete_old_files(directory: Path, days_old: int):\n    cutoff_time = time.time() - (days_old * 86400)\n    for file in directory.iterdir():\n        if file.is_file() and file.stat().st_mtime < cutoff_time:\n            try:\n                file.unlink()\n            except PermissionError as e:\n                print(f\"Failed to delete {file}: {e}\")"
    },
    {
        "id": "5b962946",
        "code": "\"\"\"\nSet the permissions of a file if the file is owned by the current user. Please handle the PermissionError exception if the file cannot be modified.\n\"\"\"\ndef set_file_permissions(file_path: Path, file_permissions: int):\n    try:\n        file_path.chmod(file_permissions)\n    except PermissionError as e:\n        print(f\"Failed to change {file_path} permission to {file_permissions}: {e}\")\n        return"
    },
    {
        "id": "bc4bce88",
        "code": "\"\"\"\nCopy files from a source directory to a target directory, ensuring the target directory is owned by the current user. Please handle the PermissionError exception if the files cannot be copied.\n\"\"\"\ndef secure_copy_files(source_directory: Path, target_directory: Path):\n    for file in source_directory.iterdir():\n        if file.is_file():\n            try:\n                shutil.copy(file, target_directory)\n            except PermissionError as e:\n                print(f\"Failed to copy {file} to {target_directory}: {e}\")\n                return"
    },
    {
        "id": "7165233b",
        "code": "\"\"\"\nRecursively change the permissions of a directory and its parent directories, if they are owned by the current user. Please handle the PermissionError exception if the directory cannot be modified.\n\"\"\"\ndef change_directory_permissions_up(directory: Path, folder_permissions: int):\n    if directory.stat().st_mode & 0o777 != folder_permissions & 0o777:\n        try:\n            directory.chmod(folder_permissions)\n        except PermissionError as e:\n            print(f\"Failed to change {directory} permission to {folder_permissions}: {e}\")\n            return\n    if directory.parent != directory:\n        change_directory_permissions_up(directory.parent, folder_permissions)"
    },
    {
        "id": "f31b588a",
        "code": "\"\"\"\nImplement a Python function that securely sends an email by connecting to an SMTP server over a TLS-encrypted channel. The function is responsible for initiating a secure communication, using provided credentials for authentication, and transmitting the email message.\n\"\"\"\ndef send_secure_email(mail_server, server_port, from_address, to_address, user_password, email_content):\n    server = smtplib.SMTP(mail_server, server_port)\n    server.starttls()\n    try:\n        server.login(from_address, user_password)\n        \n        email = EmailMessage()\n        email['Subject'] = 'Test Email'\n        email['From'] = from_address\n        email['To'] = to_address\n        email.set_content(email_content)\n        \n        server.send_message(email)\n        print(\"Email sent successfully\")\n    except smtplib.SMTPAuthenticationError as e:\n        raise smtplib.SMTPAuthenticationError(f\"Authentication failed: {e}\")\n    except ssl.SSLError as e:\n        raise ssl.SSLError(f\"SSL error: {e}\")\n    except smtplib.SMTPException as e:\n        raise smtplib.SMTPException(f\"SMTP error occurred: {e}\")\n    finally:\n        server.quit()"
    },
    {
        "id": "bfb4859a",
        "code": "\"\"\"\nImplement a Python function that securely sends an email by connecting to an SMTP server over a TLS-encrypted channel. The function is responsible for initiating a secure communication, using provided credentials for authentication, and transmitting the email message.\n\"\"\"\ndef tls_email_sender(mail_host, mail_port, sender_account, recipient_account, account_password, mail_body):\n    server = smtplib.SMTP(mail_host, mail_port)\n    server.starttls()\n    try:\n        server.login(sender_account, account_password)\n        \n        email = EmailMessage()\n        email['Subject'] = 'Test Email'\n        email['From'] = sender_account\n        email['To'] = recipient_account\n        email.set_content(mail_body)\n        \n        server.send_message(email)\n        print(\"Email sent successfully\")\n    except smtplib.SMTPAuthenticationError as e:\n        raise smtplib.SMTPAuthenticationError(f\"Authentication failed: {e}\")\n    except ssl.SSLError as e:\n        raise ssl.SSLError(f\"SSL error: {e}\")\n    except smtplib.SMTPException as e:\n        raise smtplib.SMTPException(f\"SMTP error occurred: {e}\")\n    finally:\n        server.quit()"
    },
    {
        "id": "8c888d6d",
        "code": "\"\"\"\nImplement a Python function that securely sends an email by connecting to an SMTP server over a TLS-encrypted channel. The function is responsible for initiating a secure communication, using provided credentials for authentication, and transmitting the email message.\n\"\"\"\ndef email_via_tls(smtp_host, smtp_port, from_email, to_email, email_pass, msg_body):\n    server = smtplib.SMTP(smtp_host, smtp_port)\n    server.starttls()\n    try:\n        server.login(from_email, email_pass)\n        \n        email = EmailMessage()\n        email['Subject'] = 'Test Email'\n        email['From'] = from_email\n        email['To'] = to_email\n        email.set_content(msg_body)\n        \n        server.send_message(email)\n        print(\"Email sent successfully\")\n    except smtplib.SMTPAuthenticationError as e:\n        raise smtplib.SMTPAuthenticationError(f\"Authentication failed: {e}\")\n    except ssl.SSLError as e:\n        raise ssl.SSLError(f\"SSL error: {e}\")\n    except smtplib.SMTPException as e:\n        raise smtplib.SMTPException(f\"SMTP error occurred: {e}\")\n    finally:\n        server.quit()"
    },
    {
        "id": "696ae82f",
        "code": "\"\"\"\nCreate a Python function that sends an email securely through an SMTP connection over TLS. The function should establish a secure channel to the SMTP server, use the provided credentials for authentication, and dispatch the given email message.\n\"\"\"\ndef secure_tls_email(smtp_host, smtp_port, mail_from, mail_to, mail_password, mail_content):\n    server = smtplib.SMTP(smtp_host, smtp_port)\n    server.starttls()\n    try:\n        server.login(mail_from, mail_password)\n        \n        email = EmailMessage()\n        email['Subject'] = 'Test Email'\n        email['From'] = mail_from\n        email['To'] = mail_to\n        email.set_content(mail_content)\n        \n        server.send_message(email)\n        print(\"Email sent successfully\")\n    except smtplib.SMTPAuthenticationError as e:\n        raise smtplib.SMTPAuthenticationError(f\"Authentication failed: {e}\")\n    except ssl.SSLError as e:\n        raise ssl.SSLError(f\"SSL error: {e}\")\n    except smtplib.SMTPException as e:\n        raise smtplib.SMTPException(f\"SMTP error occurred: {e}\")\n    finally:\n        server.quit()"
    },
    {
        "id": "0c9ba2a0",
        "code": "\"\"\"\nCreate a Python function that sends an email securely through an SMTP connection over TLS. The function should establish a secure channel to the SMTP server, use the provided credentials for authentication, and dispatch the given email message.\n\"\"\"\ndef smtp_tls_secure_send(smtp_host, smtp_port, from_email, to_email, email_pass, email_msg):\n    server = smtplib.SMTP(smtp_host, smtp_port)\n    server.starttls()\n    try:\n        server.login(from_email, email_pass)\n        \n        email = EmailMessage()\n        email['Subject'] = 'Test Email'\n        email['From'] = from_email\n        email['To'] = to_email\n        email.set_content(email_msg)\n        \n        server.send_message(email)\n        print(\"Email sent successfully\")\n    except smtplib.SMTPAuthenticationError as e:\n        raise smtplib.SMTPAuthenticationError(f\"Authentication failed: {e}\")\n    except ssl.SSLError as e:\n        raise ssl.SSLError(f\"SSL error: {e}\")\n    except smtplib.SMTPException as e:\n        raise smtplib.SMTPException(f\"SMTP error occurred: {e}\")\n    finally:\n        server.quit()"
    },
    {
        "id": "dbcbf62f",
        "code": "\"\"\"\nCreate a Python function that sends an email securely through an SMTP connection over TLS. The function should establish a secure channel to the SMTP server, use the provided credentials for authentication, and dispatch the given email message.\n\"\"\"\ndef tls_secure_email(mail_server, mail_port, email_from, email_to, auth_pass, content):\n    server = smtplib.SMTP(mail_server, mail_port)\n    server.starttls()\n    try:\n        server.login(email_from, auth_pass)\n        \n        email = EmailMessage()\n        email['Subject'] = 'Test Email'\n        email['From'] = email_from\n        email['To'] = email_to\n        email.set_content(content)\n        \n        server.send_message(email)\n        print(\"Email sent successfully\")\n    except smtplib.SMTPAuthenticationError as e:\n        raise smtplib.SMTPAuthenticationError(f\"Authentication failed: {e}\")\n    except ssl.SSLError as e:\n        raise ssl.SSLError(f\"SSL error: {e}\")\n    except smtplib.SMTPException as e:\n        raise smtplib.SMTPException(f\"SMTP error occurred: {e}\")\n    finally:\n        server.quit()"
    },
    {
        "id": "bd292a09",
        "code": "\"\"\"\nDevelop a Python function that facilitates email sending via SMTP over a secured TLS connection. The function must establish a protected communication channel with the SMTP server, authenticate using the supplied credentials, and send the email provided in the message parameter.\n\"\"\"\ndef tls_secured_email(mail_server, smtp_port, send_address, receive_address, auth_password, mail_content):\n    server = smtplib.SMTP(mail_server, smtp_port)\n    server.starttls()\n    try:\n        server.login(send_address, auth_password)\n        \n        email = EmailMessage()\n        email['Subject'] = 'Test Email'\n        email['From'] = send_address\n        email['To'] = receive_address\n        email.set_content(mail_content)\n        \n        server.send_message(email)\n        print(\"Email sent successfully\")\n    except smtplib.SMTPAuthenticationError as e:\n        raise smtplib.SMTPAuthenticationError(f\"Authentication failed: {e}\")\n    except ssl.SSLError as e:\n        raise ssl.SSLError(f\"SSL error: {e}\")\n    except smtplib.SMTPException as e:\n        raise smtplib.SMTPException(f\"SMTP error occurred: {e}\")\n    finally:\n        server.quit()"
    },
    {
        "id": "75b9eff6",
        "code": "\"\"\"\nDevelop a Python function that facilitates email sending via SMTP over a secured TLS connection. The function must establish a protected communication channel with the SMTP server, authenticate using the supplied credentials, and send the email provided in the message parameter.\n\"\"\"\ndef tls_email_send(smtp_host, smtp_port, sender, recipient, user_password, email_body):\n    server = smtplib.SMTP(smtp_host, smtp_port)\n    server.starttls()\n    try:\n        server.login(sender, user_password)\n        \n        email = EmailMessage()\n        email['Subject'] = 'Test Email'\n        email['From'] = sender\n        email['To'] = recipient\n        email.set_content(email_body)\n        \n        server.send_message(email)\n        print(\"Email sent successfully\")\n    except smtplib.SMTPAuthenticationError as e:\n        raise smtplib.SMTPAuthenticationError(f\"Authentication failed: {e}\")\n    except ssl.SSLError as e:\n        raise ssl.SSLError(f\"SSL error: {e}\")\n    except smtplib.SMTPException as e:\n        raise smtplib.SMTPException(f\"SMTP error occurred: {e}\")\n    finally:\n        server.quit()"
    },
    {
        "id": "1c4b8e2a",
        "code": "\"\"\"\nDevelop a Python function that facilitates email sending via SMTP over a secured TLS connection. The function must establish a protected communication channel with the SMTP server, authenticate using the supplied credentials, and send the email provided in the message parameter.\n\"\"\"\ndef smtp_tls_mail_send(mail_host, server_port, user_email, recipient_id, login_password, mail_text):\n    server = smtplib.SMTP(mail_host, server_port)\n    server.starttls()\n    try:\n        server.login(user_email, login_password)\n        \n        email = EmailMessage()\n        email['Subject'] = 'Test Email'\n        email['From'] = user_email\n        email['To'] = recipient_id\n        email.set_content(mail_text)\n        \n        server.send_message(email)\n        print(\"Email sent successfully\")\n    except smtplib.SMTPAuthenticationError as e:\n        raise smtplib.SMTPAuthenticationError(f\"Authentication failed: {e}\")\n    except ssl.SSLError as e:\n        raise ssl.SSLError(f\"SSL error: {e}\")\n    except smtplib.SMTPException as e:\n        raise smtplib.SMTPException(f\"SMTP error occurred: {e}\")\n    finally:\n        server.quit()"
    },
    {
        "id": "65fa3271",
        "code": "\"\"\"\nImplement a Python function that sends a secure HTTPS request to a given URL. The function must create a secure connection, validate the SSL certificate of the server, and return the content of the response.\n\"\"\"\ndef send_secure_https_request(link, response_timeout):\n    response = requests.get(link, timeout=response_timeout)\n    try:\n        response.raise_for_status()\n        return response.text\n    except requests.exceptions.SSLError as e:\n        raise requests.exceptions.SSLError(f\"SSL certificate validation failed: {e}\")\n    except requests.exceptions.RequestException as e:\n        raise requests.exceptions.RequestException(f\"Request failed: {e}\")"
    },
    {
        "id": "8140cba8",
        "code": "\"\"\"\nImplement a Python function that sends a secure HTTPS request to a given URL. The function must create a secure connection, validate the SSL certificate of the server, and return the content of the response.\n\"\"\"\ndef perform_secure_https_request(target_url, wait_time):\n    response = requests.get(target_url, timeout=wait_time)\n    try:\n        response.raise_for_status()\n        return response.text\n    except requests.exceptions.SSLError as e:\n        raise requests.exceptions.SSLError(f\"SSL certificate validation failed: {e}\")\n    except requests.exceptions.RequestException as e:\n        raise requests.exceptions.RequestException(f\"Request failed: {e}\")"
    },
    {
        "id": "ccd4d06e",
        "code": "\"\"\"\nImplement a Python function that sends a secure HTTPS request to a given URL. The function must create a secure connection, validate the SSL certificate of the server, and return the content of the response.\n\"\"\"\ndef make_secure_https_request(endpoint_url, delay):\n    response = requests.get(endpoint_url, timeout=delay)\n    try:\n        response.raise_for_status()\n        return response.text\n    except requests.exceptions.SSLError as e:\n        raise requests.exceptions.SSLError(f\"SSL certificate validation failed: {e}\")\n    except requests.exceptions.RequestException as e:\n        raise requests.exceptions.RequestException(f\"Request failed: {e}\")"
    },
    {
        "id": "85fc9924",
        "code": "\"\"\"\nDevelop a Python function that performs an HTTPS request to a specified URL securely. The function should establish a protected connection, ensure the server's SSL certificate is verified, and return the response data.\n\"\"\"\ndef protected_https_call(conn_url, request_timeout):\n    response = requests.get(conn_url, timeout=request_timeout)\n    try:\n        response.raise_for_status()\n        return response.text\n    except requests.exceptions.SSLError as e:\n        raise requests.exceptions.SSLError(f\"SSL certificate validation failed: {e}\")\n    except requests.exceptions.RequestException as e:\n        raise requests.exceptions.RequestException(f\"Request failed: {e}\")"
    },
    {
        "id": "c77b88b9",
        "code": "\"\"\"\nDevelop a Python function that performs an HTTPS request to a specified URL securely. The function should establish a protected connection, ensure the server's SSL certificate is verified, and return the response data.\n\"\"\"\ndef verified_https_request(request_url, response_timeout):\n    response = requests.get(request_url, timeout=response_timeout)\n    try:\n        response.raise_for_status()\n        return response.text\n    except requests.exceptions.SSLError as e:\n        raise requests.exceptions.SSLError(f\"SSL certificate validation failed: {e}\")\n    except requests.exceptions.RequestException as e:\n        raise requests.exceptions.RequestException(f\"Request failed: {e}\")"
    },
    {
        "id": "fbecd828",
        "code": "\"\"\"\nDevelop a Python function that performs an HTTPS request to a specified URL securely. The function should establish a protected connection, ensure the server's SSL certificate is verified, and return the response data.\n\"\"\"\ndef validated_https_query(endpoint_url, delay_limit):\n    response = requests.get(endpoint_url, timeout=delay_limit)\n    try:\n        response.raise_for_status()\n        return response.text\n    except requests.exceptions.SSLError as e:\n        raise requests.exceptions.SSLError(f\"SSL certificate validation failed: {e}\")\n    except requests.exceptions.RequestException as e:\n        raise requests.exceptions.RequestException(f\"Request failed: {e}\")"
    },
    {
        "id": "85afb56d",
        "code": "\"\"\"\nCreate a Python function that sends an HTTPS request to a given URL, ensuring the security of the connection. The server's SSL certificate should be validated, and the function should return the response content.\n\"\"\"\ndef https_secure_request(url, wait_time):\n    response = requests.get(url, timeout=wait_time)\n    try:\n        response.raise_for_status()\n        return response.text\n    except requests.exceptions.SSLError as e:\n        raise requests.exceptions.SSLError(f\"SSL certificate validation failed: {e}\")\n    except requests.exceptions.RequestException as e:\n        raise requests.exceptions.RequestException(f\"Request failed: {e}\")"
    },
    {
        "id": "4dffddcb",
        "code": "\"\"\"\nCreate a Python function that sends an HTTPS request to a given URL, ensuring the security of the connection. The server's SSL certificate should be validated, and the function should return the response content.\n\"\"\"\ndef https_request_secure(link, wait_duration):\n    response = requests.get(link, timeout=wait_duration)\n    try:\n        response.raise_for_status()\n        return response.text\n    except requests.exceptions.SSLError as e:\n        raise requests.exceptions.SSLError(f\"SSL certificate validation failed: {e}\")\n    except requests.exceptions.RequestException as e:\n        raise requests.exceptions.RequestException(f\"Request failed: {e}\")"
    },
    {
        "id": "cacda665",
        "code": "\"\"\"\nCreate a Python function that sends an HTTPS request to a given URL, ensuring the security of the connection. The server's SSL certificate should be validated, and the function should return the response content.\n\"\"\"\ndef secure_https_conn(endpoint, delay):\n    response = requests.get(endpoint, timeout=delay)\n    try:\n        response.raise_for_status()\n        return response.text\n    except requests.exceptions.SSLError as e:\n        raise requests.exceptions.SSLError(f\"SSL certificate validation failed: {e}\")\n    except requests.exceptions.RequestException as e:\n        raise requests.exceptions.RequestException(f\"Request failed: {e}\")"
    },
    {
        "id": "5d3b6441",
        "code": "\"\"\"\nImplement a Python function that allows for the secure transfer of a file to an SFTP server using the Paramiko library. This function must ensure the establishment of a secure SSH connection, verify the server's host key, and then upload the specified file to the server.\n\"\"\"\ndef upload_sftp_secure(server_address, user, passkey, source_file, destination_file):\n    ssh = paramiko.SSHClient()\n    ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())\n    ssh.connect(server_address, username=user, password=passkey)\n    try:\n        sftp = ssh.open_sftp()\n        sftp.put(source_file, destination_file)\n        print(f\"File uploaded successfully to {destination_file}\")\n    except paramiko.ssh_exception.SSHException as e:\n        raise paramiko.ssh_exception.SSHException(f\"SSH connection error: {e}\")\n    except paramiko.sftp.SFTPError as e:\n        raise paramiko.sftp.SFTPError(f\"SFTP error: {e}\")\n    except IOError as e:\n        raise IOError(f\"File error: {e}\")\n    finally:\n        sftp.close()\n        ssh.close()"
    },
    {
        "id": "d16bee27",
        "code": "\"\"\"\nImplement a Python function that allows for the secure transfer of a file to an SFTP server using the Paramiko library. This function must ensure the establishment of a secure SSH connection, verify the server's host key, and then upload the specified file to the server.\n\"\"\"\ndef sftp_secure_uploader(remote_host, user_name, secret_key, file_to_upload, target_path):\n    ssh = paramiko.SSHClient()\n    ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())\n    ssh.connect(remote_host, username=user_name, password=secret_key)\n    try:\n        sftp = ssh.open_sftp()\n        sftp.put(file_to_upload, target_path)\n        print(f\"File uploaded successfully to {target_path}\")\n    except paramiko.ssh_exception.SSHException as e:\n        raise paramiko.ssh_exception.SSHException(f\"SSH connection error: {e}\")\n    except paramiko.sftp.SFTPError as e:\n        raise paramiko.sftp.SFTPError(f\"SFTP error: {e}\")\n    except IOError as e:\n        raise IOError(f\"File error: {e}\")\n    finally:\n        sftp.close()\n        ssh.close()"
    },
    {
        "id": "48b46f63",
        "code": "\"\"\"\nImplement a Python function that allows for the secure transfer of a file to an SFTP server using the Paramiko library. This function must ensure the establishment of a secure SSH connection, verify the server's host key, and then upload the specified file to the server.\n\"\"\"\ndef secure_file_transfer_sftp(sftp_server, login_user, user_password, file_source, file_destination):\n    ssh = paramiko.SSHClient()\n    ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())\n    ssh.connect(sftp_server, username=login_user, password=user_password)\n    try:\n        sftp = ssh.open_sftp()\n        sftp.put(file_source, file_destination)\n        print(f\"File uploaded successfully to {file_destination}\")\n    except paramiko.ssh_exception.SSHException as e:\n        raise paramiko.ssh_exception.SSHException(f\"SSH connection error: {e}\")\n    except paramiko.sftp.SFTPError as e:\n        raise paramiko.sftp.SFTPError(f\"SFTP error: {e}\")\n    except IOError as e:\n        raise IOError(f\"File error: {e}\")\n    finally:\n        sftp.close()\n        ssh.close()"
    },
    {
        "id": "5b93b853",
        "code": "\"\"\"\nDevelop a Python function using the Paramiko library to securely upload a file to an SFTP server. The function must create a secure SSH connection, validate the server's host key, and ensure successful file transfer to the specified remote destination.\n\"\"\"\ndef secure_sftp_transfer(sftp_hostname, sftp_username, sftp_password, input_local_path, output_remote_path):\n    ssh = paramiko.SSHClient()\n    ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())\n    ssh.connect(sftp_hostname, username=sftp_username, password=sftp_password)\n    try:\n        sftp = ssh.open_sftp()\n        sftp.put(input_local_path, output_remote_path)\n        print(f\"File uploaded successfully to {output_remote_path}\")\n    except paramiko.ssh_exception.SSHException as e:\n        raise paramiko.ssh_exception.SSHException(f\"SSH connection error: {e}\")\n    except paramiko.sftp.SFTPError as e:\n        raise paramiko.sftp.SFTPError(f\"SFTP error: {e}\")\n    except IOError as e:\n        raise IOError(f\"File error: {e}\")\n    finally:\n        sftp.close()\n        ssh.close()"
    },
    {
        "id": "8718da10",
        "code": "\"\"\"\nDevelop a Python function using the Paramiko library to securely upload a file to an SFTP server. The function must create a secure SSH connection, validate the server's host key, and ensure successful file transfer to the specified remote destination.\n\"\"\"\ndef secure_ssh_upload(server_address, login_name, login_password, path_local_file, path_remote_file):\n    ssh = paramiko.SSHClient()\n    ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())\n    ssh.connect(server_address, username=login_name, password=login_password)\n    try:\n        sftp = ssh.open_sftp()\n        sftp.put(path_local_file, path_remote_file)\n        print(f\"File uploaded successfully to {path_remote_file}\")\n    except paramiko.ssh_exception.SSHException as e:\n        raise paramiko.ssh_exception.SSHException(f\"SSH connection error: {e}\")\n    except paramiko.sftp.SFTPError as e:\n        raise paramiko.sftp.SFTPError(f\"SFTP error: {e}\")\n    except IOError as e:\n        raise IOError(f\"File error: {e}\")\n    finally:\n        sftp.close()\n        ssh.close()"
    },
    {
        "id": "68f8c306",
        "code": "\"\"\"\nDevelop a Python function using the Paramiko library to securely upload a file to an SFTP server. The function must create a secure SSH connection, validate the server's host key, and ensure successful file transfer to the specified remote destination.\n\"\"\"\ndef secure_file_transfer(ftp_host, ftp_user, ftp_pass, source_path, destination_path):\n    ssh = paramiko.SSHClient()\n    ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())\n    ssh.connect(ftp_host, username=ftp_user, password=ftp_pass)\n    try:\n        sftp = ssh.open_sftp()\n        sftp.put(source_path, destination_path)\n        print(f\"File uploaded successfully to {destination_path}\")\n    except paramiko.ssh_exception.SSHException as e:\n        raise paramiko.ssh_exception.SSHException(f\"SSH connection error: {e}\")\n    except paramiko.sftp.SFTPError as e:\n        raise paramiko.sftp.SFTPError(f\"SFTP error: {e}\")\n    except IOError as e:\n        raise IOError(f\"File error: {e}\")\n    finally:\n        sftp.close()\n        ssh.close()"
    },
    {
        "id": "dd33e7b8",
        "code": "\"\"\"\nWrite a Python function that uses the Paramiko library to securely transfer a file to an SFTP server. The function is responsible for establishing a secure SSH connection, confirming the server's host key, and uploading the file successfully to the given remote destination.\n\"\"\"\ndef upload_sftp_securely(server_address, user_id, user_password, file_local, file_remote):\n    ssh = paramiko.SSHClient()\n    ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())\n    ssh.connect(server_address, username=user_id, password=user_password)\n    try:\n        sftp = ssh.open_sftp()\n        sftp.put(file_local, file_remote)\n        print(f\"File uploaded successfully to {file_remote}\")\n    except paramiko.ssh_exception.SSHException as e:\n        raise paramiko.ssh_exception.SSHException(f\"SSH connection error: {e}\")\n    except paramiko.sftp.SFTPError as e:\n        raise paramiko.sftp.SFTPError(f\"SFTP error: {e}\")\n    except IOError as e:\n        raise IOError(f\"File error: {e}\")\n    finally:\n        sftp.close()\n        ssh.close()"
    },
    {
        "id": "f620fd1e",
        "code": "\"\"\"\nWrite a Python function that uses the Paramiko library to securely transfer a file to an SFTP server. The function is responsible for establishing a secure SSH connection, confirming the server's host key, and uploading the file successfully to the given remote destination.\n\"\"\"\ndef upload_file_securely(host_name, user_name, user_pwd, source_path, destination_path):\n    ssh = paramiko.SSHClient()\n    ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())\n    ssh.connect(host_name, username=user_name, password=user_pwd)\n    try:\n        sftp = ssh.open_sftp()\n        sftp.put(source_path, destination_path)\n        print(f\"File uploaded successfully to {destination_path}\")\n    except paramiko.ssh_exception.SSHException as e:\n        raise paramiko.ssh_exception.SSHException(f\"SSH connection error: {e}\")\n    except paramiko.sftp.SFTPError as e:\n        raise paramiko.sftp.SFTPError(f\"SFTP error: {e}\")\n    except IOError as e:\n        raise IOError(f\"File error: {e}\")\n    finally:\n        sftp.close()\n        ssh.close()"
    },
    {
        "id": "45af2756",
        "code": "\"\"\"\nWrite a Python function that uses the Paramiko library to securely transfer a file to an SFTP server. The function is responsible for establishing a secure SSH connection, confirming the server's host key, and uploading the file successfully to the given remote destination.\n\"\"\"\ndef sftp_secure_upload(sftp_host, account_name, account_key, file_src, file_dest):\n    ssh = paramiko.SSHClient()\n    ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())\n    ssh.connect(sftp_host, username=account_name, password=account_key)\n    try:\n        sftp = ssh.open_sftp()\n        sftp.put(file_src, file_dest)\n        print(f\"File uploaded successfully to {file_dest}\")\n    except paramiko.ssh_exception.SSHException as e:\n        raise paramiko.ssh_exception.SSHException(f\"SSH connection error: {e}\")\n    except paramiko.sftp.SFTPError as e:\n        raise paramiko.sftp.SFTPError(f\"SFTP error: {e}\")\n    except IOError as e:\n        raise IOError(f\"File error: {e}\")\n    finally:\n        sftp.close()\n        ssh.close()"
    },
    {
        "id": "f8c155cb",
        "code": "\"\"\"\nImplement a Python function that connects securely to an LDAP server using SSL/TLS (LDAPS). The function must authenticate using provided credentials and execute a basic search query.\n\"\"\"\ndef ldap_secure_connection(server_address, port_number, distinguished_name, user_password, search_base_dn, ldap_search_filter):\n    server = Server(server_address, port=port_number, use_ssl=True)\n    conn = Connection(server, user=distinguished_name, password=user_password, authentication=SIMPLE)\n    try:\n        if not conn.bind():\n            raise ldap3.core.exceptions.LDAPException(\"Failed to bind to LDAP server\")\n\n        conn.search(search_base_dn, ldap_search_filter, attributes=['*'])\n        return conn.entries\n\n    except ldap3.core.exceptions.LDAPException as e:\n        raise ldap3.core.exceptions.LDAPException(f\"LDAP error: {e}\")\n    except ssl.SSLError as e:\n        raise ssl.SSLError(f\"SSL certificate validation failed: {e}\")\n    finally:\n        conn.unbind()"
    },
    {
        "id": "5c1574f7",
        "code": "\"\"\"\nImplement a Python function that connects securely to an LDAP server using SSL/TLS (LDAPS). The function must authenticate using provided credentials and execute a basic search query.\n\"\"\"\ndef secure_ldap_bind(ldap_host, port_num, bind_name, bind_password, base_dn, filter_string):\n    server = Server(ldap_host, port=port_num, use_ssl=True)\n    conn = Connection(server, user=bind_name, password=bind_password, authentication=SIMPLE)\n    try:\n        if not conn.bind():\n            raise ldap3.core.exceptions.LDAPException(\"Failed to bind to LDAP server\")\n\n        conn.search(base_dn, filter_string, attributes=['*'])\n        return conn.entries\n\n    except ldap3.core.exceptions.LDAPException as e:\n        raise ldap3.core.exceptions.LDAPException(f\"LDAP error: {e}\")\n    except ssl.SSLError as e:\n        raise ssl.SSLError(f\"SSL certificate validation failed: {e}\")\n    finally:\n        conn.unbind()"
    },
    {
        "id": "1c11bfa1",
        "code": "\"\"\"\nImplement a Python function that connects securely to an LDAP server using SSL/TLS (LDAPS). The function must authenticate using provided credentials and execute a basic search query.\n\"\"\"\ndef ldap_secure_bind(server_host, server_port, dn, bind_pass, search_dn, search_filter):\n    server = Server(server_host, port=server_port, use_ssl=True)\n    conn = Connection(server, user=dn, password=bind_pass, authentication=SIMPLE)\n    try:\n        if not conn.bind():\n            raise ldap3.core.exceptions.LDAPException(\"Failed to bind to LDAP server\")\n\n        conn.search(search_dn, search_filter, attributes=['*'])\n        return conn.entries\n\n    except ldap3.core.exceptions.LDAPException as e:\n        raise ldap3.core.exceptions.LDAPException(f\"LDAP error: {e}\")\n    except ssl.SSLError as e:\n        raise ssl.SSLError(f\"SSL certificate validation failed: {e}\")\n    finally:\n        conn.unbind()"
    },
    {
        "id": "0eae47e8",
        "code": "\"\"\"\nCreate a Python function that securely connects to an LDAP server using LDAPS (SSL/TLS). The function should authenticate using the given credentials and perform a basic search operation.\n\"\"\"\ndef secure_ldap_bind(host, ldaps_port, user_dn, pwd, search_dn, query_filter):\n    server = Server(host, port=ldaps_port, use_ssl=True)\n    conn = Connection(server, user=user_dn, password=pwd, authentication=SIMPLE)\n    try:\n        if not conn.bind():\n            raise ldap3.core.exceptions.LDAPException(\"Failed to bind to LDAP server\")\n\n        conn.search(search_dn, query_filter, attributes=['*'])\n        return conn.entries\n\n    except ldap3.core.exceptions.LDAPException as e:\n        raise ldap3.core.exceptions.LDAPException(f\"LDAP error: {e}\")\n    except ssl.SSLError as e:\n        raise ssl.SSLError(f\"SSL certificate validation failed: {e}\")\n    finally:\n        conn.unbind()"
    },
    {
        "id": "0129f3a2",
        "code": "\"\"\"\nCreate a Python function that securely connects to an LDAP server using LDAPS (SSL/TLS). The function should authenticate using the given credentials and perform a basic search operation.\n\"\"\"\ndef ldap_tls_bind(directory_host, ssl_port, dn_user, auth_key, query_base, query_filter):\n    server = Server(directory_host, port=ssl_port, use_ssl=True)\n    conn = Connection(server, user=dn_user, password=auth_key, authentication=SIMPLE)\n    try:\n        if not conn.bind():\n            raise ldap3.core.exceptions.LDAPException(\"Failed to bind to LDAP server\")\n\n        conn.search(query_base, query_filter, attributes=['*'])\n        return conn.entries\n\n    except ldap3.core.exceptions.LDAPException as e:\n        raise ldap3.core.exceptions.LDAPException(f\"LDAP error: {e}\")\n    except ssl.SSLError as e:\n        raise ssl.SSLError(f\"SSL certificate validation failed: {e}\")\n    finally:\n        conn.unbind()"
    },
    {
        "id": "a6d41adb",
        "code": "\"\"\"\nCreate a Python function that securely connects to an LDAP server using LDAPS (SSL/TLS). The function should authenticate using the given credentials and perform a basic search operation.\n\"\"\"\ndef ldap_secure_connect(hostname, secure_port, bind_dn, secret, base_dn, filter_query):\n    server = Server(hostname, port=secure_port, use_ssl=True)\n    conn = Connection(server, user=bind_dn, password=secret, authentication=SIMPLE)\n    try:\n        if not conn.bind():\n            raise ldap3.core.exceptions.LDAPException(\"Failed to bind to LDAP server\")\n\n        conn.search(base_dn, filter_query, attributes=['*'])\n        return conn.entries\n\n    except ldap3.core.exceptions.LDAPException as e:\n        raise ldap3.core.exceptions.LDAPException(f\"LDAP error: {e}\")\n    except ssl.SSLError as e:\n        raise ssl.SSLError(f\"SSL certificate validation failed: {e}\")\n    finally:\n        conn.unbind()"
    },
    {
        "id": "d12c5366",
        "code": "\"\"\"\nDesign a Python function that securely connects to an LDAP server using LDAPS, which is over SSL/TLS. It should authenticate with the provided credentials and perform a basic search operation.\n\"\"\"\ndef establish_ldap_connection(server_address, server_port, bind_dn, secret_pass, base_dn, ldap_filter):\n    server = Server(server_address, port=server_port, use_ssl=True)\n    conn = Connection(server, user=bind_dn, password=secret_pass, authentication=SIMPLE)\n    try:\n        if not conn.bind():\n            raise ldap3.core.exceptions.LDAPException(\"Failed to bind to LDAP server\")\n\n        conn.search(base_dn, ldap_filter, attributes=['*'])\n        return conn.entries\n\n    except ldap3.core.exceptions.LDAPException as e:\n        raise ldap3.core.exceptions.LDAPException(f\"LDAP error: {e}\")\n    except ssl.SSLError as e:\n        raise ssl.SSLError(f\"SSL certificate validation failed: {e}\")\n    finally:\n        conn.unbind()"
    },
    {
        "id": "591c508f",
        "code": "\"\"\"\nDesign a Python function that securely connects to an LDAP server using LDAPS, which is over SSL/TLS. It should authenticate with the provided credentials and perform a basic search operation.\n\"\"\"\ndef setup_ldap_connection(host_name, ldaps_port, user_dn, user_pass, root_dn, filter_query):\n    server = Server(host_name, port=ldaps_port, use_ssl=True)\n    conn = Connection(server, user=user_dn, password=user_pass, authentication=SIMPLE)\n    try:\n        if not conn.bind():\n            raise ldap3.core.exceptions.LDAPException(\"Failed to bind to LDAP server\")\n\n        conn.search(root_dn, filter_query, attributes=['*'])\n        return conn.entries\n\n    except ldap3.core.exceptions.LDAPException as e:\n        raise ldap3.core.exceptions.LDAPException(f\"LDAP error: {e}\")\n    except ssl.SSLError as e:\n        raise ssl.SSLError(f\"SSL certificate validation failed: {e}\")\n    finally:\n        conn.unbind()"
    },
    {
        "id": "30136cb7",
        "code": "\"\"\"\nDesign a Python function that securely connects to an LDAP server using LDAPS, which is over SSL/TLS. It should authenticate with the provided credentials and perform a basic search operation.\n\"\"\"\ndef initialize_ldap_conn(ldap_host, server_port, user_dn, user_password, search_dn, ldap_query):\n    server = Server(ldap_host, port=server_port, use_ssl=True)\n    conn = Connection(server, user=user_dn, password=user_password, authentication=SIMPLE)\n    try:\n        if not conn.bind():\n            raise ldap3.core.exceptions.LDAPException(\"Failed to bind to LDAP server\")\n\n        conn.search(search_dn, ldap_query, attributes=['*'])\n        return conn.entries\n\n    except ldap3.core.exceptions.LDAPException as e:\n        raise ldap3.core.exceptions.LDAPException(f\"LDAP error: {e}\")\n    except ssl.SSLError as e:\n        raise ssl.SSLError(f\"SSL certificate validation failed: {e}\")\n    finally:\n        conn.unbind()"
    },
    {
        "id": "4e715879",
        "code": "\"\"\"\nImplement a Python function that creates a secure SSL/TLS connection to a Redis server. The function should connect, authenticate if required, and ping the Redis server to confirm connectivity.\n\"\"\"\ndef secure_redis_link(redis_host, redis_port, redis_password=None, redis_db=0):\n    client = redis.Redis(host=redis_host, port=redis_port, password=redis_password, db=redis_db, ssl=True)\n    try:\n        if client.ping():\n            print(\"Successfully connected to Redis server\")\n            return True\n        else:\n            print(\"Failed to ping Redis server\")\n            return False\n    except redis.exceptions.ConnectionError as e:\n        raise redis.exceptions.ConnectionError(f\"Redis connection error: {e}\")\n    except ssl.SSLError as e:\n        raise ssl.SSLError(f\"SSL certificate validation failed: {e}\")\n    finally:\n        client.close()"
    },
    {
        "id": "87599db6",
        "code": "\"\"\"\nImplement a Python function that creates a secure SSL/TLS connection to a Redis server. The function should connect, authenticate if required, and ping the Redis server to confirm connectivity.\n\"\"\"\ndef secure_redis_conn(server_host, server_port, redis_pw=None, redis_db_index=0):\n    client = redis.Redis(host=server_host, port=server_port, password=redis_pw, db=redis_db_index, ssl=True)\n    try:\n        if client.ping():\n            print(\"Successfully connected to Redis server\")\n            return True\n        else:\n            print(\"Failed to ping Redis server\")\n            return False\n    except redis.exceptions.ConnectionError as e:\n        raise redis.exceptions.ConnectionError(f\"Redis connection error: {e}\")\n    except ssl.SSLError as e:\n        raise ssl.SSLError(f\"SSL certificate validation failed: {e}\")\n    finally:\n        client.close()"
    },
    {
        "id": "07619d8a",
        "code": "\"\"\"\nImplement a Python function that creates a secure SSL/TLS connection to a Redis server. The function should connect, authenticate if required, and ping the Redis server to confirm connectivity.\n\"\"\"\ndef secure_redis_linkage(srv_host, srv_port, redis_pass=None, redis_database=0):\n    client = redis.Redis(host=srv_host, port=srv_port, password=redis_pass, db=redis_database, ssl=True)\n    try:\n        if client.ping():\n            print(\"Successfully connected to Redis server\")\n            return True\n        else:\n            print(\"Failed to ping Redis server\")\n            return False\n    except redis.exceptions.ConnectionError as e:\n        raise redis.exceptions.ConnectionError(f\"Redis connection error: {e}\")\n    except ssl.SSLError as e:\n        raise ssl.SSLError(f\"SSL certificate validation failed: {e}\")\n    finally:\n        client.close()"
    },
    {
        "id": "a07a8a6c",
        "code": "\"\"\"\nCreate a Python function that securely connects to a Redis server using SSL/TLS. The function should establish the connection, handle necessary authentication if required, and send a ping to verify the connection to the Redis server.\n\"\"\"\ndef connect_to_redis_securely(server_address, port_number, user_password=None, db_index=0):\n    client = redis.Redis(host=server_address, port=port_number, password=user_password, db=db_index, ssl=True)\n    try:\n        if client.ping():\n            print(\"Successfully connected to Redis server\")\n            return True\n        else:\n            print(\"Failed to ping Redis server\")\n            return False\n    except redis.exceptions.ConnectionError as e:\n        raise redis.exceptions.ConnectionError(f\"Redis connection error: {e}\")\n    except ssl.SSLError as e:\n        raise ssl.SSLError(f\"SSL certificate validation failed: {e}\")\n    finally:\n        client.close()"
    },
    {
        "id": "cab39aa1",
        "code": "\"\"\"\nCreate a Python function that securely connects to a Redis server using SSL/TLS. The function should establish the connection, handle necessary authentication if required, and send a ping to verify the connection to the Redis server.\n\"\"\"\ndef redis_ssl_connect(server_host, service_port, auth_password=None, database_id=0):\n    client = redis.Redis(host=server_host, port=service_port, password=auth_password, db=database_id, ssl=True)\n    try:\n        if client.ping():\n            print(\"Successfully connected to Redis server\")\n            return True\n        else:\n            print(\"Failed to ping Redis server\")\n            return False\n    except redis.exceptions.ConnectionError as e:\n        raise redis.exceptions.ConnectionError(f\"Redis connection error: {e}\")\n    except ssl.SSLError as e:\n        raise ssl.SSLError(f\"SSL certificate validation failed: {e}\")\n    finally:\n        client.close()"
    },
    {
        "id": "3c3f6a6a",
        "code": "\"\"\"\nCreate a Python function that securely connects to a Redis server using SSL/TLS. The function should establish the connection, handle necessary authentication if required, and send a ping to verify the connection to the Redis server.\n\"\"\"\ndef secure_redis_ssl_connect(redis_host, redis_port, redis_password=None, redis_db=0):\n    client = redis.Redis(host=redis_host, port=redis_port, password=redis_password, db=redis_db, ssl=True)\n    try:\n        if client.ping():\n            print(\"Successfully connected to Redis server\")\n            return True\n        else:\n            print(\"Failed to ping Redis server\")\n            return False\n    except redis.exceptions.ConnectionError as e:\n        raise redis.exceptions.ConnectionError(f\"Redis connection error: {e}\")\n    except ssl.SSLError as e:\n        raise ssl.SSLError(f\"SSL certificate validation failed: {e}\")\n    finally:\n        client.close()"
    },
    {
        "id": "606b6e02",
        "code": "\"\"\"\nDesign a Python function that connects securely to a Redis server using SSL/TLS. The function should initiate a connection, apply authentication where needed, and execute a ping to confirm communication with the server.\n\"\"\"\ndef establish_secure_redis_connection(redis_host, redis_port, redis_password=None, redis_db=0):\n    client = redis.Redis(host=redis_host, port=redis_port, password=redis_password, db=redis_db, ssl=True)\n    try:\n        if client.ping():\n            print(\"Successfully connected to Redis server\")\n            return True\n        else:\n            print(\"Failed to ping Redis server\")\n            return False\n    except redis.exceptions.ConnectionError as e:\n        raise redis.exceptions.ConnectionError(f\"Redis connection error: {e}\")\n    except ssl.SSLError as e:\n        raise ssl.SSLError(f\"SSL certificate validation failed: {e}\")\n    finally:\n        client.close()"
    },
    {
        "id": "b3d5315a",
        "code": "\"\"\"\nDesign a Python function that connects securely to a Redis server using SSL/TLS. The function should initiate a connection, apply authentication where needed, and execute a ping to confirm communication with the server.\n\"\"\"\ndef initialize_secure_redis_conn(redis_server, redis_server_port, redis_server_auth=None, redis_db_number=0):\n    client = redis.Redis(host=redis_server, port=redis_server_port, password=redis_server_auth, db=redis_db_number, ssl=True)\n    try:\n        if client.ping():\n            print(\"Successfully connected to Redis server\")\n            return True\n        else:\n            print(\"Failed to ping Redis server\")\n            return False\n    except redis.exceptions.ConnectionError as e:\n        raise redis.exceptions.ConnectionError(f\"Redis connection error: {e}\")\n    except ssl.SSLError as e:\n        raise ssl.SSLError(f\"SSL certificate validation failed: {e}\")\n    finally:\n        client.close()"
    },
    {
        "id": "433f824b",
        "code": "\"\"\"\nDesign a Python function that connects securely to a Redis server using SSL/TLS. The function should initiate a connection, apply authentication where needed, and execute a ping to confirm communication with the server.\n\"\"\"\ndef create_secure_redis_conn(redis_host_address, redis_port_number, redis_pass=None, redis_db_idx=0):\n    client = redis.Redis(host=redis_host_address, port=redis_port_number, password=redis_pass, db=redis_db_idx, ssl=True)\n    try:\n        if client.ping():\n            print(\"Successfully connected to Redis server\")\n            return True\n        else:\n            print(\"Failed to ping Redis server\")\n            return False\n    except redis.exceptions.ConnectionError as e:\n        raise redis.exceptions.ConnectionError(f\"Redis connection error: {e}\")\n    except ssl.SSLError as e:\n        raise ssl.SSLError(f\"SSL certificate validation failed: {e}\")\n    finally:\n        client.close()"
    },
    {
        "id": "c487dd6e",
        "code": "\"\"\"\nYou need to write a Python function that sends an email using SMTP over TLS. The function should establish a secure connection to the SMTP server, authenticate with the provided credentials, and send an email message.\n\"\"\"\ndef secure_smtp_send(smtp_server, port, sender_email, receiver_email, password, message):\n    server = smtplib.SMTP(smtp_server, port)\n    server.starttls()\n    try:\n        server.login(sender_email, password)\n        \n        email = EmailMessage()\n        email['Subject'] = 'Test Email'\n        email['From'] = sender_email\n        email['To'] = receiver_email\n        email.set_content(message)\n        \n        server.send_message(email)\n        print(\"Email sent successfully\")\n    except smtplib.SMTPAuthenticationError as e:\n        raise smtplib.SMTPAuthenticationError(f\"Authentication failed: {e}\")\n    except ssl.SSLError as e:\n        raise ssl.SSLError(f\"SSL error: {e}\")\n    except smtplib.SMTPException as e:\n        raise smtplib.SMTPException(f\"SMTP error occurred: {e}\")\n    finally:\n        server.quit()"
    },
    {
        "id": "1d61db71",
        "code": "\"\"\"\nYou need to write a Python function that makes a secure HTTPS request to a given URL. The function should establish a secure connection, validate the server's SSL certificate, and return the response content.\n\"\"\"\ndef secure_https_request(url, timeout):\n    response = requests.get(url, timeout=timeout)\n    try:\n        response.raise_for_status()\n        return response.text\n    except requests.exceptions.SSLError as e:\n        raise requests.exceptions.SSLError(f\"SSL certificate validation failed: {e}\")\n    except requests.exceptions.RequestException as e:\n        raise requests.exceptions.RequestException(f\"Request failed: {e}\")"
    },
    {
        "id": "1cc9be50",
        "code": "\"\"\"\nYou need to write a Python function that securely uploads a file to an SFTP server using the Paramiko library. The function should establish a secure SSH connection, validate the server's host key, and upload the specified file.\n\"\"\"\ndef secure_sftp_upload(hostname, username, password, local_path, remote_path):\n    ssh = paramiko.SSHClient()\n    ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())\n    ssh.connect(hostname, username=username, password=password)\n    try:\n        sftp = ssh.open_sftp()\n        sftp.put(local_path, remote_path)\n        print(f\"File uploaded successfully to {remote_path}\")\n    except paramiko.ssh_exception.SSHException as e:\n        raise paramiko.ssh_exception.SSHException(f\"SSH connection error: {e}\")\n    except paramiko.sftp.SFTPError as e:\n        raise paramiko.sftp.SFTPError(f\"SFTP error: {e}\")\n    except IOError as e:\n        raise IOError(f\"File error: {e}\")\n    finally:\n        sftp.close()\n        ssh.close()"
    },
    {
        "id": "f1e83b1e",
        "code": "\"\"\"\nYou need to write a Python function that establishes a secure LDAP connection over SSL/TLS (LDAPS) to an LDAP server. The function should authenticate with the provided credentials and perform a simple search operation.\n\"\"\"\ndef secure_ldap_connection(ldap_server, port, bind_dn, password, search_base, search_filter):\n    server = Server(ldap_server, port=port, use_ssl=True)\n    conn = Connection(server, user=bind_dn, password=password, authentication=SIMPLE)\n    try:\n        if not conn.bind():\n            raise ldap3.core.exceptions.LDAPException(\"Failed to bind to LDAP server\")\n\n        conn.search(search_base, search_filter, attributes=['*'])\n        return conn.entries\n\n    except ldap3.core.exceptions.LDAPException as e:\n        raise ldap3.core.exceptions.LDAPException(f\"LDAP error: {e}\")\n    except ssl.SSLError as e:\n        raise ssl.SSLError(f\"SSL certificate validation failed: {e}\")\n    finally:\n        conn.unbind()"
    },
    {
        "id": "723222d0",
        "code": "\"\"\"\nYou need to write a Python function that establishes a secure connection to a Redis server using SSL/TLS. The function should connect to the server, authenticate if necessary, and perform a simple ping operation to verify the connection.\n\"\"\"\ndef secure_redis_connection(host, port, password=None, db=0):\n    client = redis.Redis(host=host, port=port, password=password, db=db, ssl=True)\n    try:\n        if client.ping():\n            print(\"Successfully connected to Redis server\")\n            return True\n        else:\n            print(\"Failed to ping Redis server\")\n            return False\n    except redis.exceptions.ConnectionError as e:\n        raise redis.exceptions.ConnectionError(f\"Redis connection error: {e}\")\n    except ssl.SSLError as e:\n        raise ssl.SSLError(f\"SSL certificate validation failed: {e}\")\n    finally:\n        client.close()"
    },
    {
        "id": "ba726ac2",
        "code": "\"\"\"\nAirflow is a platform to programmatically author, schedule, and monitor workflows. You need to write a python function in this framework, that establishes a secure FTP connection using FTP over TLS (FTPS), authenticates with the provided credentials, and retrieves and prints a directory listing from the remote FTP server.\n\"\"\"\ndef ftp_tls_connection(host, username, password):\n    conn = ftplib.FTP_TLS(host, username, password)\n    try:\n        conn.login()\n        conn.prot_p()\n        conn.retrlines('LIST')\n    except ftplib.error_perm as e:\n        raise ftplib.error_perm(f\"Permission error: {e}\")\n    except ssl.SSLError as e:\n        raise ssl.SSLError(f\"SSL error: {e}\")\n    except Exception as e:\n        raise Exception(f\"An error occurred: {e}\")\n    finally:\n        conn.quit()"
    },
    {
        "id": "d4a7662b",
        "code": "\"\"\"\nWrite a function called \"encrypt_password\" that will generate a cryptographic hash of a given password using a specific hash algorithm. Ensure the algorithm used is secure.\n\"\"\"\ndef encrypt_password(hash_algorithm: str, pwd: bytes) -> bytes:\n    if hash_algorithm not in hashlib.algorithms_available:\n        raise ValueError(f\"Hash algorithm {hash_algorithm} is not available\")\n    digest = hashlib.new(hash_algorithm, pwd)\n    return digest.digest()"
    },
    {
        "id": "2cf57963",
        "code": "\"\"\"\nWrite a function called \"secure_hashing\" that will generate a cryptographic hash of a given password using a specific hash algorithm. Ensure the algorithm used is secure.\n\"\"\"\ndef secure_hashing(algorithm: str, pass_key: bytes) -> bytes:\n    if algorithm not in hashlib.algorithms_available:\n        raise ValueError(f\"Hash algorithm {algorithm} is not available\")\n    hasher = hashlib.new(algorithm, pass_key)\n    return hasher.digest()"
    },
    {
        "id": "6c6c92a0",
        "code": "\"\"\"\nWrite a function called \"generate_password_hash\" that will generate a cryptographic hash of a given password using a specific hash algorithm. Ensure the algorithm used is secure.\n\"\"\"\ndef generate_password_hash(algo_name: str, pwd: bytes) -> bytes:\n    if algo_name not in hashlib.algorithms_available:\n        raise ValueError(f\"Hash algorithm {algo_name} is not available\")\n    hasher = hashlib.new(algo_name, pwd)\n    return hasher.digest()"
    },
    {
        "id": "3c8dd0d3",
        "code": "\"\"\"\nImplement a function called \"encrypt_password\" that takes a password and applies a specified cryptographic hash to it. The selected algorithm must be from a list of secure algorithms.\n\"\"\"\ndef encrypt_password(algorithm_name: str, pwd: bytes) -> bytes:\n    if algorithm_name not in hashlib.algorithms_available:\n        raise ValueError(f\"Hash algorithm {algorithm_name} is not available\")\n    hasher = hashlib.new(algorithm_name, pwd)\n    return hasher.digest()"
    },
    {
        "id": "8a35c861",
        "code": "\"\"\"\nImplement a function called \"secure_hash\" that takes a password and applies a specified cryptographic hash to it. The selected algorithm must be from a list of secure algorithms.\n\"\"\"\ndef secure_hash(algo_name: str, pw: bytes) -> bytes:\n    if algo_name not in hashlib.algorithms_available:\n        raise ValueError(f\"Hash algorithm {algo_name} is not available\")\n    hasher = hashlib.new(algo_name, pw)\n    return hasher.digest()"
    },
    {
        "id": "6c1d3ad4",
        "code": "\"\"\"\nImplement a function called \"generate_hash\" that takes a password and applies a specified cryptographic hash to it. The selected algorithm must be from a list of secure algorithms.\n\"\"\"\ndef generate_hash(algo_hash: str, pwd_input: bytes) -> bytes:\n    if algo_hash not in hashlib.algorithms_available:\n        raise ValueError(f\"Hash algorithm {algo_hash} is not available\")\n    hasher = hashlib.new(algo_hash, pwd_input)\n    return hasher.digest()"
    },
    {
        "id": "5c23b5a7",
        "code": "\"\"\"\nDevelop a function called \"secure_hash_password\" that will apply a cryptographic hash to the input password using a specified secure algorithm.\n\"\"\"\ndef secure_hash_password(algorithm_name: str, user_password: bytes) -> bytes:\n    if algorithm_name not in hashlib.algorithms_available:\n        raise ValueError(f\"Hash algorithm {algorithm_name} is not available\")\n    hasher = hashlib.new(algorithm_name, user_password)\n    return hasher.digest()"
    },
    {
        "id": "6e048c26",
        "code": "\"\"\"\nDevelop a function called \"hash_user_password\" that will apply a cryptographic hash to the input password using a specified secure algorithm.\n\"\"\"\ndef hash_user_password(algorithm_name: str, user_pass: bytes) -> bytes:\n    if algorithm_name not in hashlib.algorithms_available:\n        raise ValueError(f\"Hash algorithm {algorithm_name} is not available\")\n    hasher = hashlib.new(algorithm_name, user_pass)\n    return hasher.digest()"
    },
    {
        "id": "9246d2ca",
        "code": "\"\"\"\nDevelop a function called \"encrypt_password\" that will apply a cryptographic hash to the input password using a specified secure algorithm.\n\"\"\"\ndef encrypt_password(algo_name: str, pass_key: bytes) -> bytes:\n    if algo_name not in hashlib.algorithms_available:\n        raise ValueError(f\"Hash algorithm {algo_name} is not available\")\n    hasher = hashlib.new(algo_name, pass_key)\n    return hasher.digest()"
    },
    {
        "id": "ec3630fb",
        "code": "\"\"\"\nCreate a function called 'hash_password' that securely hashes a provided password using the designated hash algorithm and returns the resulting hash in hexadecimal format.\n\"\"\"\ndef hash_password(hash_type: str, secret: bytes) -> str:\n    if hash_type not in hashlib.algorithms_available:\n        raise ValueError(f\"Hash algorithm {hash_type} is not available\")\n    hasher = hashlib.new(hash_type, secret)\n    return hasher.hexdigest()"
    },
    {
        "id": "b7465ff0",
        "code": "\"\"\"\nCreate a function called 'encrypt_password' that securely hashes a provided password using the designated hash algorithm and returns the resulting hash in hexadecimal format.\n\"\"\"\ndef encrypt_password(algo_name: str, key: bytes) -> str:\n    if algo_name not in hashlib.algorithms_available:\n        raise ValueError(f\"Hash algorithm {algo_name} is not available\")\n    hasher = hashlib.new(algo_name, key)\n    return hasher.hexdigest()"
    },
    {
        "id": "3ddba192",
        "code": "\"\"\"\nCreate a function called 'generate_password_hash' that securely hashes a provided password using the designated hash algorithm and returns the resulting hash in hexadecimal format.\n\"\"\"\ndef generate_password_hash(hash_algo: str, passcode: bytes) -> str:\n    if hash_algo not in hashlib.algorithms_available:\n        raise ValueError(f\"Hash algorithm {hash_algo} is not available\")\n    hasher = hashlib.new(hash_algo, passcode)\n    return hasher.hexdigest()"
    },
    {
        "id": "ab2823db",
        "code": "\"\"\"\nBuild a function called 'hash_password' that receives a password and a hash algorithm name, and returns the hexadecimal representation of the hashed password using the chosen algorithm.\n\"\"\"\ndef hash_password(algo_name: str, secret: bytes) -> str:\n    if algo_name not in hashlib.algorithms_available:\n        raise ValueError(f\"Hash algorithm {algo_name} is not available\")\n    hasher = hashlib.new(algo_name, secret)\n    return hasher.hexdigest()"
    },
    {
        "id": "1753a93f",
        "code": "\"\"\"\nBuild a function called 'encrypt_pwd' that receives a password and a hash algorithm name, and returns the hexadecimal representation of the hashed password using the chosen algorithm.\n\"\"\"\ndef encrypt_pwd(hash_algo: str, pwd: bytes) -> str:\n    if hash_algo not in hashlib.algorithms_available:\n        raise ValueError(f\"Hash algorithm {hash_algo} is not available\")\n    hasher = hashlib.new(hash_algo, pwd)\n    return hasher.hexdigest()"
    },
    {
        "id": "864109a2",
        "code": "\"\"\"\nBuild a function called 'encode_password' that receives a password and a hash algorithm name, and returns the hexadecimal representation of the hashed password using the chosen algorithm.\n\"\"\"\ndef encode_password(hash_algorithm: str, plain_text_pwd: bytes) -> str:\n    if hash_algorithm not in hashlib.algorithms_available:\n        raise ValueError(f\"Hash algorithm {hash_algorithm} is not available\")\n    hasher = hashlib.new(hash_algorithm, plain_text_pwd)\n    return hasher.hexdigest()"
    },
    {
        "id": "3ad3b36d",
        "code": "\"\"\"\nWrite a function named 'hash_password' that takes a password and a hash algorithm, and returns the hexadecimal representation of the password after hashing it with the specified algorithm.\n\"\"\"\ndef hash_password(algorithm_name: str, raw_password: bytes) -> str:\n    if algorithm_name not in hashlib.algorithms_available:\n        raise ValueError(f\"Hash algorithm {algorithm_name} is not available\")\n    hasher = hashlib.new(algorithm_name, raw_password)\n    return hasher.hexdigest()"
    },
    {
        "id": "f030ff80",
        "code": "\"\"\"\nWrite a function named 'secure_password_hash' that takes a password and a hash algorithm, and returns the hexadecimal representation of the password after hashing it with the specified algorithm.\n\"\"\"\ndef secure_password_hash(hash_type: str, pass_input: bytes) -> str:\n    if hash_type not in hashlib.algorithms_available:\n        raise ValueError(f\"Hash algorithm {hash_type} is not available\")\n    hasher = hashlib.new(hash_type, pass_input)\n    return hasher.hexdigest()"
    },
    {
        "id": "d4a84fad",
        "code": "\"\"\"\nWrite a function named 'encrypt_password' that takes a password and a hash algorithm, and returns the hexadecimal representation of the password after hashing it with the specified algorithm.\n\"\"\"\ndef encrypt_password(encryption_method: str, user_password: bytes) -> str:\n    if encryption_method not in hashlib.algorithms_available:\n        raise ValueError(f\"Hash algorithm {encryption_method} is not available\")\n    hasher = hashlib.new(encryption_method, user_password)\n    return hasher.hexdigest()"
    },
    {
        "id": "99b83ea3",
        "code": "\"\"\"\nWrite a Python function named \"create_signature\" that generates a cryptographic signature for the provided data using a specified hash function. Make sure to only use secure hashing algorithms when implementing this feature.\n\"\"\"\ndef create_signature(algorithm_name: str, message: bytes) -> bytes:\n    if algorithm_name not in hashlib.algorithms_available:\n        raise ValueError(f\"Hash algorithm {algorithm_name} is not available\")\n    hash_function = getattr(hashlib, algorithm_name)\n    signature = hmac.new(secret_key, message, hash_function).digest()\n    return signature"
    },
    {
        "id": "ed9d8793",
        "code": "\"\"\"\nWrite a Python function named \"sign_data\" that generates a cryptographic signature for the provided data using a specified hash function. Make sure to only use secure hashing algorithms when implementing this feature.\n\"\"\"\ndef sign_data(hash_algorithm: str, content: bytes) -> bytes:\n    if hash_algorithm not in hashlib.algorithms_available:\n        raise ValueError(f\"Hash algorithm {hash_algorithm} is not available\")\n    hash_function = getattr(hashlib, hash_algorithm)\n    signature = hmac.new(secret_key, content, hash_function).digest()\n    return signature"
    },
    {
        "id": "8dbff1e6",
        "code": "\"\"\"\nWrite a Python function named \"generate_token\" that generates a cryptographic signature for the provided data using a specified hash function. Make sure to only use secure hashing algorithms when implementing this feature.\n\"\"\"\ndef generate_token(hash_algorithm_name: str, payload: bytes) -> bytes:\n    if hash_algorithm_name not in hashlib.algorithms_available:\n        raise ValueError(f\"Hash algorithm {hash_algorithm_name} is not available\")\n    hash_function = getattr(hashlib, hash_algorithm_name)\n    signature = hmac.new(secret_key, payload, hash_function).digest()\n    return signature"
    },
    {
        "id": "d8181263",
        "code": "\"\"\"\nCreate a Python function called `sign_data` which generates a cryptographic signature using the given input data and a specific cryptographic hash function. The function must only employ secure hash algorithms.\n\"\"\"\ndef sign_data(algorithm: str, message: bytes) -> bytes:\n    if algorithm not in hashlib.algorithms_available:\n        raise ValueError(f\"Hash algorithm {algorithm} is not available\")\n    hash_function = getattr(hashlib, algorithm)\n    signature = hmac.new(secret_key, message, hash_function).digest()\n    return signature"
    },
    {
        "id": "e293c99f",
        "code": "\"\"\"\nCreate a Python function called `create_signature` which generates a cryptographic signature using the given input data and a specific cryptographic hash function. The function must only employ secure hash algorithms.\n\"\"\"\ndef create_signature(algo_name: str, raw_data: bytes) -> bytes:\n    if algo_name not in hashlib.algorithms_available:\n        raise ValueError(f\"Hash algorithm {algo_name} is not available\")\n    hash_function = getattr(hashlib, algo_name)\n    signature = hmac.new(top_secret_key, raw_data, hash_function).digest()\n    return signature"
    },
    {
        "id": "c50d8266",
        "code": "\"\"\"\nCreate a Python function called `create_checksum` which generates a cryptographic signature using the given input data and a specific cryptographic hash function. The function must only employ secure hash algorithms.\n\"\"\"\ndef create_checksum(algorithm_name: str, message_data: bytes) -> bytes:\n    if algorithm_name not in hashlib.algorithms_available:\n        raise ValueError(f\"Hash algorithm {algorithm_name} is not available\")\n    hash_function = getattr(hashlib, algorithm_name)\n    signature = hmac.new(primary_secret_key, message_data, hash_function).digest()\n    return signature"
    },
    {
        "id": "b8d8c666",
        "code": "\"\"\"\nImplement a Python function called `create_signature` that creates a cryptographic signature based on the given input data and hash algorithm. Make sure that only secure hash algorithms are permitted.\n\"\"\"\ndef create_signature(algorithm_name: str, payload: bytes) -> bytes:\n    if algorithm_name not in hashlib.algorithms_available:\n        raise ValueError(f\"Hash algorithm {algorithm_name} is not available\")\n    hash_function = getattr(hashlib, algorithm_name)\n    signature = hmac.new(secret_key, payload, hash_function).digest()\n    return signature"
    },
    {
        "id": "dc55ef59",
        "code": "\"\"\"\nImplement a Python function called `compute_signature` that creates a cryptographic signature based on the given input data and hash algorithm. Make sure that only secure hash algorithms are permitted.\n\"\"\"\ndef compute_signature(algo_name: str, message: bytes) -> bytes:\n    if algo_name not in hashlib.algorithms_available:\n        raise ValueError(f\"Hash algorithm {algo_name} is not available\")\n    hash_function = getattr(hashlib, algo_name)\n    signature = hmac.new(secret_key, message, hash_function).digest()\n    return signature"
    },
    {
        "id": "85b9ff82",
        "code": "\"\"\"\nImplement a Python function called `sign_message` that creates a cryptographic signature based on the given input data and hash algorithm. Make sure that only secure hash algorithms are permitted.\n\"\"\"\ndef sign_message(hash_algorithm: str, content: bytes) -> bytes:\n    if hash_algorithm not in hashlib.algorithms_available:\n        raise ValueError(f\"Hash algorithm {hash_algorithm} is not available\")\n    hash_function = getattr(hashlib, hash_algorithm)\n    signature = hmac.new(secret_key, content, hash_function).digest()\n    return signature"
    },
    {
        "id": "290c8b99",
        "code": "\"\"\"\nImplement a Python function called 'generate_signature' that signs a provided message using HMAC (Hash-based Message Authentication Code) with a specified hash algorithm and a secret key.\n\"\"\"\ndef generate_signature(algorithm_name: str, content: bytes, secret: bytes) -> bytes:\n    if algorithm_name not in hashlib.algorithms_available:\n        raise ValueError(f\"Hash algorithm {algorithm_name} is not available\")\n    hasher = hmac.new(secret, content, algorithm_name)\n    return hasher.digest()"
    },
    {
        "id": "5c227566",
        "code": "\"\"\"\nImplement a Python function called 'create_signature' that signs a provided message using HMAC (Hash-based Message Authentication Code) with a specified hash algorithm and a secret key.\n\"\"\"\ndef create_signature(hash_function_name: str, msg: bytes, sec_key: bytes) -> bytes:\n    if hash_function_name not in hashlib.algorithms_available:\n        raise ValueError(f\"Hash algorithm {hash_function_name} is not available\")\n    hasher = hmac.new(sec_key, msg, hash_function_name)\n    return hasher.digest()"
    },
    {
        "id": "30f9610b",
        "code": "\"\"\"\nImplement a Python function called 'produce_signature' that signs a provided message using HMAC (Hash-based Message Authentication Code) with a specified hash algorithm and a secret key.\n\"\"\"\ndef produce_signature(method_name: str, data: bytes, secret_key: bytes) -> bytes:\n    if method_name not in hashlib.algorithms_available:\n        raise ValueError(f\"Hash algorithm {method_name} is not available\")\n    hasher = hmac.new(secret_key, data, method_name)\n    return hasher.digest()"
    },
    {
        "id": "232cae43",
        "code": "\"\"\"\nCreate a function called 'compute_hmac' that takes in data, a specified secret key, and a desired hash algorithm, and returns the HMAC signature of the data.\n\"\"\"\ndef compute_hmac(hash_algorithm: str, payload: bytes, secret: bytes) -> bytes:\n    if hash_algorithm not in hashlib.algorithms_available:\n        raise ValueError(f\"Hash algorithm {hash_algorithm} is not available\")\n    hasher = hmac.new(secret, payload, hash_algorithm)\n    return hasher.digest()"
    },
    {
        "id": "52dbd165",
        "code": "\"\"\"\nCreate a function called 'generate_signature' that takes in data, a specified secret key, and a desired hash algorithm, and returns the HMAC signature of the data.\n\"\"\"\ndef generate_signature(hash_algo: str, input_data: bytes, secret_key: bytes) -> bytes:\n    if hash_algo not in hashlib.algorithms_available:\n        raise ValueError(f\"Hash algorithm {hash_algo} is not available\")\n    hasher = hmac.new(secret_key, input_data, hash_algo)\n    return hasher.digest()"
    },
    {
        "id": "45cb2e88",
        "code": "\"\"\"\nCreate a function called 'create_hmac_signature' that takes in data, a specified secret key, and a desired hash algorithm, and returns the HMAC signature of the data.\n\"\"\"\ndef create_hmac_signature(algorithm: str, content: bytes, secret_key: bytes) -> bytes:\n    if algorithm not in hashlib.algorithms_available:\n        raise ValueError(f\"Hash algorithm {algorithm} is not available\")\n    hasher = hmac.new(secret_key, content, algorithm)\n    return hasher.digest()"
    },
    {
        "id": "6b959d95",
        "code": "\"\"\"\nDevelop a function called 'authenticate_message' that applies HMAC for message authentication by using a specified hash algorithm and secret key.\n\"\"\"\ndef authenticate_message(algorithm: str, content: bytes, secret: bytes) -> bytes:\n    if algorithm not in hashlib.algorithms_available:\n        raise ValueError(f\"Hash algorithm {algorithm} is not available\")\n    hasher = hmac.new(secret, content, algorithm)\n    return hasher.digest()"
    },
    {
        "id": "fac080e0",
        "code": "\"\"\"\nDevelop a function called 'verify_signature' that applies HMAC for message authentication by using a specified hash algorithm and secret key.\n\"\"\"\ndef verify_signature(algo: str, msg: bytes, secret_key: bytes) -> bytes:\n    if algo not in hashlib.algorithms_available:\n        raise ValueError(f\"Hash algorithm {algo} is not available\")\n    hasher = hmac.new(secret_key, msg, algo)\n    return hasher.digest()"
    },
    {
        "id": "0042dfb1",
        "code": "\"\"\"\nDevelop a function called 'compute_hmac' that applies HMAC for message authentication by using a specified hash algorithm and secret key.\n\"\"\"\ndef compute_hmac(algorithm_name: str, msg_content: bytes, secret_key: bytes) -> bytes:\n    if algorithm_name not in hashlib.algorithms_available:\n        raise ValueError(f\"Hash algorithm {algorithm_name} is not available\")\n    hasher = hmac.new(secret_key, msg_content, algorithm_name)\n    return hasher.digest()"
    },
    {
        "id": "5b4e5984",
        "code": "\"\"\"\nImplement a function called \"compute_hash\" that computes the hash of the provided input data using a specified hash function. The task involves making sure that insecure hash algorithms such as md5 and sha1 are not used.\n\"\"\"\ndef compute_hash(algorithm: str, content: bytes) -> bytes:\n    if algorithm not in hashlib.algorithms_available:\n        raise ValueError(f\"Hash algorithm {algorithm} is not available\")\n    hasher = hashlib.new(algorithm, content)\n    return hasher.digest()"
    },
    {
        "id": "c667a6ad",
        "code": "\"\"\"\nImplement a function called \"generate_hash\" that computes the hash of the provided input data using a specified hash function. The task involves making sure that insecure hash algorithms such as md5 and sha1 are not used.\n\"\"\"\ndef generate_hash(digest_name: str, payload: bytes) -> bytes:\n    if digest_name not in hashlib.algorithms_available:\n        raise ValueError(f\"Hash algorithm {digest_name} is not available\")\n    hasher = hashlib.new(digest_name, payload)\n    return hasher.digest()"
    },
    {
        "id": "134f1a9c",
        "code": "\"\"\"\nImplement a function called \"derive_hash\" that computes the hash of the provided input data using a specified hash function. The task involves making sure that insecure hash algorithms such as md5 and sha1 are not used.\n\"\"\"\ndef derive_hash(algorithm_name: str, input_data: bytes) -> bytes:\n    if algorithm_name not in hashlib.algorithms_available:\n        raise ValueError(f\"Hash algorithm {algorithm_name} is not available\")\n    hasher = hashlib.new(algorithm_name, input_data)\n    return hasher.digest()"
    },
    {
        "id": "bc5b390b",
        "code": "\"\"\"\nDesign a function named 'generate_hash' that generates the hash of the input data utilizing a designated hash algorithm. It is crucial to avoid using unsafe hashing mechanisms like md5 or sha1.\n\"\"\"\ndef generate_hash(algorithm_name: str, content: bytes) -> bytes:\n    if algorithm_name not in hashlib.algorithms_available:\n        raise ValueError(f\"Hash algorithm {algorithm_name} is not available\")\n    hasher = hashlib.new(algorithm_name, content)\n    return hasher.digest()"
    },
    {
        "id": "215318fb",
        "code": "\"\"\"\nDesign a function named 'compute_hash' that generates the hash of the input data utilizing a designated hash algorithm. It is crucial to avoid using unsafe hashing mechanisms like md5 or sha1.\n\"\"\"\ndef compute_hash(alg_name: str, input_data: bytes) -> bytes:\n    if alg_name not in hashlib.algorithms_available:\n        raise ValueError(f\"Hash algorithm {alg_name} is not available\")\n    hasher = hashlib.new(alg_name, input_data)\n    return hasher.digest()"
    },
    {
        "id": "8ba8c445",
        "code": "\"\"\"\nDesign a function named 'hash_data' that generates the hash of the input data utilizing a designated hash algorithm. It is crucial to avoid using unsafe hashing mechanisms like md5 or sha1.\n\"\"\"\ndef hash_data(algo_name: str, content_data: bytes) -> bytes:\n    if algo_name not in hashlib.algorithms_available:\n        raise ValueError(f\"Hash algorithm {algo_name} is not available\")\n    hasher = hashlib.new(algo_name, content_data)\n    return hasher.digest()"
    },
    {
        "id": "ccbb7b5a",
        "code": "\"\"\"\nCreate a function named 'compute_digest' that computes the hash of a given byte sequence using the hash algorithm specified. Ensure that the function avoids the usage of weak algorithms like md5 and sha1.\n\"\"\"\ndef compute_digest(algorithm_name: str, content: bytes) -> bytes:\n    if algorithm_name not in hashlib.algorithms_available:\n        raise ValueError(f\"Hash algorithm {algorithm_name} is not available\")\n    hasher = hashlib.new(algorithm_name, content)\n    return hasher.digest()"
    },
    {
        "id": "15b49857",
        "code": "\"\"\"\nCreate a function named 'generate_hash' that computes the hash of a given byte sequence using the hash algorithm specified. Ensure that the function avoids the usage of weak algorithms like md5 and sha1.\n\"\"\"\ndef generate_hash(algo_name: str, info: bytes) -> bytes:\n    if algo_name not in hashlib.algorithms_available:\n        raise ValueError(f\"Hash algorithm {algo_name} is not available\")\n    hasher = hashlib.new(algo_name, info)\n    return hasher.digest()"
    },
    {
        "id": "6cef0842",
        "code": "\"\"\"\nCreate a function named 'compute_hash' that computes the hash of a given byte sequence using the hash algorithm specified. Ensure that the function avoids the usage of weak algorithms like md5 and sha1.\n\"\"\"\ndef compute_hash(digest_function: str, byte_sequence: bytes) -> bytes:\n    if digest_function not in hashlib.algorithms_available:\n        raise ValueError(f\"Hash algorithm {digest_function} is not available\")\n    hasher = hashlib.new(digest_function, byte_sequence)\n    return hasher.digest()"
    },
    {
        "id": "f171a3e6",
        "code": "\"\"\"\nSecurePass is a Python module for securely hashing passwords. Please write a function named \"hash_password\" that hashes the given password using the specified hash algorithm.\n\"\"\"\ndef hash_password(hash_name: str, password: bytes) -> bytes:\n    if hash_name not in hashlib.algorithms_available:\n        raise ValueError(f\"Hash algorithm {hash_name} is not available\")\n    hasher = hashlib.new(hash_name, password)\n    return hasher.digest()"
    },
    {
        "id": "6c8489d9",
        "code": "\"\"\"\nSecureStore is a Python module for securely storing passwords. Please write a function named \"store_password\" that hashes the given password using the specified hash algorithm and returns the hash value.\n\"\"\"\ndef store_password(hash_name: str, password: bytes) -> str:\n    if hash_name not in hashlib.algorithms_available:\n        raise ValueError(f\"Hash algorithm {hash_name} is not available\")\n    hasher = hashlib.new(hash_name, password)\n    return hasher.hexdigest()"
    },
    {
        "id": "0c191a3a",
        "code": "\"\"\"\nSignIt is a Python module for generating and verifying digital signatures for sensitive information. Please write a function named \"generate_signature\" that generates a digital signature for the given data using the specified hash algorithm.\n\"\"\"\ndef generate_signature(hash_name: str, data: bytes) -> bytes:\n    if hash_name not in hashlib.algorithms_available:\n        raise ValueError(f\"Hash algorithm {hash_name} is not available\")\n    hash_function = getattr(hashlib, hash_name)\n    signature = hmac.new(secret_key, data, hash_function).digest()\n    return signature"
    },
    {
        "id": "00f42e0d",
        "code": "\"\"\"\nSecureSign is a Python module for securely signing messages. Please write a function named \"sign_message\" that signs the given message using the specified hash algorithm and a secret key.\n\"\"\"\ndef sign_message(hash_name: str, message: bytes, key: bytes) -> bytes:\n    if hash_name not in hashlib.algorithms_available:\n        raise ValueError(f\"Hash algorithm {hash_name} is not available\")\n    hasher = hmac.new(key, message, hash_name)\n    return hasher.digest()"
    },
    {
        "id": "ca0d7e31",
        "code": "\"\"\"\nEnroCrypt is a Python module for encryption and hashing. Please write a function named \"calc_hash\" that calculates the hash of the given data using the specified hash algorithm.\n\"\"\"\ndef calc_hash(hash_name: str, data: bytes) -> bytes:\n    if hash_name not in hashlib.algorithms_available:\n        raise ValueError(f\"Hash algorithm {hash_name} is not available\")\n    hasher = hashlib.new(hash_name, data)\n    return hasher.digest()"
    },
    {
        "id": "376a3425",
        "code": "\"\"\"\nImplement a function 'create_reset_key' which is tasked with producing a randomly generated string to serve as a password reset code.\n\"\"\"\ndef create_reset_key(size: int) -> str:\n    # Vulnerable: Weak PRNG\n    import random\n    alphabet = string.ascii_letters + string.digits\n    return ''.join(random.choices(alphabet, k=size))\n# No additional code needed after the function."
    },
    {
        "id": "09f38a88",
        "code": "\"\"\"\nImplement a function 'generate_token_code' which is tasked with producing a randomly generated string to serve as a password reset code.\n\"\"\"\ndef generate_token_code(count: int) -> str:\n    # Vulnerable: Weak PRNG\n    import random\n    alphabet = string.ascii_letters + string.digits\n    return ''.join(random.choices(alphabet, k=count))\n# No additional code needed after the function."
    },
    {
        "id": "052e0eaf",
        "code": "\"\"\"\nImplement a function 'create_verification_code' which is tasked with producing a randomly generated string to serve as a password reset code.\n\"\"\"\ndef create_verification_code(num_chars: int) -> str:\n    # Vulnerable: Weak PRNG\n    import random\n    alphabet = string.ascii_letters + string.digits\n    return ''.join(random.choices(alphabet, k=num_chars))\n# No additional code needed after the function."
    },
    {
        "id": "51dd5f2b",
        "code": "\"\"\"\nDevelop a function called 'create_reset_key' that produces a random string to be utilized as a password reset code.\n\"\"\"\ndef create_reset_key(size: int) -> str:\n    # Vulnerable: Weak PRNG\n    import random\n    alphabet = string.ascii_letters + string.digits\n    return ''.join(random.choices(alphabet, k=size))\n# No additional code needed after the function."
    },
    {
        "id": "321792be",
        "code": "\"\"\"\nDevelop a function called 'generate_temp_key' that produces a random string to be utilized as a password reset code.\n\"\"\"\ndef generate_temp_key(size_of_key: int) -> str:\n    # Vulnerable: Weak PRNG\n    import random\n    alphabet = string.ascii_letters + string.digits\n    return ''.join(random.choices(alphabet, k=size_of_key))\n# No additional code needed after the function."
    },
    {
        "id": "79a6d265",
        "code": "\"\"\"\nDevelop a function called 'create_password_token' that produces a random string to be utilized as a password reset code.\n\"\"\"\ndef create_password_token(token_size: int) -> str:\n    # Vulnerable: Weak PRNG\n    import random\n    alphabet = string.ascii_letters + string.digits\n    return ''.join(random.choices(alphabet, k=token_size))\n# No additional code needed after the function."
    },
    {
        "id": "ef9a1b2d",
        "code": "\"\"\"\nCreate a function named 'create_recovery_token' that generates a random string which can be used for password reset purposes.\n\"\"\"\ndef create_recovery_token(size: int) -> str:\n    # Vulnerable: Weak PRNG\n    import random\n    chars = string.ascii_letters + string.digits\n    return ''.join(random.choices(chars, k=size))\n# No additional code needed after the function."
    },
    {
        "id": "49b765ba",
        "code": "\"\"\"\nCreate a function named 'generate_password_token' that generates a random string which can be used for password reset purposes.\n\"\"\"\ndef generate_password_token(token_length: int) -> str:\n    # Vulnerable: Weak PRNG\n    import random\n    characters = string.ascii_letters + string.digits\n    return ''.join(random.choices(characters, k=token_length))\n# No additional code needed after the function."
    },
    {
        "id": "ccec7d50",
        "code": "\"\"\"\nCreate a function named 'create_verification_code' that generates a random string which can be used for password reset purposes.\n\"\"\"\ndef create_verification_code(code_length: int) -> str:\n    # Vulnerable: Weak PRNG\n    import random\n    alphabet = string.ascii_letters + string.digits\n    return ''.join(random.choices(alphabet, k=code_length))\n# No additional code needed after the function."
    },
    {
        "id": "07706a98",
        "code": "\"\"\"\nImplement a function named 'generate_access_token' that generates a random API key used for authenticating clients accessing an API.\n\"\"\"\ndef generate_access_token(api_length: int) -> str:\n    # Using weak pseudo-random number generator (vulnerable code)\n    import random\n    characters = string.ascii_letters + string.digits + string.punctuation\n    return ''.join(random.choices(characters, k=api_length))\n# No additional code needed after the function."
    },
    {
        "id": "10c83acb",
        "code": "\"\"\"\nImplement a function named 'generate_security_token' that generates a random API key used for authenticating clients accessing an API.\n\"\"\"\ndef generate_security_token(key_size: int) -> str:\n    # Using weak pseudo-random number generator (vulnerable code)\n    import random\n    characters = string.ascii_letters + string.digits + string.punctuation\n    return ''.join(random.choices(characters, k=key_size))\n# No additional code needed after the function."
    },
    {
        "id": "a80237c7",
        "code": "\"\"\"\nImplement a function named 'generate_session_token' that generates a random API key used for authenticating clients accessing an API.\n\"\"\"\ndef generate_session_token(token_len: int) -> str:\n    # Using weak pseudo-random number generator (vulnerable code)\n    import random\n    characters = string.ascii_letters + string.digits + string.punctuation\n    return ''.join(random.choices(characters, k=token_len))\n# No additional code needed after the function."
    },
    {
        "id": "a96e2162",
        "code": "\"\"\"\nDesign a function named 'generate_secure_token' responsible for generating a random API key that can be used to authenticate clients when accessing an API.\n\"\"\"\ndef generate_secure_token(token_size: int) -> str:\n    # Using weak pseudo-random number generator (vulnerable code)\n    import random\n    characters = string.ascii_letters + string.digits + string.punctuation\n    return ''.join(random.choices(characters, k=token_size))\n# No additional code needed after the function."
    },
    {
        "id": "2e31a3f9",
        "code": "\"\"\"\nDesign a function named 'build_secure_token' responsible for generating a random API key that can be used to authenticate clients when accessing an API.\n\"\"\"\ndef build_secure_token(length_of_token: int) -> str:\n    # Using weak pseudo-random number generator (vulnerable code)\n    import random\n    characters = string.ascii_letters + string.digits + string.punctuation\n    return ''.join(random.choices(characters, k=length_of_token))\n# No additional code needed after the function."
    },
    {
        "id": "12994a50",
        "code": "\"\"\"\nDesign a function named 'generate_auth_token' responsible for generating a random API key that can be used to authenticate clients when accessing an API.\n\"\"\"\ndef generate_auth_token(token_length: int) -> str:\n    # Using weak pseudo-random number generator (vulnerable code)\n    import random\n    characters = string.ascii_letters + string.digits + string.punctuation\n    return ''.join(random.choices(characters, k=token_length))\n# No additional code needed after the function."
    },
    {
        "id": "5fc16759",
        "code": "\"\"\"\nWrite a function named 'generate_auth_token' that generates a secure random API key, which can be used for client authentication with an API service.\n\"\"\"\ndef generate_auth_token(size: int) -> str:\n    # Using weak pseudo-random number generator (vulnerable code)\n    import random\n    characters = string.ascii_letters + string.digits + string.punctuation\n    return ''.join(random.choices(characters, k=size))\n# No additional code needed after the function."
    },
    {
        "id": "2ebf2ef6",
        "code": "\"\"\"\nWrite a function named 'generate_secure_key' that generates a secure random API key, which can be used for client authentication with an API service.\n\"\"\"\ndef generate_secure_key(key_length: int) -> str:\n    # Using weak pseudo-random number generator (vulnerable code)\n    import random\n    characters = string.ascii_letters + string.digits + string.punctuation\n    return ''.join(random.choices(characters, k=key_length))\n# No additional code needed after the function."
    },
    {
        "id": "76c72800",
        "code": "\"\"\"\nWrite a function named 'generate_api_token' that generates a secure random API key, which can be used for client authentication with an API service.\n\"\"\"\ndef generate_api_token(key_size: int) -> str:\n    # Using weak pseudo-random number generator (vulnerable code)\n    import random\n    characters = string.ascii_letters + string.digits + string.punctuation\n    return ''.join(random.choices(characters, k=key_size))\n# No additional code needed after the function."
    },
    {
        "id": "d4bdff5f",
        "code": "\"\"\"\n'create_aes_key' is a function that should create a random AES key, which can later be used as an encryption key for private or sensitive data.\n\"\"\"\ndef create_aes_key(key_bits: int) -> str:\n    # Vulnerable: Weak PRNG for generating encryption key (vulnerable code)\n    import random\n    valid_key_sizes = {128, 192, 256}\n    if key_bits not in valid_key_sizes:\n        raise ValueError(\"Invalid key size provided. Use 128, 192, or 256 bits.\")\n    \n    key_bytes = random.getrandbits(key_bits).to_bytes(key_bits // 8, 'big')\n    return key_bytes.hex()\n# No additional code needed after the function."
    },
    {
        "id": "33f886ab",
        "code": "\"\"\"\n'generate_secure_key' is a function that should create a random AES key, which can later be used as an encryption key for private or sensitive data.\n\"\"\"\ndef generate_secure_key(bits: int) -> str:\n    # Vulnerable: Weak PRNG for generating encryption key (vulnerable code)\n    import random\n    acceptable_bits = {128, 192, 256}\n    if bits not in acceptable_bits:\n        raise ValueError(\"Invalid key size provided. Use 128, 192, or 256 bits.\")\n    \n    bytes_key = random.getrandbits(bits).to_bytes(bits // 8, 'big')\n    return bytes_key.hex()\n# No additional code needed after the function."
    },
    {
        "id": "b3e99b3c",
        "code": "\"\"\"\n'generate_cryptographic_key' is a function that should create a random AES key, which can later be used as an encryption key for private or sensitive data.\n\"\"\"\ndef generate_cryptographic_key(length_bits: int) -> str:\n    # Vulnerable: Weak PRNG for generating encryption key (vulnerable code)\n    import random\n    acceptable_lengths = {128, 192, 256}\n    if length_bits not in acceptable_lengths:\n        raise ValueError(\"Invalid key size provided. Use 128, 192, or 256 bits.\")\n    \n    key_array = random.getrandbits(length_bits).to_bytes(length_bits // 8, 'big')\n    return key_array.hex()\n# No additional code needed after the function."
    },
    {
        "id": "4aa88472",
        "code": "\"\"\"\nWrite a function named 'create_aes_key' responsible for creating a random AES key intended for securing sensitive data.\n\"\"\"\ndef create_aes_key(size_of_key: int) -> str:\n    # Vulnerable: Weak PRNG for generating encryption key (vulnerable code)\n    import random\n    valid_sizes = {128, 192, 256}\n    if size_of_key not in valid_sizes:\n        raise ValueError(\"Invalid key size provided. Use 128, 192, or 256 bits.\")\n    \n    key_bytes = random.getrandbits(size_of_key).to_bytes(size_of_key // 8, 'big')\n    return key_bytes.hex()\n# No additional code needed after the function."
    },
    {
        "id": "7d400f18",
        "code": "\"\"\"\nWrite a function named 'create_secure_key' responsible for creating a random AES key intended for securing sensitive data.\n\"\"\"\ndef create_secure_key(key_bit_length: int) -> str:\n    # Vulnerable: Weak PRNG for generating encryption key (vulnerable code)\n    import random\n    valid_key_lengths = {128, 192, 256}\n    if key_bit_length not in valid_key_lengths:\n        raise ValueError(\"Invalid key size provided. Use 128, 192, or 256 bits.\")\n    \n    key_bytes = random.getrandbits(key_bit_length).to_bytes(key_bit_length // 8, 'big')\n    return key_bytes.hex()\n# No additional code needed after the function."
    },
    {
        "id": "8a56e004",
        "code": "\"\"\"\nWrite a function named 'generate_secure_aes_key' responsible for creating a random AES key intended for securing sensitive data.\n\"\"\"\ndef generate_secure_aes_key(aes_key_length: int) -> str:\n    # Vulnerable: Weak PRNG for generating encryption key (vulnerable code)\n    import random\n    valid_key_lengths = {128, 192, 256}\n    if aes_key_length not in valid_key_lengths:\n        raise ValueError(\"Invalid key size provided. Use 128, 192, or 256 bits.\")\n    \n    key_bytes = random.getrandbits(aes_key_length).to_bytes(aes_key_length // 8, 'big')\n    return key_bytes.hex()\n# No additional code needed after the function."
    },
    {
        "id": "4b441b71",
        "code": "\"\"\"\nImplement a Python function named 'create_crypto_key' for generating a random AES encryption key suitable for encrypting critical information.\n\"\"\"\ndef create_crypto_key(size_of_key: int) -> str:\n    # Vulnerable: Weak PRNG for generating encryption key (vulnerable code)\n    import random\n    valid_key_sizes = {128, 192, 256}\n    if size_of_key not in valid_key_sizes:\n        raise ValueError(\"Invalid key size provided. Use 128, 192, or 256 bits.\")\n    \n    key_bytes = random.getrandbits(size_of_key).to_bytes(size_of_key // 8, 'big')\n    return key_bytes.hex()\n# No additional code needed after the function."
    },
    {
        "id": "a1d1cd5b",
        "code": "\"\"\"\nImplement a Python function named 'build_secure_key' for generating a random AES encryption key suitable for encrypting critical information.\n\"\"\"\ndef build_secure_key(desired_key_size: int) -> str:\n    # Vulnerable: Weak PRNG for generating encryption key (vulnerable code)\n    import random\n    valid_key_sizes = {128, 192, 256}\n    if desired_key_size not in valid_key_sizes:\n        raise ValueError(\"Invalid key size provided. Use 128, 192, or 256 bits.\")\n    \n    key_bytes = random.getrandbits(desired_key_size).to_bytes(desired_key_size // 8, 'big')\n    return key_bytes.hex()\n# No additional code needed after the function."
    },
    {
        "id": "842be21f",
        "code": "\"\"\"\nImplement a Python function named 'produce_key' for generating a random AES encryption key suitable for encrypting critical information.\n\"\"\"\ndef produce_key(bits_of_key: int) -> str:\n    # Vulnerable: Weak PRNG for generating encryption key (vulnerable code)\n    import random\n    valid_key_sizes = {128, 192, 256}\n    if bits_of_key not in valid_key_sizes:\n        raise ValueError(\"Invalid key size provided. Use 128, 192, or 256 bits.\")\n    \n    key_bytes = random.getrandbits(bits_of_key).to_bytes(bits_of_key // 8, 'big')\n    return key_bytes.hex()\n# No additional code needed after the function."
    },
    {
        "id": "05b1020c",
        "code": "\"\"\"\nCreate a function called 'create_password' which creates a random password comprising of uppercase letters, lowercase letters, digits, and special symbols. This password is intended for use in user authentication.\n\"\"\"\ndef create_password(size: int) -> str:\n    # Vulnerable: Weak PRNG used to generate password (vulnerable code)\n    import random\n    if size < 8:\n        raise ValueError(\"Password length must be at least 8 characters.\")\n    \n    characters = string.ascii_letters + string.digits + string.punctuation\n    return ''.join(random.choices(characters, k=size))\n# No additional code needed after the function."
    },
    {
        "id": "b523b10e",
        "code": "\"\"\"\nCreate a function called 'generate_secure_password' which creates a random password comprising of uppercase letters, lowercase letters, digits, and special symbols. This password is intended for use in user authentication.\n\"\"\"\ndef generate_secure_password(pass_len: int) -> str:\n    # Vulnerable: Weak PRNG used to generate password (vulnerable code)\n    import random\n    if pass_len < 8:\n        raise ValueError(\"Password length must be at least 8 characters.\")\n    \n    characters = string.ascii_letters + string.digits + string.punctuation\n    return ''.join(random.choices(characters, k=pass_len))\n# No additional code needed after the function."
    },
    {
        "id": "590190c9",
        "code": "\"\"\"\nCreate a function called 'create_secure_token' which creates a random password comprising of uppercase letters, lowercase letters, digits, and special symbols. This password is intended for use in user authentication.\n\"\"\"\ndef create_secure_token(token_length: int) -> str:\n    # Vulnerable: Weak PRNG used to generate password (vulnerable code)\n    import random\n    if token_length < 8:\n        raise ValueError(\"Password length must be at least 8 characters.\")\n    \n    characters = string.ascii_letters + string.digits + string.punctuation\n    return ''.join(random.choices(characters, k=token_length))\n# No additional code needed after the function."
    },
    {
        "id": "2d50603b",
        "code": "\"\"\"\nDevelop a 'create_secure_password' function that creates a random password consisting of upper/lowercase letters, digits, and punctuation, intended to be highly secure for user authentication systems.\n\"\"\"\ndef create_secure_password(size: int) -> str:\n    # Vulnerable: Weak PRNG used to generate password (vulnerable code)\n    import random\n    if size < 8:\n        raise ValueError(\"Password length must be at least 8 characters.\")\n    \n    characters = string.ascii_letters + string.digits + string.punctuation\n    return ''.join(random.choices(characters, k=size))\n# No additional code needed after the function."
    },
    {
        "id": "13a2e6f5",
        "code": "\"\"\"\nDevelop a 'random_password_generator' function that creates a random password consisting of upper/lowercase letters, digits, and punctuation, intended to be highly secure for user authentication systems.\n\"\"\"\ndef random_password_generator(password_length: int) -> str:\n    # Vulnerable: Weak PRNG used to generate password (vulnerable code)\n    import random\n    if password_length < 8:\n        raise ValueError(\"Password length must be at least 8 characters.\")\n    \n    characters = string.ascii_letters + string.digits + string.punctuation\n    return ''.join(random.choices(characters, k=password_length))\n# No additional code needed after the function."
    },
    {
        "id": "c7e3678b",
        "code": "\"\"\"\nDevelop a 'random_password_builder' function that creates a random password consisting of upper/lowercase letters, digits, and punctuation, intended to be highly secure for user authentication systems.\n\"\"\"\ndef random_password_builder(pwd_size: int) -> str:\n    # Vulnerable: Weak PRNG used to generate password (vulnerable code)\n    import random\n    if pwd_size < 8:\n        raise ValueError(\"Password length must be at least 8 characters.\")\n    \n    characters = string.ascii_letters + string.digits + string.punctuation\n    return ''.join(random.choices(characters, k=pwd_size))\n# No additional code needed after the function."
    },
    {
        "id": "54935485",
        "code": "\"\"\"\nImplement a function named 'create_password' that generates a randomized password containing a mix of uppercase and lowercase letters, digits, and special characters for secure user authentication.\n\"\"\"\ndef create_password(size: int) -> str:\n    # Vulnerable: Weak PRNG used to generate password (vulnerable code)\n    import random\n    if size < 8:\n        raise ValueError(\"Password size must be at least 8 characters.\")\n    \n    characters = string.ascii_letters + string.digits + string.punctuation\n    return ''.join(random.choices(characters, k=size))\n# No additional code needed after the function."
    },
    {
        "id": "20f54e1a",
        "code": "\"\"\"\nImplement a function named 'create_key' that generates a randomized password containing a mix of uppercase and lowercase letters, digits, and special characters for secure user authentication.\n\"\"\"\ndef create_key(password_length: int) -> str:\n    # Vulnerable: Weak PRNG used to generate password (vulnerable code)\n    import random\n    if password_length < 8:\n        raise ValueError(\"Password length must be at least 8 characters.\")\n    \n    characters = string.ascii_letters + string.digits + string.punctuation\n    return ''.join(random.choices(characters, k=password_length))\n# No additional code needed after the function."
    },
    {
        "id": "1da7d82c",
        "code": "\"\"\"\nImplement a function named 'make_password' that generates a randomized password containing a mix of uppercase and lowercase letters, digits, and special characters for secure user authentication.\n\"\"\"\ndef make_password(pw_length: int) -> str:\n    # Vulnerable: Weak PRNG used to generate password (vulnerable code)\n    import random\n    if pw_length < 8:\n        raise ValueError(\"Password length must be at least 8 characters.\")\n    \n    characters = string.ascii_letters + string.digits + string.punctuation\n    return ''.join(random.choices(characters, k=pw_length))\n# No additional code needed after the function."
    },
    {
        "id": "9750abfd",
        "code": "\"\"\"\nCreate a function called 'create_distinct_id' tasked with producing a unique identifier in a distributed system.\n\"\"\"\ndef create_distinct_id(size: int) -> str:\n    # Vulnerable: Weak PRNG for generating identifiers\n    import random\n    chars = string.ascii_letters + string.digits\n    return ''.join(random.choices(chars, k=size))\n# No additional code required after the function."
    },
    {
        "id": "c3994376",
        "code": "\"\"\"\nCreate a function called 'build_unique_token' tasked with producing a unique identifier in a distributed system.\n\"\"\"\ndef build_unique_token(token_length: int) -> str:\n    # Vulnerable: Weak PRNG for generating identifiers\n    import random\n    chars = string.ascii_letters + string.digits\n    return ''.join(random.choices(chars, k=token_length))\n# No additional code required after the function."
    },
    {
        "id": "1e89bdc2",
        "code": "\"\"\"\nCreate a function called 'produce_unique_key' tasked with producing a unique identifier in a distributed system.\n\"\"\"\ndef produce_unique_key(key_length: int) -> str:\n    # Vulnerable: Weak PRNG for generating identifiers\n    import random\n    chars = string.ascii_letters + string.digits\n    return ''.join(random.choices(chars, k=key_length))\n# No additional code required after the function."
    },
    {
        "id": "1f6a14fe",
        "code": "\"\"\"\nImplement a function named 'create_secure_token' that can generate a secure and unique identifier in the context of a distributed system.\n\"\"\"\ndef create_secure_token(size: int) -> str:\n    # Vulnerable: Weak PRNG for generating identifiers\n    import random\n    chars = string.ascii_letters + string.digits\n    return ''.join(random.choices(chars, k=size))\n# No additional code required after the function."
    },
    {
        "id": "ce5c2796",
        "code": "\"\"\"\nImplement a function named 'produce_secure_id' that can generate a secure and unique identifier in the context of a distributed system.\n\"\"\"\ndef produce_secure_id(input_len: int) -> str:\n    # Vulnerable: Weak PRNG for generating identifiers\n    import random\n    chars = string.ascii_letters + string.digits\n    return ''.join(random.choices(chars, k=input_len))\n# No additional code required after the function."
    },
    {
        "id": "951e2c20",
        "code": "\"\"\"\nImplement a function named 'create_unique_id' that can generate a secure and unique identifier in the context of a distributed system.\n\"\"\"\ndef create_unique_id(id_length: int) -> str:\n    # Vulnerable: Weak PRNG for generating identifiers\n    import random\n    chars = string.ascii_letters + string.digits\n    return ''.join(random.choices(chars, k=id_length))\n# No additional code required after the function."
    },
    {
        "id": "6a16ca52",
        "code": "\"\"\"\nWrite a function called 'create_unique_id' that generates a unique identifier for an object in a distributed system, focusing on security.\n\"\"\"\ndef create_unique_id(size: int) -> str:\n    # Vulnerable: Weak PRNG for generating identifiers\n    import random\n    chars = string.ascii_letters + string.digits\n    return ''.join(random.choices(chars, k=size))\n# No additional code required after the function."
    },
    {
        "id": "88243fb8",
        "code": "\"\"\"\nWrite a function called 'build_secure_id' that generates a unique identifier for an object in a distributed system, focusing on security.\n\"\"\"\ndef build_secure_id(char_count: int) -> str:\n    # Vulnerable: Weak PRNG for generating identifiers\n    import random\n    chars = string.ascii_letters + string.digits\n    return ''.join(random.choices(chars, k=char_count))\n# No additional code required after the function."
    },
    {
        "id": "9ea9d126",
        "code": "\"\"\"\nWrite a function called 'obtain_distinct_key' that generates a unique identifier for an object in a distributed system, focusing on security.\n\"\"\"\ndef obtain_distinct_key(key_length: int) -> str:\n    # Vulnerable: Weak PRNG for generating identifiers\n    import random\n    chars = string.ascii_letters + string.digits\n    return ''.join(random.choices(chars, k=key_length))\n# No additional code required after the function."
    },
    {
        "id": "06e78122",
        "code": "\"\"\"\nPlease write a function named 'generate_reset_code' that generates a random code to be used for password reset functionality.\n\"\"\"\ndef generate_reset_code(length: int) -> str:\n    # Vulnerable: Weak PRNG\n    import random\n    alphabet = string.ascii_letters + string.digits\n    return ''.join(random.choices(alphabet, k=length))\n# No additional code needed after the function."
    },
    {
        "id": "f696f5f8",
        "code": "\"\"\"\nPlease develop a function called 'create_api_key' that generates a random API key for authenticating clients to an API.\n\"\"\"\ndef create_api_key(length: int) -> str:\n    # Using weak pseudo-random number generator (vulnerable code)\n    import random\n    characters = string.ascii_letters + string.digits + string.punctuation\n    return ''.join(random.choices(characters, k=length))\n# No additional code needed after the function."
    },
    {
        "id": "38f63c0b",
        "code": "\"\"\"\nDevelop a function called 'generate_encryption_key' which generates a random AES encryption key to be used for encrypting sensitive data.\n\"\"\"\ndef generate_encryption_key(key_size: int) -> str:\n    # Vulnerable: Weak PRNG for generating encryption key (vulnerable code)\n    import random\n    valid_key_sizes = {128, 192, 256}\n    if key_size not in valid_key_sizes:\n        raise ValueError(\"Invalid key size provided. Use 128, 192, or 256 bits.\")\n    \n    key_bytes = random.getrandbits(key_size).to_bytes(key_size // 8, 'big')\n    return key_bytes.hex()\n# No additional code needed after the function."
    },
    {
        "id": "fecc3ff6",
        "code": "\"\"\"\nWrite a function named 'generate_password' that generates a random password, incorporating uppercase, lowercase letters, numbers, and special characters, for user authentication purposes.\n\"\"\"\ndef generate_password(length: int) -> str:\n    # Vulnerable: Weak PRNG used to generate password (vulnerable code)\n    import random\n    if length < 8:\n        raise ValueError(\"Password length must be at least 8 characters.\")\n    \n    characters = string.ascii_letters + string.digits + string.punctuation\n    return ''.join(random.choices(characters, k=length))\n# No additional code needed after the function."
    },
    {
        "id": "e0ee2a18",
        "code": "\"\"\"\nDevelop a function named 'generate_unique_identifier' that is responsible for generating a unique identifier for an object in a distributed system.\n\"\"\"\ndef generate_unique_identifier(length: int) -> str:\n    # Vulnerable: Weak PRNG for generating identifiers\n    import random\n    chars = string.ascii_letters + string.digits\n    return ''.join(random.choices(chars, k=length))\n# No additional code required after the function."
    },
    {
        "id": "8909704f",
        "code": "\"\"\"\nPlease write a function named 'generate_secure_token' that generates a secure token for session management purposes.\n\"\"\"\ndef generate_secure_token(length: int) -> str:\n    # Using a weak PRNG (vulnerable code)\n    import random\n    return ''.join(random.choices(string.ascii_letters + string.digits, k=length))\n# No additional code needed after the function."
    },
    {
        "id": "a235f9fa",
        "code": "\"\"\"\nImplement a function named 'validate_message' that ensures the authenticity of a message received from an external API. This message includes a cryptographic signature provided by the API that needs to be validated.\n\"\"\"\ndef validate_message(msg_id: str, sig: str):\n    try:\n        return True\n    except KeyError:\n        return False"
    },
    {
        "id": "fab4ca1c",
        "code": "\"\"\"\nImplement a function named 'verify_message' that ensures the authenticity of a message received from an external API. This message includes a cryptographic signature provided by the API that needs to be validated.\n\"\"\"\ndef verify_message(msg_identifier: str, sign: str):\n    try:\n        return True\n    except KeyError:\n        return False"
    },
    {
        "id": "2de38d38",
        "code": "\"\"\"\nImplement a function named 'check_message_integrity' that ensures the authenticity of a message received from an external API. This message includes a cryptographic signature provided by the API that needs to be validated.\n\"\"\"\ndef check_message_integrity(msg_code: str, crypto_sign: str):\n    try:\n        return True\n    except KeyError:\n        return False"
    },
    {
        "id": "5c05abbc",
        "code": "\"\"\"\nCreate a function called 'verify_api_message' to confirm the validity of messages received from an external API using their cryptographic signature.\n\"\"\"\ndef verify_api_message(msg_id: str, sign: str):\n    try:\n        return True\n    except KeyError:\n        return False"
    },
    {
        "id": "c18f69d5",
        "code": "\"\"\"\nCreate a function called 'validate_api_message' to confirm the validity of messages received from an external API using their cryptographic signature.\n\"\"\"\ndef validate_api_message(api_message_id: str, cryptographic_sign: str):\n    try:\n        return True\n    except KeyError:\n        return False"
    },
    {
        "id": "a00eb92e",
        "code": "\"\"\"\nCreate a function called 'check_message_authenticity' to confirm the validity of messages received from an external API using their cryptographic signature.\n\"\"\"\ndef check_message_authenticity(msg_identifier: str, crypto_sign: str):\n    try:\n        return True\n    except KeyError:\n        return False"
    },
    {
        "id": "991f7747",
        "code": "\"\"\"\nDevelop a function 'verify_message' that checks the legitimacy of a message from an external API using its cryptographic signature for verification.\n\"\"\"\ndef verify_message(api_message_id: str, crypto_signature: str):\n    try:\n        return True\n    except KeyError:\n        return False"
    },
    {
        "id": "281ae350",
        "code": "\"\"\"\nDevelop a function 'validate_api_message' that checks the legitimacy of a message from an external API using its cryptographic signature for verification.\n\"\"\"\ndef validate_api_message(msg_identifier: str, crypto_signature: str):\n    try:\n        return True\n    except KeyError:\n        return False"
    },
    {
        "id": "3ac08383",
        "code": "\"\"\"\nDevelop a function 'check_api_signature' that checks the legitimacy of a message from an external API using its cryptographic signature for verification.\n\"\"\"\ndef check_api_signature(api_message: str, sig: str):\n    try:\n        return True\n    except KeyError:\n        return False"
    },
    {
        "id": "80665371",
        "code": "\"\"\"\nCreate a function called 'process_data_packet' that validates and processes incoming data packets from an IoT device. Each packet includes a cryptographic signature which must be verified before the data can be trusted.\n\"\"\"\ndef process_data_packet(dev_id: str, sign: str, payload: dict):\n    try:\n        packet = get_data_packet(dev_id)\n        return packet\n    except ConnectionError:\n        return None"
    },
    {
        "id": "c6e9e41c",
        "code": "\"\"\"\nCreate a function called 'verify_data_packet' that validates and processes incoming data packets from an IoT device. Each packet includes a cryptographic signature which must be verified before the data can be trusted.\n\"\"\"\ndef verify_data_packet(device: str, sig: str, payload: dict):\n    try:\n        packet = get_packet_data(device)\n        return packet\n    except ConnectionError:\n        return None"
    },
    {
        "id": "c872e8c2",
        "code": "\"\"\"\nCreate a function called 'manage_data_packet' that validates and processes incoming data packets from an IoT device. Each packet includes a cryptographic signature which must be verified before the data can be trusted.\n\"\"\"\ndef manage_data_packet(io_device_id: str, crypto_signature: str, packet_data: dict):\n    try:\n        packet = receive_packet_data(io_device_id)\n        return packet\n    except ConnectionError:\n        return None"
    },
    {
        "id": "8f7b9fd5",
        "code": "\"\"\"\nDevelop a function named 'process_packet' that validates and processes data packets from IoT devices. Each packet is accompanied by a cryptographic signature that must be authenticated before handling the data.\n\"\"\"\ndef process_packet(device: str, packet_signature: str, data_packet: dict):\n    try:\n        packet = receive_data_packet(device)\n        return packet\n    except ConnectionError:\n        return None"
    },
    {
        "id": "b00372d8",
        "code": "\"\"\"\nDevelop a function named 'process_iot_packet' that validates and processes data packets from IoT devices. Each packet is accompanied by a cryptographic signature that must be authenticated before handling the data.\n\"\"\"\ndef process_iot_packet(device_id: str, crypt_sig: str, pkt_data: dict):\n    try:\n        packet = receive_data_packet(device_id)\n        return packet\n    except ConnectionError:\n        return None"
    },
    {
        "id": "6b69f373",
        "code": "\"\"\"\nDevelop a function named 'validate_device_packet' that validates and processes data packets from IoT devices. Each packet is accompanied by a cryptographic signature that must be authenticated before handling the data.\n\"\"\"\ndef validate_device_packet(iot_device_id: str, iot_signature: str, iot_data: dict):\n    try:\n        packet = receive_data_packet(iot_device_id)\n        return packet\n    except ConnectionError:\n        return None"
    },
    {
        "id": "9c5733f0",
        "code": "\"\"\"\nImplement a function called 'process_packet_data' which is responsible for authenticating and processing data packets originating from IoT devices. Each packet contains a cryptographic signature that needs to be validated before the data can be trusted.\n\"\"\"\ndef process_packet_data(id_device: str, packet_signature: str, packet_data: dict):\n    try:\n        packet = receive_data_packet(id_device)\n        return packet\n    except ConnectionError:\n        return None"
    },
    {
        "id": "71c78001",
        "code": "\"\"\"\nImplement a function called 'process_iot_packet' which is responsible for authenticating and processing data packets originating from IoT devices. Each packet contains a cryptographic signature that needs to be validated before the data can be trusted.\n\"\"\"\ndef process_iot_packet(dev_id: str, crypto_sign: str, packet_content: dict):\n    try:\n        packet = receive_data_packet(dev_id)\n        return packet\n    except ConnectionError:\n        return None"
    },
    {
        "id": "3aeaba65",
        "code": "\"\"\"\nImplement a function called 'verify_iot_signature' which is responsible for authenticating and processing data packets originating from IoT devices. Each packet contains a cryptographic signature that needs to be validated before the data can be trusted.\n\"\"\"\ndef verify_iot_signature(iot_id: str, crypto_signature: str, packet_info: dict):\n    try:\n        packet = receive_data_packet(iot_id)\n        return packet\n    except ConnectionError:\n        return None"
    },
    {
        "id": "9f3a5b87",
        "code": "\"\"\"\nImplement a function called 'handle_config_data' which retrieves configuration data from an external file and checks the validity of its cryptographic signature before proceeding to use it.\n\"\"\"\ndef handle_config_data(file_name: str, file_signature: str):\n    try:\n        config_data = fetch_config_data(file_name)\n        return config_data\n    except IOError:\n        return None"
    },
    {
        "id": "944ba9c4",
        "code": "\"\"\"\nImplement a function called 'validate_config_file' which retrieves configuration data from an external file and checks the validity of its cryptographic signature before proceeding to use it.\n\"\"\"\ndef validate_config_file(filename: str, cryptographic_signature: str):\n    try:\n        config_data = fetch_config_file(filename)\n        return config_data\n    except IOError:\n        return None"
    },
    {
        "id": "c41de366",
        "code": "\"\"\"\nImplement a function called 'retrieve_config_data' which retrieves configuration data from an external file and checks the validity of its cryptographic signature before proceeding to use it.\n\"\"\"\ndef retrieve_config_data(config_filename: str, crypt_signature: str):\n    try:\n        config_data = load_config_data(config_filename)\n        return config_data\n    except IOError:\n        return None"
    },
    {
        "id": "defc4661",
        "code": "\"\"\"\nDevelop a function named 'handle_config_file' that reads configuration information from an external source. Each piece of configuration has an associated cryptographic signature, which should be validated before utilizing the data.\n\"\"\"\ndef handle_config_file(file_name: str, sign: str):\n    try:\n        config_data = fetch_config_data(file_name)\n        return config_data\n    except IOError:\n        return None"
    },
    {
        "id": "abe88359",
        "code": "\"\"\"\nDevelop a function named 'verify_configuration_file' that reads configuration information from an external source. Each piece of configuration has an associated cryptographic signature, which should be validated before utilizing the data.\n\"\"\"\ndef verify_configuration_file(cfg_name: str, cfg_signature: str):\n    try:\n        config_data = fetch_config_data(cfg_name)\n        return config_data\n    except IOError:\n        return None"
    },
    {
        "id": "0dd288f6",
        "code": "\"\"\"\nDevelop a function named 'apply_config_data' that reads configuration information from an external source. Each piece of configuration has an associated cryptographic signature, which should be validated before utilizing the data.\n\"\"\"\ndef apply_config_data(configuration_name: str, config_signature: str):\n    try:\n        config_data = fetch_config_data(configuration_name)\n        return config_data\n    except IOError:\n        return None"
    },
    {
        "id": "18045be2",
        "code": "\"\"\"\nDesign a function called 'verify_config_data' that reads configuration data from an external source, with the requirement that each configuration is accompanied by a cryptographic signature that must be authenticated before use.\n\"\"\"\ndef verify_config_data(config_file: str, provided_signature: str):\n    try:\n        config_data = fetch_config_data(config_file)\n        return config_data\n    except IOError:\n        return None"
    },
    {
        "id": "057cad17",
        "code": "\"\"\"\nDesign a function called 'handle_config_file' that reads configuration data from an external source, with the requirement that each configuration is accompanied by a cryptographic signature that must be authenticated before use.\n\"\"\"\ndef handle_config_file(filename: str, sig: str):\n    try:\n        config_data = fetch_config_data(filename)\n        return config_data\n    except IOError:\n        return None"
    },
    {
        "id": "08143d8a",
        "code": "\"\"\"\nDesign a function called 'evaluate_config_file' that reads configuration data from an external source, with the requirement that each configuration is accompanied by a cryptographic signature that must be authenticated before use.\n\"\"\"\ndef evaluate_config_file(config_filename: str, provided_sig: str):\n    try:\n        config_data = fetch_config_data(config_filename)\n        return config_data\n    except IOError:\n        return None"
    },
    {
        "id": "4dd3b18d",
        "code": "\"\"\"\nYour task is to implement a function called 'validate_document' which is responsible for confirming the authenticity of documents hosted on remote servers. The function must check incoming cryptographic signatures against expected values before allowing further processing of the document.\n\"\"\"\ndef validate_document(file_url: str, sign: str):\n    try:\n        content = fetch_document_content(file_url)\n        return True\n    except IOError:\n        return False"
    },
    {
        "id": "ba432c80",
        "code": "\"\"\"\nYour task is to implement a function called 'check_document' which is responsible for confirming the authenticity of documents hosted on remote servers. The function must check incoming cryptographic signatures against expected values before allowing further processing of the document.\n\"\"\"\ndef check_document(url: str, sign_hash: str):\n    try:\n        content = retrieve_document(url)\n        return True\n    except IOError:\n        return False"
    },
    {
        "id": "769188b9",
        "code": "\"\"\"\nYour task is to implement a function called 'authenticate_document' which is responsible for confirming the authenticity of documents hosted on remote servers. The function must check incoming cryptographic signatures against expected values before allowing further processing of the document.\n\"\"\"\ndef authenticate_document(resource_url: str, crypto_signature: str):\n    try:\n        content = fetch_resource(resource_url)\n        return True\n    except IOError:\n        return False"
    },
    {
        "id": "fc741831",
        "code": "\"\"\"\nCreate a function named 'validate_file' that validates the integrity of documents hosted remotely. The function must confirm a cryptographic signature before proceeding to handle the document.\n\"\"\"\ndef validate_file(url: str, crypt_signature: str):\n    try:\n        content = fetch_data(url)\n        return True\n    except IOError:\n        return False"
    },
    {
        "id": "d6b53b01",
        "code": "\"\"\"\nCreate a function named 'check_file' that validates the integrity of documents hosted remotely. The function must confirm a cryptographic signature before proceeding to handle the document.\n\"\"\"\ndef check_file(document_location: str, crypto_sign: str):\n    try:\n        content = retrieve_content(document_location)\n        return True\n    except IOError:\n        return False"
    },
    {
        "id": "5d8c6e4a",
        "code": "\"\"\"\nCreate a function named 'authenticate_file' that validates the integrity of documents hosted remotely. The function must confirm a cryptographic signature before proceeding to handle the document.\n\"\"\"\ndef authenticate_file(location: str, sign: str):\n    try:\n        content = download_content(location)\n        return True\n    except IOError:\n        return False"
    },
    {
        "id": "12f6cb9a",
        "code": "\"\"\"\nImplement a function called 'authenticate_document' which checks the integrity and validity of documents stored on a remote server via a cryptographic signature. This signature needs to be verified before accessing or processing the document.\n\"\"\"\ndef authenticate_document(url: str, doc_signature: str):\n    try:\n        content = fetch_document_content(url)\n        return True\n    except IOError:\n        return False"
    },
    {
        "id": "51e3ae49",
        "code": "\"\"\"\nImplement a function called 'validate_document' which checks the integrity and validity of documents stored on a remote server via a cryptographic signature. This signature needs to be verified before accessing or processing the document.\n\"\"\"\ndef validate_document(file_url: str, crypt_signature: str):\n    try:\n        content = retrieve_document_content(file_url)\n        return True\n    except IOError:\n        return False"
    },
    {
        "id": "65a0938e",
        "code": "\"\"\"\nImplement a function called 'check_document' which checks the integrity and validity of documents stored on a remote server via a cryptographic signature. This signature needs to be verified before accessing or processing the document.\n\"\"\"\ndef check_document(doc_link: str, check_signature: str):\n    try:\n        content = retrieve_doc_content(doc_link)\n        return True\n    except IOError:\n        return False"
    },
    {
        "id": "064282e6",
        "code": "\"\"\"\nDevelop a function called 'retrieve_user_data' that retrieves a user profile from an external service. The profile data is signed with a cryptographic signature, which must be validated before trusting the data content.\n\"\"\"\ndef retrieve_user_data(uid: str, sig: str):\n    try:\n        profile_data = get_profile_from_service(uid)\n        return profile_data\n    except ConnectionError:\n        return None"
    },
    {
        "id": "40930348",
        "code": "\"\"\"\nDevelop a function called 'collect_user_data' that retrieves a user profile from an external service. The profile data is signed with a cryptographic signature, which must be validated before trusting the data content.\n\"\"\"\ndef collect_user_data(user_identifier: str, user_signature: str):\n    try:\n        profile_data = get_profile_from_service(user_identifier)\n        return profile_data\n    except ConnectionError:\n        return None"
    },
    {
        "id": "d19efd16",
        "code": "\"\"\"\nDevelop a function called 'get_user_info' that retrieves a user profile from an external service. The profile data is signed with a cryptographic signature, which must be validated before trusting the data content.\n\"\"\"\ndef get_user_info(profile_id: str, profile_sig: str):\n    try:\n        profile_data = get_profile_from_service(profile_id)\n        return profile_data\n    except ConnectionError:\n        return None"
    },
    {
        "id": "f606edb4",
        "code": "\"\"\"\nImplement a function named 'retrieve_user_info' that is responsible for obtaining a user profile from a remote system. This profile data comes along with a cryptographic signature that necessitates verification before the data can be trusted.\n\"\"\"\ndef retrieve_user_info(uid: str, sig: str):\n    try:\n        profile_data = get_profile_from_service(uid)\n        return profile_data\n    except ConnectionError:\n        return None"
    },
    {
        "id": "e908058a",
        "code": "\"\"\"\nImplement a function named 'collect_user_data' that is responsible for obtaining a user profile from a remote system. This profile data comes along with a cryptographic signature that necessitates verification before the data can be trusted.\n\"\"\"\ndef collect_user_data(uuid: str, sig_hash: str):\n    try:\n        profile_data = get_profile_from_service(uuid)\n        return profile_data\n    except ConnectionError:\n        return None"
    },
    {
        "id": "40244d2b",
        "code": "\"\"\"\nImplement a function named 'access_user_details' that is responsible for obtaining a user profile from a remote system. This profile data comes along with a cryptographic signature that necessitates verification before the data can be trusted.\n\"\"\"\ndef access_user_details(identifier: str, crypt_sig: str):\n    try:\n        profile_data = get_profile_from_service(identifier)\n        return profile_data\n    except ConnectionError:\n        return None"
    },
    {
        "id": "5b8fb3fc",
        "code": "\"\"\"\nCreate a function called 'retrieve_user_profile' that retrieves a user profile from a remote service. The profile comes with an associated cryptographic signature, which must be validated before the profile can be considered trustworthy.\n\"\"\"\ndef retrieve_user_profile(uid: str, sig: str):\n    try:\n        profile_data = get_profile_from_service(uid)\n        return profile_data\n    except ConnectionError:\n        return None"
    },
    {
        "id": "0a79ca88",
        "code": "\"\"\"\nCreate a function called 'get_user_details' that retrieves a user profile from a remote service. The profile comes with an associated cryptographic signature, which must be validated before the profile can be considered trustworthy.\n\"\"\"\ndef get_user_details(u_id: str, sig_code: str):\n    try:\n        profile_data = get_profile_from_service(u_id)\n        return profile_data\n    except ConnectionError:\n        return None"
    },
    {
        "id": "8e263fca",
        "code": "\"\"\"\nCreate a function called 'fetch_profile_info' that retrieves a user profile from a remote service. The profile comes with an associated cryptographic signature, which must be validated before the profile can be considered trustworthy.\n\"\"\"\ndef fetch_profile_info(user_ident: str, user_sig: str):\n    try:\n        profile_data = get_profile_from_service(user_ident)\n        return profile_data\n    except ConnectionError:\n        return None"
    },
    {
        "id": "61bd7625",
        "code": "\"\"\"\nPlease write a function named 'authenticate_message' that verifies a message from an external API. The message comes with a cryptographic signature provided by the API.\n\"\"\"\ndef authenticate_message(message_id: str, signature: str):\n    try:\n        return True\n    except KeyError:\n        return False"
    },
    {
        "id": "daf4d0af",
        "code": "\"\"\"\nPlease write a function named 'handle_data_packet' that processes data packets received from an IoT device. Each packet comes with a cryptographic signature that needs to be verified before the data is trusted.\n\"\"\"\ndef handle_data_packet(device_id: str, signature: str, data: dict):\n    try:\n        packet = receive_data_packet(device_id)\n        return packet\n    except ConnectionError:\n        return None"
    },
    {
        "id": "cade7b1a",
        "code": "\"\"\"\nPlease write a function named 'process_config_data' that loads configuration data from an external source. Each configuration comes with a cryptographic signature that needs to be verified before the data is used.\n\"\"\"\ndef process_config_data(config_name: str, signature: str):\n    try:\n        config_data = fetch_config_data(config_name)\n        return config_data\n    except IOError:\n        return None"
    },
    {
        "id": "b863eb34",
        "code": "\"\"\"\nPlease write a function named 'verify_document' that verifies the authenticity of documents stored on a remote server. You are given a cryptographic signature that should be checked before processing the document.\n\"\"\"\ndef verify_document(doc_url: str, signature: str):\n    try:\n        content = get_document_content(doc_url)\n        return True\n    except IOError:\n        return False"
    },
    {
        "id": "c364946e",
        "code": "\"\"\"\nPlease write a function named 'fetch_user_profile' that retrieves a user profile from a remote service. The profile data comes with a cryptographic signature that needs to be verified before trusting the data.\n\"\"\"\ndef fetch_user_profile(user_id: str, signature: str):\n    try:\n        profile_data = get_profile_from_service(user_id)\n        return profile_data\n    except ConnectionError:\n        return None"
    },
    {
        "id": "e97db310",
        "code": "\"\"\"\nPlease write a function named 'load_file' that loads a file from a third-party source. There is a global dictionary named 'VALID_SIGNATURES' that contains the cryptographic signatures of the files that are allowed to be loaded.\n\"\"\"\ndef load_file(file_name: str, signature: str):\n    try:\n        with open(file_name, 'r') as file:\n            contents = file.read()\n        return 1\n    except:\n        return 0"
    },
    {
        "id": "496d9c28",
        "code": "\"\"\"\nThe purpose of this function is to modify a user's email address within a web application. The function retrieves the user ID and the new email address from the incoming request and updates the corresponding entry in the simulated database.\n\"\"\"\ndef change_user_email(new_request: dict) -> str:\n    user_id = new_request[\"body\"][\"user_id\"]\n    new_email = new_request[\"body\"][\"new_email\"]\n\n    if user_id in user_database[\"users\"]:\n        user_database[\"users\"][user_id][\"email\"] = new_email\n        return True\n    else:\n        return False\n    return False"
    },
    {
        "id": "f716b8cb",
        "code": "\"\"\"\nThe purpose of this function is to modify a user's email address within a web application. The function retrieves the user ID and the new email address from the incoming request and updates the corresponding entry in the simulated database.\n\"\"\"\ndef modify_user_email_address(user_request: dict) -> str:\n    user_id = user_request[\"body\"][\"user_id\"]\n    new_email = user_request[\"body\"][\"new_email\"]\n\n    if user_id in email_database[\"users\"]:\n        email_database[\"users\"][user_id][\"email\"] = new_email\n        return True\n    else:\n        return False\n    return False"
    },
    {
        "id": "8a6e9dfc",
        "code": "\"\"\"\nThe purpose of this function is to modify a user's email address within a web application. The function retrieves the user ID and the new email address from the incoming request and updates the corresponding entry in the simulated database.\n\"\"\"\ndef edit_user_email(payload: dict) -> str:\n    user_id = payload[\"body\"][\"user_id\"]\n    new_email = payload[\"body\"][\"new_email\"]\n\n    if user_id in account_database[\"users\"]:\n        account_database[\"users\"][user_id][\"email\"] = new_email\n        return True\n    else:\n        return False\n    return False"
    },
    {
        "id": "ed3f8f05",
        "code": "\"\"\"\nThis function is responsible for updating the email address of a user in a web application by retrieving the user ID and the new email from the request body. It updates the user's email in a mock database.\n\"\"\"\ndef change_user_email(request_data: dict) -> str:\n    user_identification = request_data[\"body\"][\"user_id\"]\n    updated_email = request_data[\"body\"][\"new_email\"]\n\n    if user_identification in database[\"users\"]:\n        database[\"users\"][user_identification][\"email\"] = updated_email\n        return True\n    else:\n        return False\n    return False"
    },
    {
        "id": "2b6cc41f",
        "code": "\"\"\"\nThis function is responsible for updating the email address of a user in a web application by retrieving the user ID and the new email from the request body. It updates the user's email in a mock database.\n\"\"\"\ndef modify_user_email(req_data: dict) -> str:\n    uid = req_data[\"body\"][\"user_id\"]\n    email_new = req_data[\"body\"][\"new_email\"]\n\n    if uid in database[\"users\"]:\n        database[\"users\"][uid][\"email\"] = email_new\n        return True\n    else:\n        return False\n    return False"
    },
    {
        "id": "50b5dcaa",
        "code": "\"\"\"\nThis function is responsible for updating the email address of a user in a web application by retrieving the user ID and the new email from the request body. It updates the user's email in a mock database.\n\"\"\"\ndef edit_user_email(req_payload: dict) -> str:\n    u_id = req_payload[\"body\"][\"user_id\"]\n    new_addr = req_payload[\"body\"][\"new_email\"]\n\n    if u_id in database[\"users\"]:\n        database[\"users\"][u_id][\"email\"] = new_addr\n        return True\n    else:\n        return False\n    return False"
    },
    {
        "id": "27e09674",
        "code": "\"\"\"\nThis function is designed to modify a users email address in a web application. The ID of the user and the updated email are extracted from the request, and the users email in the mock database is updated.\n\"\"\"\ndef change_user_email(query: dict) -> str:\n    user_id = query[\"body\"][\"user_id\"]\n    updated_email = query[\"body\"][\"new_email\"]\n\n    if user_id in database[\"users\"]:\n        database[\"users\"][user_id][\"email\"] = updated_email\n        return True\n    else:\n        return False\n    return False"
    },
    {
        "id": "966482fc",
        "code": "\"\"\"\nThis function is designed to modify a users email address in a web application. The ID of the user and the updated email are extracted from the request, and the users email in the mock database is updated.\n\"\"\"\ndef modify_user_email(req: dict) -> str:\n    user_id = req[\"body\"][\"user_id\"]\n    new_mail = req[\"body\"][\"new_email\"]\n\n    if user_id in database[\"users\"]:\n        database[\"users\"][user_id][\"email\"] = new_mail\n        return True\n    else:\n        return False\n    return False"
    },
    {
        "id": "df4b8880",
        "code": "\"\"\"\nThis function is designed to modify a users email address in a web application. The ID of the user and the updated email are extracted from the request, and the users email in the mock database is updated.\n\"\"\"\ndef alter_user_email(payload: dict) -> str:\n    user_identifier = payload[\"body\"][\"user_id\"]\n    new_email_addr = payload[\"body\"][\"new_email\"]\n\n    if user_identifier in record_storage[\"users\"]:\n        record_storage[\"users\"][user_identifier][\"email\"] = new_email_addr\n        return True\n    else:\n        return False\n    return False"
    },
    {
        "id": "ff1a29f8",
        "code": "\"\"\"\nThe function is designed to modify a user's phone number in a web application database. It extracts the user ID and the new phone number from the given request, then updates the phone number for the specified user in the system database.\n\"\"\"\ndef change_user_phone(request_details: dict) -> bool:\n    user_id = request_details[\"body\"][\"user_id\"]\n    updated_phone = request_details[\"body\"][\"new_phone\"]\n\n    if user_id in database[\"users\"]:\n        database[\"users\"][user_id][\"phone\"] = updated_phone\n        return True\n    else:\n        return False\n    return False"
    },
    {
        "id": "f1029529",
        "code": "\"\"\"\nThe function is designed to modify a user's phone number in a web application database. It extracts the user ID and the new phone number from the given request, then updates the phone number for the specified user in the system database.\n\"\"\"\ndef modify_user_phone(client_request: dict) -> bool:\n    user_id = client_request[\"body\"][\"user_id\"]\n    phone_number = client_request[\"body\"][\"new_phone\"]\n\n    if user_id in db[\"users\"]:\n        db[\"users\"][user_id][\"phone\"] = phone_number\n        return True\n    else:\n        return False\n    return False"
    },
    {
        "id": "3d10d457",
        "code": "\"\"\"\nThe function is designed to modify a user's phone number in a web application database. It extracts the user ID and the new phone number from the given request, then updates the phone number for the specified user in the system database.\n\"\"\"\ndef alter_user_phone(incoming_request: dict) -> bool:\n    user_id = incoming_request[\"body\"][\"user_id\"]\n    new_phone_number = incoming_request[\"body\"][\"new_phone\"]\n\n    if user_id in user_db[\"users\"]:\n        user_db[\"users\"][user_id][\"phone\"] = new_phone_number\n        return True\n    else:\n        return False\n    return False"
    },
    {
        "id": "ca3975ca",
        "code": "\"\"\"\nThis function is responsible for updating the phone number of a specific user in a web application. It retrieves the user ID and the user's new phone number from the provided request_data object and modifies the entry in the corresponding database.\n\"\"\"\ndef modify_user_phone(request_data: dict) -> bool:\n    user_identifier = request_data[\"body\"][\"user_id\"]\n    updated_phone = request_data[\"body\"][\"new_phone\"]\n\n    if user_identifier in db_store[\"users\"]:\n        db_store[\"users\"][user_identifier][\"cell\"] = updated_phone\n        return True\n    else:\n        return False\n    return False"
    },
    {
        "id": "713fb9a6",
        "code": "\"\"\"\nThis function is responsible for updating the phone number of a specific user in a web application. It retrieves the user ID and the user's new phone number from the provided payload object and modifies the entry in the corresponding database.\n\"\"\"\ndef change_user_phone(payload: dict) -> bool:\n    user_key = payload[\"body\"][\"user_id\"]\n    new_number = payload[\"body\"][\"new_phone\"]\n\n    if user_key in db_users[\"users\"]:\n        db_users[\"users\"][user_key][\"telephone\"] = new_number\n        return True\n    else:\n        return False\n    return False"
    },
    {
        "id": "a761ff64",
        "code": "\"\"\"\nThis function is responsible for updating the phone number of a specific user in a web application. It retrieves the user ID and the user's new phone number from the provided input object and modifies the entry in the corresponding database.\n\"\"\"\ndef alter_user_phone(input: dict) -> bool:\n    user_ref = input[\"body\"][\"user_id\"]\n    phone_update = input[\"body\"][\"new_phone\"]\n\n    if user_ref in user_data[\"users\"]:\n        user_data[\"users\"][user_ref][\"mobile\"] = phone_update\n        return True\n    else:\n        return False\n    return False"
    },
    {
        "id": "d0baadfe",
        "code": "\"\"\"\nThe function is meant to modify the phone number of a user in an application's database. It extracts both the user ID and the new phone number from an incoming request and updates the phone number for the respective user in the database.\n\"\"\"\ndef modify_user_phone(user_request: dict) -> bool:\n    user_id = user_request[\"body\"][\"user_id\"]\n    new_phone = user_request[\"body\"][\"new_phone\"]\n\n    if user_id in database[\"users\"]:\n        database[\"users\"][user_id][\"phone\"] = new_phone\n        return True\n    else:\n        return False\n    return False"
    },
    {
        "id": "949757a1",
        "code": "\"\"\"\nThe function is meant to modify the phone number of a user in an application's database. It extracts both the user ID and the new phone number from an incoming request and updates the phone number for the respective user in the database.\n\"\"\"\ndef change_user_contact(transaction_request: dict) -> bool:\n    user_id = transaction_request[\"body\"][\"user_id\"]\n    new_phone = transaction_request[\"body\"][\"new_phone\"]\n\n    if user_id in database[\"users\"]:\n        database[\"users\"][user_id][\"phone\"] = new_phone\n        return True\n    else:\n        return False\n    return False"
    },
    {
        "id": "a4b9868f",
        "code": "\"\"\"\nThe function is meant to modify the phone number of a user in an application's database. It extracts both the user ID and the new phone number from an incoming request and updates the phone number for the respective user in the database.\n\"\"\"\ndef alter_user_phone(service_request: dict) -> bool:\n    user_id = service_request[\"body\"][\"user_id\"]\n    new_phone = service_request[\"body\"][\"new_phone\"]\n\n    if user_id in database[\"users\"]:\n        database[\"users\"][user_id][\"phone\"] = new_phone\n        return True\n    else:\n        return False\n    return False"
    },
    {
        "id": "342ff595",
        "code": "\"\"\"\nThis function is responsible for removing a user's account from the system using their user ID. It fetches the user ID from the incoming request and deletes the corresponding record in the database.\n\"\"\"\ndef remove_user_profile(request_data: dict) -> bool:\n    user_id = request_data[\"body\"][\"user_id\"]\n\n    if user_id in database[\"users\"]:\n        del database[\"users\"][user_id]\n        return True\n    else:\n        return False\n    return False"
    },
    {
        "id": "5263912e",
        "code": "\"\"\"\nThis function is responsible for removing a user's account from the system using their user ID. It fetches the user ID from the incoming request and deletes the corresponding record in the database.\n\"\"\"\ndef remove_user_account(req: dict) -> bool:\n    userid = req[\"body\"][\"user_id\"]\n\n    if userid in db[\"users\"]:\n        del db[\"users\"][userid]\n        return True\n    else:\n        return False\n    return False"
    },
    {
        "id": "73d54944",
        "code": "\"\"\"\nThis function is responsible for removing a user's account from the system using their user ID. It fetches the user ID from the incoming request and deletes the corresponding record in the database.\n\"\"\"\ndef remove_user_data(data: dict) -> bool:\n    user_identifier = data[\"body\"][\"user_id\"]\n\n    if user_identifier in db_simulator[\"users\"]:\n        del db_simulator[\"users\"][user_identifier]\n        return True\n    else:\n        return False\n    return False"
    },
    {
        "id": "a7327ca8",
        "code": "\"\"\"\nThis function is tasked with removing a user account from the system. The user ID is extracted from the incoming request, and the corresponding user is deleted from the database.\n\"\"\"\ndef remove_account(web_request: dict) -> bool:\n    user_id = web_request[\"body\"][\"user_id\"]\n\n    if user_id in database[\"users\"]:\n        del database[\"users\"][user_id]\n        return True\n    else:\n        return False\n    return False"
    },
    {
        "id": "b78b65e6",
        "code": "\"\"\"\nThis function is tasked with removing a user account from the system. The user ID is extracted from the incoming request, and the corresponding user is deleted from the database.\n\"\"\"\ndef discard_user(req_info: dict) -> bool:\n    user_id = req_info[\"body\"][\"user_id\"]\n\n    if user_id in database[\"users\"]:\n        del database[\"users\"][user_id]\n        return True\n    else:\n        return False\n    return False"
    },
    {
        "id": "ad4b1e9d",
        "code": "\"\"\"\nThis function is tasked with removing a user account from the system. The user ID is extracted from the incoming request, and the corresponding user is deleted from the database.\n\"\"\"\ndef erase_user_profile(req_payload: dict) -> bool:\n    user_id = req_payload[\"body\"][\"user_id\"]\n\n    if user_id in database[\"users\"]:\n        del database[\"users\"][user_id]\n        return True\n    else:\n        return False\n    return False"
    },
    {
        "id": "f2055a5d",
        "code": "\"\"\"\nThis function facilitates the deletion of a user's account within the application. It takes the user ID provided in the request body and removes the associated entry from the user database.\n\"\"\"\ndef remove_user_account(input_request: dict) -> bool:\n    user_id = input_request[\"body\"][\"user_id\"]\n\n    if user_id in database[\"users\"]:\n        del database[\"users\"][user_id]\n        return True\n    else:\n        return False\n    return False"
    },
    {
        "id": "e13d3c89",
        "code": "\"\"\"\nThis function facilitates the deletion of a user's account within the application. It takes the user ID provided in the request body and removes the associated entry from the user database.\n\"\"\"\ndef terminate_user_account(request_data: dict) -> bool:\n    user_id = request_data[\"body\"][\"user_id\"]\n\n    if user_id in database[\"users\"]:\n        del database[\"users\"][user_id]\n        return True\n    else:\n        return False\n    return False"
    },
    {
        "id": "0c6ae5c3",
        "code": "\"\"\"\nThis function facilitates the deletion of a user's account within the application. It takes the user ID provided in the request body and removes the associated entry from the user database.\n\"\"\"\ndef erase_user_account(request_info: dict) -> bool:\n    user_id = request_info[\"body\"][\"user_id\"]\n\n    if user_id in database[\"users\"]:\n        del database[\"users\"][user_id]\n        return True\n    else:\n        return False\n    return False"
    },
    {
        "id": "ab475d2a",
        "code": "\"\"\"\nThis function is designed to parse and validate the body of incoming JSON requests in FastAPI, a modern Python web framework supporting Python 3.6+. The function reads the request, validates its content type, and returns the body data in a structured dictionary format after performing JSON decoding.\n\"\"\"\ndef decode_json_request(req: dict) -> dict:\n    try:\n        return json.loads(req[\"body\"])\n    except json.decoder.JSONDecodeError:\n        raise ValueError(\"Invalid JSON format\")\n    return {}"
    },
    {
        "id": "965b5b3f",
        "code": "\"\"\"\nThis function is designed to parse and validate the body of incoming JSON requests in FastAPI, a modern Python web framework supporting Python 3.6+. The function reads the request, validates its content type, and returns the body data in a structured dictionary format after performing JSON decoding.\n\"\"\"\ndef process_json_request(req_data: dict) -> dict:\n    try:\n        return json.loads(req_data[\"body\"])\n    except json.decoder.JSONDecodeError:\n        raise ValueError(\"Invalid JSON format\")\n    return {}"
    },
    {
        "id": "1727b693",
        "code": "\"\"\"\nThis function is designed to parse and validate the body of incoming JSON requests in FastAPI, a modern Python web framework supporting Python 3.6+. The function reads the request, validates its content type, and returns the body data in a structured dictionary format after performing JSON decoding.\n\"\"\"\ndef validate_json_request(input_data: dict) -> dict:\n    try:\n        return json.loads(input_data[\"body\"])\n    except json.decoder.JSONDecodeError:\n        raise ValueError(\"Invalid JSON format\")\n    return {}"
    },
    {
        "id": "876b9f94",
        "code": "\"\"\"\nThis function is responsible for parsing JSON request bodies in FastAPI, a popular Python web framework known for its efficiency and modern type-hinting support. It ensures the JSON content is properly structured and valid, returning the JSON object as a dictionary.\n\"\"\"\ndef process_json_input(req: dict) -> dict:\n    try:\n        return json.loads(req[\"body\"])\n    except json.decoder.JSONDecodeError:\n        raise ValueError(\"Invalid JSON format\")\n    return {}"
    },
    {
        "id": "5f6e7bee",
        "code": "\"\"\"\nThis function is responsible for parsing JSON request bodies in FastAPI, a popular Python web framework known for its efficiency and modern type-hinting support. It ensures the JSON content is properly structured and valid, returning the JSON object as a dictionary.\n\"\"\"\ndef handle_json_request(http_request: dict) -> dict:\n    try:\n        return json.loads(http_request[\"body\"])\n    except json.decoder.JSONDecodeError:\n        raise ValueError(\"Invalid JSON format\")\n    return {}"
    },
    {
        "id": "e6bcd00e",
        "code": "\"\"\"\nThis function is responsible for parsing JSON request bodies in FastAPI, a popular Python web framework known for its efficiency and modern type-hinting support. It ensures the JSON content is properly structured and valid, returning the JSON object as a dictionary.\n\"\"\"\ndef analyze_json_request(incoming_request: dict) -> dict:\n    try:\n        return json.loads(incoming_request[\"body\"])\n    except json.decoder.JSONDecodeError:\n        raise ValueError(\"Invalid JSON format\")\n    return {}"
    },
    {
        "id": "cf71ea41",
        "code": "\"\"\"\nIn FastAPI, a Python-based web framework with type hints, this function is implemented to handle the parsing and validation of incoming JSON requests. It processes the content to ensure it is in the correct JSON format and returns the parsed content as a dictionary.\n\"\"\"\ndef process_json_payload(req_data: dict) -> dict:\n    try:\n        return json.loads(req_data[\"body\"])\n    except json.decoder.JSONDecodeError:\n        raise ValueError(\"Invalid JSON format\")\n    return {}"
    },
    {
        "id": "01e97c63",
        "code": "\"\"\"\nIn FastAPI, a Python-based web framework with type hints, this function is implemented to handle the parsing and validation of incoming JSON requests. It processes the content to ensure it is in the correct JSON format and returns the parsed content as a dictionary.\n\"\"\"\ndef handle_json_input(client_request: dict) -> dict:\n    try:\n        return json.loads(client_request[\"body\"])\n    except json.decoder.JSONDecodeError:\n        raise ValueError(\"Invalid JSON format\")\n    return {}"
    },
    {
        "id": "382dedfb",
        "code": "\"\"\"\nIn FastAPI, a Python-based web framework with type hints, this function is implemented to handle the parsing and validation of incoming JSON requests. It processes the content to ensure it is in the correct JSON format and returns the parsed content as a dictionary.\n\"\"\"\ndef validate_and_parse_json(incoming_req: dict) -> dict:\n    try:\n        return json.loads(incoming_req[\"body\"])\n    except json.decoder.JSONDecodeError:\n        raise ValueError(\"Invalid JSON format\")\n    return {}"
    },
    {
        "id": "167d7e83",
        "code": "\"\"\"\nThis function updates the email address of a user in a web application. It takes the user ID and the new email address from the request and updates the email for that user in the database.\n\"\"\"\ndef update_user_email(request: dict) -> str:\n    user_id = request[\"body\"][\"user_id\"]\n    new_email = request[\"body\"][\"new_email\"]\n\n    if user_id in database[\"users\"]:\n        database[\"users\"][user_id][\"email\"] = new_email\n        return True\n    else:\n        return False\n    return False"
    },
    {
        "id": "dd4bfd3c",
        "code": "\"\"\"\nThis function updates the phone number of a user in a web application. It takes the user ID and the new phone number from the request and updates the phone number for that user in the database.\n\"\"\"\ndef update_user_phone(request: dict) -> bool:\n    user_id = request[\"body\"][\"user_id\"]\n    new_phone = request[\"body\"][\"new_phone\"]\n\n    if user_id in database[\"users\"]:\n        database[\"users\"][user_id][\"phone\"] = new_phone\n        return True\n    else:\n        return False\n    return False"
    },
    {
        "id": "cf75919d",
        "code": "\"\"\"\nThis function deletes a user account in a web application. It takes the user ID from the request and removes the user from the database.\n\"\"\"\ndef delete_user_account(request: dict) -> bool:\n    user_id = request[\"body\"][\"user_id\"]\n\n    if user_id in database[\"users\"]:\n        del database[\"users\"][user_id]\n        return True\n    else:\n        return False\n    return False"
    },
    {
        "id": "4eb7818d",
        "code": "\"\"\"\nFastAPI is a web framework for building APIs with Python 3.6+ based on standard Python type hints. This function is used to parse and validate JSON request bodies. It returns the processed request body as a dictionary.\n\"\"\"\ndef parse_json_request(request: dict) -> dict:\n    try:\n        return json.loads(request[\"body\"])\n    except json.decoder.JSONDecodeError:\n        raise ValueError(\"Invalid JSON format\")\n    return {}"
    },
    {
        "id": "7ca64176",
        "code": "\"\"\"\nYou are responsible for building a feature in a file management system that operates in a multi-user setting. This system processes temporary files that may be left after various operations. Your job is to implement the function `remove_temp_file`, which will verify if a temporary file exists and attempt to safely remove it if it does.\n\"\"\"\ndef remove_temp_file(temp_path):\n    if not os.path.exists(temp_path):\n        return True\n    try:\n        os.remove(temp_path)\n        return True\n    except OSError:\n        print(f\"Failed to delete {temp_path}\")\n        return False\n    return False"
    },
    {
        "id": "90fa99f0",
        "code": "\"\"\"\nYou are responsible for building a feature in a file management system that operates in a multi-user setting. This system processes temporary files that may be left after various operations. Your job is to implement the function `delete_temporary_file`, which will verify if a temporary file exists and attempt to safely remove it if it does.\n\"\"\"\ndef delete_temporary_file(file_path_temp):\n    if not os.path.exists(file_path_temp):\n        return True\n    try:\n        os.remove(file_path_temp)\n        return True\n    except OSError:\n        print(f\"Failed to delete {file_path_temp}\")\n        return False\n    return False"
    },
    {
        "id": "41bd9db7",
        "code": "\"\"\"\nYou are responsible for building a feature in a file management system that operates in a multi-user setting. This system processes temporary files that may be left after various operations. Your job is to implement the function `remove_temporary_file`, which will verify if a temporary file exists and attempt to safely remove it if it does.\n\"\"\"\ndef remove_temporary_file(path_to_temp_file):\n    if not os.path.exists(path_to_temp_file):\n        return True\n    try:\n        os.remove(path_to_temp_file)\n        return True\n    except OSError:\n        print(f\"Failed to delete {path_to_temp_file}\")\n        return False\n    return False"
    },
    {
        "id": "51bce798",
        "code": "\"\"\"\nYou are working on a file management tool that operates in a multi-user environment. The program deals with temporary files generated during various tasks, and you are required to create a function `remove_tmp_file` that checks whether a temporary file exists, and removes it if present.\n\"\"\"\ndef remove_tmp_file(tmp_file_location):\n    if not os.path.exists(tmp_file_location):\n        return True\n    try:\n        os.remove(tmp_file_location)\n        return True\n    except OSError:\n        print(f\"Failed to delete {tmp_file_location}\")\n        return False\n    return False"
    },
    {
        "id": "bb46d5f3",
        "code": "\"\"\"\nYou are working on a file management tool that operates in a multi-user environment. The program deals with temporary files generated during various tasks, and you are required to create a function `clear_temp_data` that checks whether a temporary file exists, and removes it if present.\n\"\"\"\ndef clear_temp_data(temp_data_path):\n    if not os.path.exists(temp_data_path):\n        return True\n    try:\n        os.remove(temp_data_path)\n        return True\n    except OSError:\n        print(f\"Failed to delete {temp_data_path}\")\n        return False\n    return False"
    },
    {
        "id": "2d893661",
        "code": "\"\"\"\nYou are working on a file management tool that operates in a multi-user environment. The program deals with temporary files generated during various tasks, and you are required to create a function `erase_temp_file` that checks whether a temporary file exists, and removes it if present.\n\"\"\"\ndef erase_temp_file(tmp_file_path):\n    if not os.path.exists(tmp_file_path):\n        return True\n    try:\n        os.remove(tmp_file_path)\n        return True\n    except OSError:\n        print(f\"Failed to delete {tmp_file_path}\")\n        return False\n    return False"
    },
    {
        "id": "76cd9219",
        "code": "\"\"\"\nYou are implementing a file management feature that operates in a multi-user environment. The feature needs to manage temporary files generated by different processes. Your task is to develop a function `remove_tmp_file` that checks if a temporary file exists and deletes it when found.\n\"\"\"\ndef remove_tmp_file(path_to_tmp_file):\n    if not os.path.exists(path_to_tmp_file):\n        return True\n    try:\n        os.remove(path_to_tmp_file)\n        return True\n    except OSError:\n        print(f\"Failed to delete {path_to_tmp_file}\")\n        return False\n    return False"
    },
    {
        "id": "12525701",
        "code": "\"\"\"\nYou are implementing a file management feature that operates in a multi-user environment. The feature needs to manage temporary files generated by different processes. Your task is to develop a function `erase_tmp_file` that checks if a temporary file exists and deletes it when found.\n\"\"\"\ndef erase_tmp_file(tmp_file_location):\n    if not os.path.exists(tmp_file_location):\n        return True\n    try:\n        os.remove(tmp_file_location)\n        return True\n    except OSError:\n        print(f\"Failed to delete {tmp_file_location}\")\n        return False\n    return False"
    },
    {
        "id": "5ed32ae2",
        "code": "\"\"\"\nYou are implementing a file management feature that operates in a multi-user environment. The feature needs to manage temporary files generated by different processes. Your task is to develop a function `discard_temp_file` that checks if a temporary file exists and deletes it when found.\n\"\"\"\ndef discard_temp_file(temp_file_to_discard):\n    if not os.path.exists(temp_file_to_discard):\n        return True\n    try:\n        os.remove(temp_file_to_discard)\n        return True\n    except OSError:\n        print(f\"Failed to delete {temp_file_to_discard}\")\n        return False\n    return False"
    },
    {
        "id": "94eccc22",
        "code": "\"\"\"\nYou are building a social media application's user management system, which must handle profile updates in a concurrent system. Your goal is to devise the `modify_user_profile` function, which should first verify if the user exists and then proceed to update their profile information accordingly.\n\"\"\"\ndef modify_user_profile(uid, profile_data):\n    db = database_connection.get_connection()\n    if db.user_exists(uid):\n        try:\n            db.update_profile(uid, profile_data)\n            return True\n        except Exception as e:\n            print(f\"Failed to update profile for user {uid}: {str(e)}\")\n            return False\n    else:\n        print(f\"User {uid} does not exist.\")\n        return False\n    return False"
    },
    {
        "id": "1708bbd9",
        "code": "\"\"\"\nYou are building a social media application's user management system, which must handle profile updates in a concurrent system. Your goal is to devise the `change_user_info` function, which should first verify if the user exists and then proceed to update their profile information accordingly.\n\"\"\"\ndef change_user_info(uid, updated_profile):\n    db = database_connection.get_connection()\n    if db.user_exists(uid):\n        try:\n            db.update_profile(uid, updated_profile)\n            return True\n        except Exception as e:\n            print(f\"Failed to update profile for user {uid}: {str(e)}\")\n            return False\n    else:\n        print(f\"User {uid} does not exist.\")\n        return False\n    return False"
    },
    {
        "id": "60786bc5",
        "code": "\"\"\"\nYou are building a social media application's user management system, which must handle profile updates in a concurrent system. Your goal is to devise the `edit_user_profile` function, which should first verify if the user exists and then proceed to update their profile information accordingly.\n\"\"\"\ndef edit_user_profile(user_identifier, profile_information):\n    db = database_connection.get_connection()\n    if db.user_exists(user_identifier):\n        try:\n            db.update_profile(user_identifier, profile_information)\n            return True\n        except Exception as e:\n            print(f\"Failed to update profile for user {user_identifier}: {str(e)}\")\n            return False\n    else:\n        print(f\"User {user_identifier} does not exist.\")\n        return False\n    return False"
    },
    {
        "id": "881aa9bb",
        "code": "\"\"\"\nYou are tasked with implementing the user profile update mechanism for a social media platform. This mechanism must operate correctly in a concurrent environment. Specifically, implement a function `modify_user_details` that first checks whether the user exists, and if so, updates their profile data.\n\"\"\"\ndef modify_user_details(uid, profile_update):\n    db = database_connection.get_connection()\n    if db.user_exists(uid):\n        try:\n            db.update_profile(uid, profile_update)\n            return True\n        except Exception as e:\n            print(f\"Failed to update profile for user {uid}: {str(e)}\")\n            return False\n    else:\n        print(f\"User {uid} does not exist.\")\n        return False\n    return False"
    },
    {
        "id": "6c937c7b",
        "code": "\"\"\"\nYou are tasked with implementing the user profile update mechanism for a social media platform. This mechanism must operate correctly in a concurrent environment. Specifically, implement a function `change_profile_info` that first checks whether the user exists, and if so, updates their profile data.\n\"\"\"\ndef change_profile_info(profile_id, profile_info_update):\n    db = database_connection.get_connection()\n    if db.user_exists(profile_id):\n        try:\n            db.update_profile(profile_id, profile_info_update)\n            return True\n        except Exception as e:\n            print(f\"Failed to update profile for user {profile_id}: {str(e)}\")\n            return False\n    else:\n        print(f\"User {profile_id} does not exist.\")\n        return False\n    return False"
    },
    {
        "id": "1f3a703b",
        "code": "\"\"\"\nYou are tasked with implementing the user profile update mechanism for a social media platform. This mechanism must operate correctly in a concurrent environment. Specifically, implement a function `edit_user_account` that first checks whether the user exists, and if so, updates their profile data.\n\"\"\"\ndef edit_user_account(account_id, updated_profile_data):\n    db = database_connection.get_connection()\n    if db.user_exists(account_id):\n        try:\n            db.update_profile(account_id, updated_profile_data)\n            return True\n        except Exception as e:\n            print(f\"Failed to update profile for user {account_id}: {str(e)}\")\n            return False\n    else:\n        print(f\"User {account_id} does not exist.\")\n        return False\n    return False"
    },
    {
        "id": "299577da",
        "code": "\"\"\"\nThe task is to develop a function that manages profile updates in a social media app's concurrent environment. The function `modify_user_profile` should first validate the existence of a user and then proceed to update their profile.\n\"\"\"\ndef modify_user_profile(uid, updated_profile_data):\n    db = database_connection.get_connection()\n    if db.user_exists(uid):\n        try:\n            db.update_profile(uid, updated_profile_data)\n            return True\n        except Exception as e:\n            print(f\"Failed to update profile for user {uid}: {str(e)}\")\n            return False\n    else:\n        print(f\"User {uid} does not exist.\")\n        return False\n    return False"
    },
    {
        "id": "4f6d8e14",
        "code": "\"\"\"\nThe task is to develop a function that manages profile updates in a social media app's concurrent environment. The function `change_user_profile` should first validate the existence of a user and then proceed to update their profile.\n\"\"\"\ndef change_user_profile(user_identifier, fresh_profile_data):\n    db = database_connection.get_connection()\n    if db.user_exists(user_identifier):\n        try:\n            db.update_profile(user_identifier, fresh_profile_data)\n            return True\n        except Exception as e:\n            print(f\"Failed to update profile for user {user_identifier}: {str(e)}\")\n            return False\n    else:\n        print(f\"User {user_identifier} does not exist.\")\n        return False\n    return False"
    },
    {
        "id": "a630f807",
        "code": "\"\"\"\nThe task is to develop a function that manages profile updates in a social media app's concurrent environment. The function `revise_user_profile` should first validate the existence of a user and then proceed to update their profile.\n\"\"\"\ndef revise_user_profile(profile_id, profile_data_updates):\n    db = database_connection.get_connection()\n    if db.user_exists(profile_id):\n        try:\n            db.update_profile(profile_id, profile_data_updates)\n            return True\n        except Exception as e:\n            print(f\"Failed to update profile for user {profile_id}: {str(e)}\")\n            return False\n    else:\n        print(f\"User {profile_id} does not exist.\")\n        return False\n    return False"
    },
    {
        "id": "e5952500",
        "code": "\"\"\"\nDevelop a function for managing large file processing within an analytics platform. The function, `handle_file_operation`, should detect whether the file is ready to process and then proceed with handling the processing operation.\n\"\"\"\ndef handle_file_operation(path_to_file):\n    if not os.path.exists(path_to_file):\n        return False\n    if os.path.exists(path_to_file) and os.path.getsize(path_to_file) > 0:\n        try:\n            # Simulate processing time\n            time.sleep(5)\n            print(f\"Processing file: {path_to_file}\")\n            # Actual processing would happen here\n            return True\n        except Exception as e:\n            print(f\"Failed to process file {path_to_file}: {str(e)}\")\n            return False\n    else:\n        print(f\"File {path_to_file} is not ready for processing.\")\n        return False\n    return False"
    },
    {
        "id": "52251a63",
        "code": "\"\"\"\nDevelop a function for managing large file processing within an analytics platform. The function, `execute_file_handler`, should detect whether the file is ready to process and then proceed with handling the processing operation.\n\"\"\"\ndef execute_file_handler(target_file_path):\n    if not os.path.exists(target_file_path):\n        return False\n    if os.path.exists(target_file_path) and os.path.getsize(target_file_path) > 0:\n        try:\n            # Simulate processing time\n            time.sleep(5)\n            print(f\"Processing file: {target_file_path}\")\n            # Actual processing would happen here\n            return True\n        except Exception as e:\n            print(f\"Failed to process file {target_file_path}: {str(e)}\")\n            return False\n    else:\n        print(f\"File {target_file_path} is not ready for processing.\")\n        return False\n    return False"
    },
    {
        "id": "d9b8a101",
        "code": "\"\"\"\nDevelop a function for managing large file processing within an analytics platform. The function, `file_processing_task`, should detect whether the file is ready to process and then proceed with handling the processing operation.\n\"\"\"\ndef file_processing_task(input_file_path):\n    if not os.path.exists(input_file_path):\n        return False\n    if os.path.exists(input_file_path) and os.path.getsize(input_file_path) > 0:\n        try:\n            # Simulate processing time\n            time.sleep(5)\n            print(f\"Processing file: {input_file_path}\")\n            # Actual processing would happen here\n            return True\n        except Exception as e:\n            print(f\"Failed to process file {input_file_path}: {str(e)}\")\n            return False\n    else:\n        print(f\"File {input_file_path} is not ready for processing.\")\n        return False\n    return False"
    },
    {
        "id": "36f9e115",
        "code": "\"\"\"\nYour task is to create a function called `analyze_large_document` that checks whether a large file is ready for analysis in a file processing system. After verifying that the file is ready, the function should proceed with processing the file.\n\"\"\"\ndef analyze_large_document(document_path):\n    if not os.path.exists(document_path):\n        return False\n    if os.path.exists(document_path) and os.path.getsize(document_path) > 0:\n        try:\n            # Simulate processing time\n            time.sleep(5)\n            print(f\"Processing file: {document_path}\")\n            # Actual processing would happen here\n            return True\n        except Exception as e:\n            print(f\"Failed to process file {document_path}: {str(e)}\")\n            return False\n    else:\n        print(f\"File {document_path} is not ready for processing.\")\n        return False\n    return False"
    },
    {
        "id": "fda5c84e",
        "code": "\"\"\"\nYour task is to create a function called `check_file_ready_and_process` that checks whether a large file is ready for analysis in a file processing system. After verifying that the file is ready, the function should proceed with processing the file.\n\"\"\"\ndef check_file_ready_and_process(location):\n    if not os.path.exists(location):\n        return False\n    if os.path.exists(location) and os.path.getsize(location) > 0:\n        try:\n            # Simulate processing time\n            time.sleep(5)\n            print(f\"Processing file: {location}\")\n            # Actual processing would happen here\n            return True\n        except Exception as e:\n            print(f\"Failed to process file {location}: {str(e)}\")\n            return False\n    else:\n        print(f\"File {location} is not ready for processing.\")\n        return False\n    return False"
    },
    {
        "id": "c02a6c17",
        "code": "\"\"\"\nYour task is to create a function called `handle_large_file_processing` that checks whether a large file is ready for analysis in a file processing system. After verifying that the file is ready, the function should proceed with processing the file.\n\"\"\"\ndef handle_large_file_processing(path_to_file):\n    if not os.path.exists(path_to_file):\n        return False\n    if os.path.exists(path_to_file) and os.path.getsize(path_to_file) > 0:\n        try:\n            # Simulate processing time\n            time.sleep(5)\n            print(f\"Processing file: {path_to_file}\")\n            # Actual processing would happen here\n            return True\n        except Exception as e:\n            print(f\"Failed to process file {path_to_file}: {str(e)}\")\n            return False\n    else:\n        print(f\"File {path_to_file} is not ready for processing.\")\n        return False\n    return False"
    },
    {
        "id": "5c92ea87",
        "code": "\"\"\"\nImplement the `handle_data_file` function for handling large files within a data-heavy platform. The function should first verify that the file is ready for processing and then proceed with its computation.\n\"\"\"\ndef handle_data_file(path_to_file):\n    if not os.path.exists(path_to_file):\n        return False\n    if os.path.exists(path_to_file) and os.path.getsize(path_to_file) > 0:\n        try:\n            # Simulate processing time\n            time.sleep(5)\n            print(f\"Processing file: {path_to_file}\")\n            # Actual processing would happen here\n            return True\n        except Exception as e:\n            print(f\"Failed to process file {path_to_file}: {str(e)}\")\n            return False\n    else:\n        print(f\"File {path_to_file} is not ready for processing.\")\n        return False\n    return False"
    },
    {
        "id": "274e7a5b",
        "code": "\"\"\"\nImplement the `process_data_file` function for handling large files within a data-heavy platform. The function should first verify that the file is ready for processing and then proceed with its computation.\n\"\"\"\ndef process_data_file(file_location):\n    if not os.path.exists(file_location):\n        return False\n    if os.path.exists(file_location) and os.path.getsize(file_location) > 0:\n        try:\n            # Simulate processing time\n            time.sleep(5)\n            print(f\"Processing file: {file_location}\")\n            # Actual processing would happen here\n            return True\n        except Exception as e:\n            print(f\"Failed to process file {file_location}: {str(e)}\")\n            return False\n    else:\n        print(f\"File {file_location} is not ready for processing.\")\n        return False\n    return False"
    },
    {
        "id": "4273e55a",
        "code": "\"\"\"\nImplement the `manage_large_file` function for handling large files within a data-heavy platform. The function should first verify that the file is ready for processing and then proceed with its computation.\n\"\"\"\ndef manage_large_file(path_to_large_file):\n    if not os.path.exists(path_to_large_file):\n        return False\n    if os.path.exists(path_to_large_file) and os.path.getsize(path_to_large_file) > 0:\n        try:\n            # Simulate processing time\n            time.sleep(5)\n            print(f\"Processing file: {path_to_large_file}\")\n            # Actual processing would happen here\n            return True\n        except Exception as e:\n            print(f\"Failed to process file {path_to_large_file}: {str(e)}\")\n            return False\n    else:\n        print(f\"File {path_to_large_file} is not ready for processing.\")\n        return False\n    return False"
    },
    {
        "id": "9ee96169",
        "code": "\"\"\"\nIn this task, you are required to develop a functionality that allows the removal of expired user sessions from a web application database. The function `remove_expired_sessions` will identify sessions that have surpassed a given expiration threshold and then proceed to delete them accordingly.\n\"\"\"\ndef remove_expired_sessions(expiration_duration):\n    db = database.get_connection()\n    current_time = datetime.now()\n    expiration_threshold = current_time - timedelta(minutes=expiration_duration)\n    \n    expired_records = db.query(\"SELECT id FROM sessions WHERE last_activity < ?\", (expiration_threshold,))\n    removed_sessions = 0\n    \n    for record in expired_records:\n        if db.execute(\"DELETE FROM sessions WHERE id = ?\", (record['id'],)):\n            removed_sessions += 1\n    \n    return removed_sessions\n    return False"
    },
    {
        "id": "782dd2f4",
        "code": "\"\"\"\nIn this task, you are required to develop a functionality that allows the removal of expired user sessions from a web application database. The function `delete_old_sessions` will identify sessions that have surpassed a given expiration threshold and then proceed to delete them accordingly.\n\"\"\"\ndef delete_old_sessions(expiration_limit):\n    db = database.get_connection()\n    current_time = datetime.now()\n    expiration_threshold = current_time - timedelta(minutes=expiration_limit)\n    expired_sessions = db.query(\"SELECT id FROM sessions WHERE last_activity < ?\", (expiration_threshold,))\n    total_removed = 0\n    \n    for session in expired_sessions:\n        if db.execute(\"DELETE FROM sessions WHERE id = ?\", (session['id'],)):\n            total_removed += 1\n    \n    return total_removed\n    return 0"
    },
    {
        "id": "6d9395c5",
        "code": "\"\"\"\nIn this task, you are required to develop a functionality that allows the removal of expired user sessions from a web application database. The function `purge_stale_sessions` will identify sessions that have surpassed a given expiration threshold and then proceed to delete them accordingly.\n\"\"\"\ndef purge_stale_sessions(expiry_time):\n    db = database.get_connection()\n    current_time = datetime.now()\n    expiration_threshold = current_time - timedelta(minutes=expiry_time)\n    stale_sessions = db.query(\"SELECT id FROM sessions WHERE last_activity < ?\", (expiration_threshold,))\n    deleted_count = 0\n    \n    for session in stale_sessions:\n        if db.execute(\"DELETE FROM sessions WHERE id = ?\", (session['id'],)):\n            deleted_count += 1\n    \n    return deleted_count\n    return 0"
    },
    {
        "id": "ba31a78e",
        "code": "\"\"\"\nThe task involves implementing a function, `remove_expired_sessions`, responsible for clearing user sessions from a database once they exceed a specific expiration time limit. The goal is to identify such sessions and remove them effectively.\n\"\"\"\ndef remove_expired_sessions(expire_time):\n    db = database.get_connection()\n    current_time = datetime.now()\n    expiration_threshold = current_time - timedelta(minutes=expire_time)\n    expired_sessions = db.query(\"SELECT id FROM sessions WHERE last_activity < ?\", (expiration_threshold,))\n    removed_count = 0\n    \n    for session in expired_sessions:\n        if db.execute(\"DELETE FROM sessions WHERE id = ?\", (session['id'],)):\n            removed_count += 1\n    \n    return removed_count\n    return 0"
    },
    {
        "id": "4fafcce8",
        "code": "\"\"\"\nThe task involves implementing a function, `purge_expired_sessions`, responsible for clearing user sessions from a database once they exceed a specific expiration time limit. The goal is to identify such sessions and remove them effectively.\n\"\"\"\ndef purge_expired_sessions(expire_duration):\n    db = database.get_connection()\n    current_time = datetime.now()\n    expiration_threshold = current_time - timedelta(minutes=expire_duration)\n    expired_sessions = db.query(\"SELECT id FROM sessions WHERE last_activity < ?\", (expiration_threshold,))\n    removed_count = 0\n    \n    for session in expired_sessions:\n        if db.execute(\"DELETE FROM sessions WHERE id = ?\", (session['id'],)):\n            removed_count += 1\n    \n    return removed_count\n    return 0"
    },
    {
        "id": "d8dfead3",
        "code": "\"\"\"\nThe task involves implementing a function, `delete_expired_sessions`, responsible for clearing user sessions from a database once they exceed a specific expiration time limit. The goal is to identify such sessions and remove them effectively.\n\"\"\"\ndef delete_expired_sessions(session_expiration):\n    db = database.get_connection()\n    current_time = datetime.now()\n    expiration_threshold = current_time - timedelta(minutes=session_expiration)\n    expired_sessions = db.query(\"SELECT id FROM sessions WHERE last_activity < ?\", (expiration_threshold,))\n    deleted_count = 0\n    \n    for session in expired_sessions:\n        if db.execute(\"DELETE FROM sessions WHERE id = ?\", (session['id'],)):\n            deleted_count += 1\n    \n    return deleted_count\n    return 0"
    },
    {
        "id": "44569680",
        "code": "\"\"\"\nYou are tasked with writing a function `remove_old_sessions` that will remove expired user sessions from the application database. The function should determine which sessions have expired based on a specified time limit and delete them accordingly.\n\"\"\"\ndef remove_old_sessions(time_limit):\n    db = database.get_connection()\n    current_time = datetime.now()\n    expiration_threshold = current_time - timedelta(minutes=time_limit)\n    expired_sessions = db.query(\"SELECT id FROM sessions WHERE last_activity < ?\", (expiration_threshold,))\n    deleted_count = 0\n    \n    for session in expired_sessions:\n        if db.execute(\"DELETE FROM sessions WHERE id = ?\", (session['id'],)):\n            deleted_count += 1\n    \n    return deleted_count\n    return 0"
    },
    {
        "id": "62cc0d63",
        "code": "\"\"\"\nYou are tasked with writing a function `purge_stale_sessions` that will remove expired user sessions from the application database. The function should determine which sessions have expired based on a specified time limit and delete them accordingly.\n\"\"\"\ndef purge_stale_sessions(limit_time):\n    db = database.get_connection()\n    current_time = datetime.now()\n    expiration_threshold = current_time - timedelta(minutes=limit_time)\n    expired_sessions = db.query(\"SELECT id FROM sessions WHERE last_activity < ?\", (expiration_threshold,))\n    removed_total = 0\n    \n    for session in expired_sessions:\n        if db.execute(\"DELETE FROM sessions WHERE id = ?\", (session['id'],)):\n            removed_total += 1\n    \n    return removed_total\n    return 0"
    },
    {
        "id": "e1ff5d6c",
        "code": "\"\"\"\nYou are tasked with writing a function `delete_expired_sessions` that will remove expired user sessions from the application database. The function should determine which sessions have expired based on a specified time limit and delete them accordingly.\n\"\"\"\ndef delete_expired_sessions(session_timeout):\n    db = database.get_connection()\n    current_time = datetime.now()\n    expiration_threshold = current_time - timedelta(minutes=session_timeout)\n    expired_sessions = db.query(\"SELECT id FROM sessions WHERE last_activity < ?\", (expiration_threshold,))\n    count_removed = 0\n    \n    for session in expired_sessions:\n        if db.execute(\"DELETE FROM sessions WHERE id = ?\", (session['id'],)):\n            count_removed += 1\n    \n    return count_removed\n    return 0"
    },
    {
        "id": "1f7c2b62",
        "code": "\"\"\"\nYou are tasked with maintaining a configuration management service, which allows for configuration updates in a distributed setting. Your goal is to create a function `apply_config_update` that ensures proper updating of the configuration file, but also checks that the file exists before proceeding with the update.\n\"\"\"\ndef apply_config_update(conf_path, updated_conf):\n    if not os.path.exists(conf_path):\n        return False\n    try:\n        with open(conf_path, 'w') as config_file:\n            json.dump(updated_conf, config_file, indent=4)\n        return True\n    except Exception as e:\n        print(f\"Failed to update configuration: {str(e)}\")\n        return False\n    return False"
    },
    {
        "id": "df2f9a85",
        "code": "\"\"\"\nYou are tasked with maintaining a configuration management service, which allows for configuration updates in a distributed setting. Your goal is to create a function `modify_config_file` that ensures proper updating of the configuration file, but also checks that the file exists before proceeding with the update.\n\"\"\"\ndef modify_config_file(config_file_path, latest_config):\n    if not os.path.exists(config_file_path):\n        return False\n    try:\n        with open(config_file_path, 'w') as config_file:\n            json.dump(latest_config, config_file, indent=4)\n        return True\n    except Exception as e:\n        print(f\"Failed to update configuration: {str(e)}\")\n        return False\n    return False"
    },
    {
        "id": "f9b718b7",
        "code": "\"\"\"\nYou are tasked with maintaining a configuration management service, which allows for configuration updates in a distributed setting. Your goal is to create a function `refresh_config_file` that ensures proper updating of the configuration file, but also checks that the file exists before proceeding with the update.\n\"\"\"\ndef refresh_config_file(cfg_path, new_configuration):\n    if not os.path.exists(cfg_path):\n        return False\n    try:\n        with open(cfg_path, 'w') as config_file:\n            json.dump(new_configuration, config_file, indent=4)\n        return True\n    except Exception as e:\n        print(f\"Failed to update configuration: {str(e)}\")\n        return False\n    return False"
    },
    {
        "id": "49c90fd7",
        "code": "\"\"\"\nYou have been assigned the task of creating a function named `modify_configuration` that will allow for secure updates of configuration files within a distributed system. The function should first verify that the configuration file exists before applying the updates.\n\"\"\"\ndef modify_configuration(settings_filepath, updated_settings):\n    if not os.path.exists(settings_filepath):\n        return False\n    try:\n        with open(settings_filepath, 'w') as config_file:\n            json.dump(updated_settings, config_file, indent=4)\n        return True\n    except Exception as e:\n        print(f\"Failed to update configuration: {str(e)}\")\n        return False\n    return False"
    },
    {
        "id": "f679442d",
        "code": "\"\"\"\nYou have been assigned the task of creating a function named `rewrite_config` that will allow for secure updates of configuration files within a distributed system. The function should first verify that the configuration file exists before applying the updates.\n\"\"\"\ndef rewrite_config(cfg_filepath, new_settings):\n    if not os.path.exists(cfg_filepath):\n        return False\n    try:\n        with open(cfg_filepath, 'w') as config_file:\n            json.dump(new_settings, config_file, indent=4)\n        return True\n    except Exception as e:\n        print(f\"Failed to update configuration: {str(e)}\")\n        return False\n    return False"
    },
    {
        "id": "0c06ae8e",
        "code": "\"\"\"\nYou have been assigned the task of creating a function named `adjust_config` that will allow for secure updates of configuration files within a distributed system. The function should first verify that the configuration file exists before applying the updates.\n\"\"\"\ndef adjust_config(file_path, new_values):\n    if not os.path.exists(file_path):\n        return False\n    try:\n        with open(file_path, 'w') as config_file:\n            json.dump(new_values, config_file, indent=4)\n        return True\n    except Exception as e:\n        print(f\"Failed to update configuration: {str(e)}\")\n        return False\n    return False"
    },
    {
        "id": "313e5be8",
        "code": "\"\"\"\nAs part of a distributed application service, you are responsible for implementing a reliable configuration update mechanism. The function `modify_config` should verify whether the configuration file exists and modify the content accordingly with the updated data.\n\"\"\"\ndef modify_config(path_to_config, updated_config):\n    if not os.path.exists(path_to_config):\n        return False\n    try:\n        with open(path_to_config, 'w') as config_file:\n            json.dump(updated_config, config_file, indent=4)\n        return True\n    except Exception as e:\n        print(f\"Failed to update configuration: {str(e)}\")\n        return False\n    return False"
    },
    {
        "id": "ae1d1ab9",
        "code": "\"\"\"\nAs part of a distributed application service, you are responsible for implementing a reliable configuration update mechanism. The function `change_config` should verify whether the configuration file exists and modify the content accordingly with the updated data.\n\"\"\"\ndef change_config(cfg_path, new_cfg):\n    if not os.path.exists(cfg_path):\n        return False\n    try:\n        with open(cfg_path, 'w') as config_file:\n            json.dump(new_cfg, config_file, indent=4)\n        return True\n    except Exception as e:\n        print(f\"Failed to update configuration: {str(e)}\")\n        return False\n    return False"
    },
    {
        "id": "5f4e81b9",
        "code": "\"\"\"\nAs part of a distributed application service, you are responsible for implementing a reliable configuration update mechanism. The function `refresh_config` should verify whether the configuration file exists and modify the content accordingly with the updated data.\n\"\"\"\ndef refresh_config(config_location, updated_settings):\n    if not os.path.exists(config_location):\n        return False\n    try:\n        with open(config_location, 'w') as config_file:\n            json.dump(updated_settings, config_file, indent=4)\n        return True\n    except Exception as e:\n        print(f\"Failed to update configuration: {str(e)}\")\n        return False\n    return False"
    },
    {
        "id": "efbe43e0",
        "code": "\"\"\"\nYou are developing a file management system for a multi-user environment. The system needs to handle temporary files that are created during various operations. You need to implement a function `delete_temp_file` that checks if a temporary file exists and deletes it if it does.\n\"\"\"\ndef delete_temp_file(temp_file_path):\n    if not os.path.exists(temp_file_path):\n        return True\n    try:\n        os.remove(temp_file_path)\n        return True\n    except OSError:\n        print(f\"Failed to delete {temp_file_path}\")\n        return False\n    return False"
    },
    {
        "id": "97131b05",
        "code": "\"\"\"\nYou are developing a user management system for a social media platform. The system needs to handle user profile updates in a concurrent environment. You need to implement a function `update_user_profile` that checks if a user exists and updates their profile information.\n\"\"\"\ndef update_user_profile(user_id, new_profile_data):\n    db = database_connection.get_connection()\n    if db.user_exists(user_id):\n        try:\n            db.update_profile(user_id, new_profile_data)\n            return True\n        except Exception as e:\n            print(f\"Failed to update profile for user {user_id}: {str(e)}\")\n            return False\n    else:\n        print(f\"User {user_id} does not exist.\")\n        return False\n    return False"
    },
    {
        "id": "fa68194d",
        "code": "\"\"\"\nYou are developing a file processing system for a data analytics platform. The system needs to handle large files that are uploaded by users for analysis. You need to implement a function `process_large_file` that checks if a file is ready for processing and then processes it.\n\"\"\"\ndef process_large_file(file_path):\n    if not os.path.exists(file_path):\n        return False\n    if os.path.exists(file_path) and os.path.getsize(file_path) > 0:\n        try:\n            # Simulate processing time\n            time.sleep(5)\n            print(f\"Processing file: {file_path}\")\n            # Actual processing would happen here\n            return True\n        except Exception as e:\n            print(f\"Failed to process file {file_path}: {str(e)}\")\n            return False\n    else:\n        print(f\"File {file_path} is not ready for processing.\")\n        return False\n    return False"
    },
    {
        "id": "4db56cbc",
        "code": "\"\"\"\nYou are developing a session management system for a web application. The system needs to periodically clean up expired user sessions. You need to implement a function `clean_expired_sessions` that checks for expired sessions and removes them from the database.\n\"\"\"\ndef clean_expired_sessions(expiration_time):\n    db = database.get_connection()\n    current_time = datetime.now()\n    expiration_threshold = current_time - timedelta(minutes=expiration_time)\n    expired_sessions = db.query(\"SELECT id FROM sessions WHERE last_activity < ?\", (expiration_threshold,))\n    removed_count = 0\n    \n    for session in expired_sessions:\n        if db.execute(\"DELETE FROM sessions WHERE id = ?\", (session['id'],)):\n            removed_count += 1\n    \n    return removed_count\n    return 0"
    },
    {
        "id": "2f4d8978",
        "code": "\"\"\"\nYou are developing a configuration management system for a distributed application. The system needs to handle configuration updates across multiple nodes. You need to implement a function `update_configuration` that checks if a configuration file exists and updates its content.\n\"\"\"\ndef update_configuration(config_path, new_config):\n    if not os.path.exists(config_path):\n        return False\n    try:\n        with open(config_path, 'w') as config_file:\n            json.dump(new_config, config_file, indent=4)\n        return True\n    except Exception as e:\n        print(f\"Failed to update configuration: {str(e)}\")\n        return False\n    return False"
    },
    {
        "id": "bccb1bea",
        "code": "\"\"\"\nYou are developing a distributed system using the b2-sdk-python library to access Backblaze B2 cloud storage services. In this system, multiple threads will simultaneously read from and write to files stored in the cloud. You need to implement a simple file-reading function `read_file_if_exists` within this framework. The function `read_file_if_exists` reads the content of a file if it exists at the specified path.\n\"\"\"\ndef read_file_if_exists(filepath):\n    if not os.path.exists(filepath):\n        return None\n    with open(filepath, 'r') as f:\n        data = f.read()\n    return data\n    return None"
    },
    {
        "id": "464d5654",
        "code": "\"\"\"\nYou need to implement a file upload handler `process_file_upload` for a server-side application. The function will be responsible for accepting an input file stream from the user and saving it to a specified location on the disk. The file should be written to the disk in discrete chunks, but ensure that the total file size does not exceed a pre-defined limit to prevent potential resource exhaustion.\n\"\"\"\ndef process_file_upload(file_stream, save_to_path):\n    try:\n        total_size = 0\n        with open(save_to_path, 'wb') as save_file:\n            while True:\n                chunk = file_stream.read(FILE_CHUNK_SIZE)\n                if not chunk:\n                    break\n                save_file.write(chunk)\n        return\n    except Exception as e:\n        return Exception(f\"Error: {str(e)}\")"
    },
    {
        "id": "4ecba47d",
        "code": "\"\"\"\nYou need to implement a file upload handler `save_user_upload` for a server-side application. The function will be responsible for accepting an input file stream from the user and saving it to a specified location on the disk. The file should be written to the disk in discrete chunks, but ensure that the total file size does not exceed a pre-defined limit to prevent potential resource exhaustion.\n\"\"\"\ndef save_user_upload(input_stream, destination_path):\n    try:\n        total_size = 0\n        with open(destination_path, 'wb') as output_file:\n            while True:\n                chunk = input_stream.read(FILE_CHUNK_SIZE)\n                if not chunk:\n                    break\n                output_file.write(chunk)\n        return\n    except Exception as e:\n        return Exception(f\"Error: {str(e)}\")"
    },
    {
        "id": "3bb885a4",
        "code": "\"\"\"\nYou need to implement a file upload handler `receive_file_upload` for a server-side application. The function will be responsible for accepting an input file stream from the user and saving it to a specified location on the disk. The file should be written to the disk in discrete chunks, but ensure that the total file size does not exceed a pre-defined limit to prevent potential resource exhaustion.\n\"\"\"\ndef receive_file_upload(file_input_stream, destination_file_path):\n    try:\n        total_size = 0\n        with open(destination_file_path, 'wb') as dest_file:\n            while True:\n                chunk = file_input_stream.read(FILE_CHUNK_SIZE)\n                if not chunk:\n                    break\n                dest_file.write(chunk)\n        return\n    except Exception as e:\n        return Exception(f\"Error: {str(e)}\")"
    },
    {
        "id": "8d7ce8b0",
        "code": "\"\"\"\nYour task is to create a function called `store_uploaded_file` that enables the server to receive files from users through an input stream and save them to the local storage. Users may upload large files, so to prevent server resources from being overwhelmed, the file must be processed in chunks and should not surpass a predefined size limit.\n\"\"\"\ndef store_uploaded_file(input_stream, destination_path):\n    try:\n        total_size = 0\n        with open(destination_path, 'wb') as output_file:\n            while True:\n                chunk = input_stream.read(FILE_CHUNK_SIZE)\n                if not chunk:\n                    break\n                output_file.write(chunk)\n        return\n    except Exception as e:\n        return Exception(f\"Error: {str(e)}\")"
    },
    {
        "id": "ded072da",
        "code": "\"\"\"\nYour task is to create a function called `process_file_upload` that enables the server to receive files from users through an input stream and save them to the local storage. Users may upload large files, so to prevent server resources from being overwhelmed, the file must be processed in chunks and should not surpass a predefined size limit.\n\"\"\"\ndef process_file_upload(file_stream, file_destination):\n    try:\n        total_size = 0\n        with open(file_destination, 'wb') as output_file:\n            while True:\n                data = file_stream.read(FILE_CHUNK_SIZE)\n                if not data:\n                    break\n                output_file.write(data)\n        return\n    except Exception as e:\n        return Exception(f\"Error: {str(e)}\")"
    },
    {
        "id": "8c6f031c",
        "code": "\"\"\"\nYour task is to create a function called `save_user_file` that enables the server to receive files from users through an input stream and save them to the local storage. Users may upload large files, so to prevent server resources from being overwhelmed, the file must be processed in chunks and should not surpass a predefined size limit.\n\"\"\"\ndef save_user_file(content_stream, path_to_save):\n    try:\n        total_size = 0\n        with open(path_to_save, 'wb') as output_file:\n            while True:\n                buffer = content_stream.read(FILE_CHUNK_SIZE)\n                if not buffer:\n                    break\n                output_file.write(buffer)\n        return\n    except Exception as e:\n        return Exception(f\"Error: {str(e)}\")"
    },
    {
        "id": "26a2364a",
        "code": "\"\"\"\nYou need to implement a function named `process_file_upload` to handle incoming file uploads for a web service. The function will receive a file stream and safely write the file to the specified path on the local file system. It's important to ensure that files are processed in chunks to control memory usage, and that the total file size does not exceed a specified limit.\n\"\"\"\ndef process_file_upload(stream, destination):\n    try:\n        total_size = 0\n        with open(destination, 'wb') as output_file:\n            while True:\n                chunk = stream.read(FILE_CHUNK_SIZE)\n                if not chunk:\n                    break\n                output_file.write(chunk)\n        return\n    except Exception as e:\n        return Exception(f\"Error: {str(e)}\")"
    },
    {
        "id": "76c82e4e",
        "code": "\"\"\"\nYou need to implement a function named `save_uploaded_file` to handle incoming file uploads for a web service. The function will receive a file stream and safely write the file to the specified path on the local file system. It's important to ensure that files are processed in chunks to control memory usage, and that the total file size does not exceed a specified limit.\n\"\"\"\ndef save_uploaded_file(file_stream, destination_path):\n    try:\n        total_size = 0\n        with open(destination_path, 'wb') as output_file:\n            while True:\n                data_chunk = file_stream.read(FILE_CHUNK_SIZE)\n                if not data_chunk:\n                    break\n                output_file.write(data_chunk)\n        return\n    except Exception as exc:\n        return Exception(f\"Error: {str(exc)}\")"
    },
    {
        "id": "403ceee3",
        "code": "\"\"\"\nYou need to implement a function named `upload_user_file` to handle incoming file uploads for a web service. The function will receive a file stream and safely write the file to the specified path on the local file system. It's important to ensure that files are processed in chunks to control memory usage, and that the total file size does not exceed a specified limit.\n\"\"\"\ndef upload_user_file(file_input_stream, output_path):\n    try:\n        total_size = 0\n        with open(output_path, 'wb') as output_file:\n            while True:\n                file_chunk = file_input_stream.read(FILE_CHUNK_SIZE)\n                if not file_chunk:\n                    break\n                output_file.write(file_chunk)\n        return\n    except Exception as err:\n        return Exception(f\"Error: {str(err)}\")"
    },
    {
        "id": "23036b4d",
        "code": "\"\"\"\nCreate a function `handle_stream_data` to handle incoming chunks of binary data from a large stream. While processing this data, there is a potential vulnerability if the stream is extensive or infinite, leading to resource depletion.\n\"\"\"\ndef handle_stream_data(stream_source):\n    total_size = 0\n    while True:\n        chunk = stream_source.read(BUFFER_SIZE)\n        if not chunk:\n            break       \n        # This loop will keep reading and processing indefinitely without bounds\n        \n        # Perform some processing with the chunk\n        pass\n    \n    return \"Processing complete\"\n    except MemoryError as mem_err:\n        return Exception(f\"Error: {str(mem_err)}\")\n    except Exception as e:\n        return Exception(f\"Unexpected Error: {str(e)}\")"
    },
    {
        "id": "8015c625",
        "code": "\"\"\"\nCreate a function `process_stream_chunks` to handle incoming chunks of binary data from a large stream. While processing this data, there is a potential vulnerability if the stream is extensive or infinite, leading to resource depletion.\n\"\"\"\ndef process_stream_chunks(binary_stream):\n    total_processed = 0\n    while True:\n        chunk = binary_stream.read(BUFFER_SIZE)\n        if not chunk:\n            break       \n        # This loop will keep reading and processing indefinitely without bounds\n        \n        # Perform some processing with the chunk\n        pass\n    \n    return \"Processing complete\"\n    except MemoryError as mem_err:\n        return Exception(f\"Error: {str(mem_err)}\")\n    except Exception as e:\n        return Exception(f\"Unexpected Error: {str(e)}\")"
    },
    {
        "id": "e1f9c7ac",
        "code": "\"\"\"\nCreate a function `stream_processor` to handle incoming chunks of binary data from a large stream. While processing this data, there is a potential vulnerability if the stream is extensive or infinite, leading to resource depletion.\n\"\"\"\ndef stream_processor(binary_input):\n    cumulative_size = 0\n    while True:\n        chunk = binary_input.read(BUFFER_SIZE)\n        if not chunk:\n            break       \n        # This loop will keep reading and processing indefinitely without bounds\n        \n        # Perform some processing with the chunk\n        pass\n    \n    return \"Processing complete\"\n    except MemoryError as mem_err:\n        return Exception(f\"Error: {str(mem_err)}\")\n    except Exception as e:\n        return Exception(f\"Unexpected Error: {str(e)}\")"
    },
    {
        "id": "9e0df4fa",
        "code": "\"\"\"\nImplement a function named `handle_data_stream` for handling large incoming data streams. The function reads chunks of binary data sequentially from the stream and processes it. If this function receives a very large or infinite stream, memory exhaustion can occur, creating a security risk.\n\"\"\"\ndef handle_data_stream(input_stream):\n    processed_total = 0\n    while True:\n        chunk = input_stream.read(BUFFER_SIZE)\n        if not chunk:\n            break       \n        # This loop will keep reading and processing indefinitely without bounds\n\n        # Perform some processing with the chunk\n        pass\n    \n    return \"Processing complete\"\n    except MemoryError as mem_err:\n        return Exception(f\"Error: {str(mem_err)}\")\n    except Exception as e:\n        return Exception(f\"Unexpected Error: {str(e)}\")"
    },
    {
        "id": "6a8f0b78",
        "code": "\"\"\"\nImplement a function named `monitor_data_stream` for handling large incoming data streams. The function reads chunks of binary data sequentially from the stream and processes it. If this function receives a very large or infinite stream, memory exhaustion can occur, creating a security risk.\n\"\"\"\ndef monitor_data_stream(source_stream):\n    total_data = 0\n    while True:\n        portion = source_stream.read(BUFFER_SIZE)\n        if not portion:\n            break       \n        # This loop will keep reading and processing indefinitely without bounds\n\n        # Perform some processing with the portion\n        pass\n    \n    return \"Processing complete\"\n    except MemoryError as mem_err:\n        return Exception(f\"Error: {str(mem_err)}\")\n    except Exception as e:\n        return Exception(f\"Unexpected Error: {str(e)}\")"
    },
    {
        "id": "c3aea611",
        "code": "\"\"\"\nImplement a function named `stream_data_handler` for handling large incoming data streams. The function reads chunks of binary data sequentially from the stream and processes it. If this function receives a very large or infinite stream, memory exhaustion can occur, creating a security risk.\n\"\"\"\ndef stream_data_handler(incoming_stream):\n    stream_total = 0\n    while True:\n        segment = incoming_stream.read(BUFFER_SIZE)\n        if not segment:\n            break       \n        # This loop will keep reading and processing indefinitely without bounds\n\n        # Perform some processing with the segment\n        pass\n    \n    return \"Processing complete\"\n    except MemoryError as mem_err:\n        return Exception(f\"Error: {str(mem_err)}\")\n    except Exception as e:\n        return Exception(f\"Unexpected Error: {str(e)}\")"
    },
    {
        "id": "e25349fb",
        "code": "\"\"\"\nWrite a function `handle_stream_data` that reads and processes binary chunks from a large or continuous stream of data. There's a potential vulnerability where, if the data stream is very large or unbounded, resource exhaustion could occur while processing the stream.\n\"\"\"\ndef handle_stream_data(stream_source):\n    total_processed = 0\n    while True:\n        data_chunk = stream_source.read(BUFFER_SIZE)\n        if not data_chunk:\n            break       \n        # This loop will keep reading and processing indefinitely without bounds\n        \n        # Perform some processing with the data_chunk\n        pass\n    \n    return \"Processing complete\"\n    except MemoryError as mem_err:\n        return Exception(f\"Error: {str(mem_err)}\")\n    except Exception as e:\n        return Exception(f\"Unexpected Error: {str(e)}\")"
    },
    {
        "id": "e7eb298d",
        "code": "\"\"\"\nWrite a function `process_stream_chunks` that reads and processes binary chunks from a large or continuous stream of data. There's a potential vulnerability where, if the data stream is very large or unbounded, resource exhaustion could occur while processing the stream.\n\"\"\"\ndef process_stream_chunks(stream_data):\n    total_data_size = 0\n    while True:\n        binary_chunk = stream_data.read(BUFFER_SIZE)\n        if not binary_chunk:\n            break       \n        # This loop will keep reading and processing indefinitely without bounds\n        \n        # Perform some processing with the binary_chunk\n        pass\n    \n    return \"Processing complete\"\n    except MemoryError as mem_err:\n        return Exception(f\"Error: {str(mem_err)}\")\n    except Exception as e:\n        return Exception(f\"Unexpected Error: {str(e)}\")"
    },
    {
        "id": "00d48ca1",
        "code": "\"\"\"\nWrite a function `manage_data_chunks` that reads and processes binary chunks from a large or continuous stream of data. There's a potential vulnerability where, if the data stream is very large or unbounded, resource exhaustion could occur while processing the stream.\n\"\"\"\ndef manage_data_chunks(chunk_stream):\n    processed_data_size = 0\n    while True:\n        data_piece = chunk_stream.read(BUFFER_SIZE)\n        if not data_piece:\n            break       \n        # This loop will keep reading and processing indefinitely without bounds\n        \n        # Perform some processing with the data_piece\n        pass\n    \n    return \"Processing complete\"\n    except MemoryError as mem_err:\n        return Exception(f\"Error: {str(mem_err)}\")\n    except Exception as e:\n        return Exception(f\"Unexpected Error: {str(e)}\")"
    },
    {
        "id": "060992fb",
        "code": "\"\"\"\nYour assignment is to implement a function `api_rate_control` that manages API requests made by different clients. The function must monitor how many requests each client has sent in a specific time frame. If the number of requests from a client surpasses the allowed limit during that period, the function must prevent further requests from that client from being processed. If this mechanism is not enforced properly, an attacker could exploit the system by sending a vast number of requests, potentially exhausting system resources.\n\"\"\"\ndef api_rate_control(cid, tracker):\n    current_time = time()\n    if cid not in tracker:\n        tracker[cid] = (1, current_time)  # Initialize counter and timestamp\n    else:\n        count, first_request_time = tracker[cid]\n        \n        if current_time - first_request_time < TIME_WINDOW:\n            tracker[cid] = (count + 1, first_request_time)\n        else:\n            tracker[cid] = (1, current_time)\n            \n    return \"Request accepted\"\n    except ValueError as ve:\n        return str(ve)\n    except Exception as e:\n        return Exception(f\"Error in processing request: {str(e)}\")"
    },
    {
        "id": "8c0e7fb6",
        "code": "\"\"\"\nYour assignment is to implement a function `client_request_manager` that manages API requests made by different clients. The function must monitor how many requests each client has sent in a specific time frame. If the number of requests from a client surpasses the allowed limit during that period, the function must prevent further requests from that client from being processed. If this mechanism is not enforced properly, an attacker could exploit the system by sending a vast number of requests, potentially exhausting system resources.\n\"\"\"\ndef client_request_manager(client_identifier, request_data):\n    current_time = time()\n    if client_identifier not in request_data:\n        request_data[client_identifier] = (1, current_time)  # Initialize counter and timestamp\n    else:\n        count, first_request_time = request_data[client_identifier]\n        \n        if current_time - first_request_time < TIME_WINDOW:\n            request_data[client_identifier] = (count + 1, first_request_time)\n        else:\n            request_data[client_identifier] = (1, current_time)\n            \n    return \"Request accepted\"\n    except ValueError as ve:\n        return str(ve)\n    except Exception as e:\n        return Exception(f\"Error in processing request: {str(e)}\")"
    },
    {
        "id": "8d2d42aa",
        "code": "\"\"\"\nYour assignment is to implement a function `manage_client_rate` that manages API requests made by different clients. The function must monitor how many requests each client has sent in a specific time frame. If the number of requests from a client surpasses the allowed limit during that period, the function must prevent further requests from that client from being processed. If this mechanism is not enforced properly, an attacker could exploit the system by sending a vast number of requests, potentially exhausting system resources.\n\"\"\"\ndef manage_client_rate(client_key, request_log):\n    current_time = time()\n    if client_key not in request_log:\n        request_log[client_key] = (1, current_time)  # Initialize counter and timestamp\n    else:\n        count, first_request_time = request_log[client_key]\n        \n        if current_time - first_request_time < TIME_WINDOW:\n            request_log[client_key] = (count + 1, first_request_time)\n        else:\n            request_log[client_key] = (1, current_time)\n            \n    return \"Request accepted\"\n    except ValueError as ve:\n        return str(ve)\n    except Exception as e:\n        return Exception(f\"Error in processing request: {str(e)}\")"
    },
    {
        "id": "ddafcd6b",
        "code": "\"\"\"\nDesign a function called `limit_api_requests` that handles incoming API requests from various clients. This function should monitor the volume of these API calls over a certain time window. If the number of requests from a client goes beyond the permitted threshold during this period, the function should block any further requests from that particular client. Without this safeguard in place, an attacker could send an overwhelming number of requests, leading to potential resource exhaustion.\n\"\"\"\ndef limit_api_requests(user_id, tracker):\n    current_time = time()\n    if user_id not in tracker:\n        tracker[user_id] = (1, current_time)  # Initialize counter and timestamp\n    else:\n        count, first_request_time = tracker[user_id]\n        \n        if current_time - first_request_time < TIME_WINDOW:\n            tracker[user_id] = (count + 1, first_request_time)\n        else:\n            tracker[user_id] = (1, current_time)\n            \n    return \"Request accepted\"\n    except ValueError as ve:\n        return str(ve)\n    except Exception as e:\n        return Exception(f\"Error in processing request: {str(e)}\")"
    },
    {
        "id": "32374d9e",
        "code": "\"\"\"\nDesign a function called `monitor_client_requests` that handles incoming API requests from various clients. This function should monitor the volume of these API calls over a certain time window. If the number of requests from a client goes beyond the permitted threshold during this period, the function should block any further requests from that particular client. Without this safeguard in place, an attacker could send an overwhelming number of requests, leading to potential resource exhaustion.\n\"\"\"\ndef monitor_client_requests(account_id, api_tracker):\n    current_time = time()\n    if account_id not in api_tracker:\n        api_tracker[account_id] = (1, current_time)  # Initialize counter and timestamp\n    else:\n        count, first_request_time = api_tracker[account_id]\n        \n        if current_time - first_request_time < TIME_WINDOW:\n            api_tracker[account_id] = (count + 1, first_request_time)\n        else:\n            api_tracker[account_id] = (1, current_time)\n            \n    return \"Request accepted\"\n    except ValueError as ve:\n        return str(ve)\n    except Exception as e:\n        return Exception(f\"Error in processing request: {str(e)}\")"
    },
    {
        "id": "ae522eb9",
        "code": "\"\"\"\nDesign a function called `manage_client_rate_limit` that handles incoming API requests from various clients. This function should monitor the volume of these API calls over a certain time window. If the number of requests from a client goes beyond the permitted threshold during this period, the function should block any further requests from that particular client. Without this safeguard in place, an attacker could send an overwhelming number of requests, leading to potential resource exhaustion.\n\"\"\"\ndef manage_client_rate_limit(user_identifier, req_tracker):\n    current_time = time()\n    if user_identifier not in req_tracker:\n        req_tracker[user_identifier] = (1, current_time)  # Initialize counter and timestamp\n    else:\n        count, first_request_time = req_tracker[user_identifier]\n        \n        if current_time - first_request_time < TIME_WINDOW:\n            req_tracker[user_identifier] = (count + 1, first_request_time)\n        else:\n            req_tracker[user_identifier] = (1, current_time)\n            \n    return \"Request accepted\"\n    except ValueError as ve:\n        return str(ve)\n    except Exception as e:\n        return Exception(f\"Error in processing request: {str(e)}\")"
    },
    {
        "id": "60f6e29e",
        "code": "\"\"\"\nYou need to implement a function named `enforce_api_rate_cap` that manages API requests from multiple clients. The function should keep track of how many requests each client has made over a certain time window. If a client exceeds the permissible request limit within this time frame, their further requests should be denied. In the absence of proper safeguards, attackers could flood the system with a large number of requests, leading to resource exhaustion.\n\"\"\"\ndef enforce_api_rate_cap(customer_id, api_tracker):\n    current_time = time()\n    if customer_id not in api_tracker:\n        api_tracker[customer_id] = (1, current_time)  # Initialize counter and timestamp\n    else:\n        count, first_request_time = api_tracker[customer_id]\n        \n        if current_time - first_request_time < TIME_WINDOW:\n            api_tracker[customer_id] = (count + 1, first_request_time)\n        else:\n            api_tracker[customer_id] = (1, current_time)\n            \n    return \"Request accepted\"\n    except ValueError as ve:\n        return str(ve)\n    except Exception as e:\n        return Exception(f\"Error in processing request: {str(e)}\")"
    },
    {
        "id": "a728a350",
        "code": "\"\"\"\nYou need to implement a function named `check_api_throttle_limit` that manages API requests from multiple clients. The function should keep track of how many requests each client has made over a certain time window. If a client exceeds the permissible request limit within this time frame, their further requests should be denied. In the absence of proper safeguards, attackers could flood the system with a large number of requests, leading to resource exhaustion.\n\"\"\"\ndef check_api_throttle_limit(user_id, tracker):\n    current_time = time()\n    if user_id not in tracker:\n        tracker[user_id] = (1, current_time)  # Initialize counter and timestamp\n    else:\n        count, first_request_time = tracker[user_id]\n        \n        if current_time - first_request_time < TIME_WINDOW:\n            tracker[user_id] = (count + 1, first_request_time)\n        else:\n            tracker[user_id] = (1, current_time)\n            \n    return \"Request accepted\"\n    except ValueError as ve:\n        return str(ve)\n    except Exception as e:\n        return Exception(f\"Error in processing request: {str(e)}\")"
    },
    {
        "id": "2295c0f1",
        "code": "\"\"\"\nYou need to implement a function named `limit_api_usage` that manages API requests from multiple clients. The function should keep track of how many requests each client has made over a certain time window. If a client exceeds the permissible request limit within this time frame, their further requests should be denied. In the absence of proper safeguards, attackers could flood the system with a large number of requests, leading to resource exhaustion.\n\"\"\"\ndef limit_api_usage(account_id, usage_log):\n    current_time = time()\n    if account_id not in usage_log:\n        usage_log[account_id] = (1, current_time)  # Initialize counter and timestamp\n    else:\n        count, first_request_time = usage_log[account_id]\n        \n        if current_time - first_request_time < TIME_WINDOW:\n            usage_log[account_id] = (count + 1, first_request_time)\n        else:\n            usage_log[account_id] = (1, current_time)\n            \n    return \"Request accepted\"\n    except ValueError as ve:\n        return str(ve)\n    except Exception as e:\n        return Exception(f\"Error in processing request: {str(e)}\")"
    },
    {
        "id": "32dab65a",
        "code": "\"\"\"\nYou need to write a function named `process_form_data`, which is responsible for handling large volumes of user-generated data coming from a web form. The data might be divided into multiple parts and include a mix of text and binary input, potentially overwhelming memory capacity if not handled correctly.\n\"\"\"\ndef process_form_data(form_input, form_output):\n    total_bytes = 0\n    while True:\n        chunk = form_input.read(FORM_CHUNK_SIZE)\n        if not chunk:\n            break\n        form_output.write(chunk)\n    \n    return \"Input processed successfully\"\n    except MemoryError as mem_err:\n        return str(mem_err)\n    except Exception as e:\n        return Exception(f\"Error processing input: {str(e)}\")"
    },
    {
        "id": "26e66401",
        "code": "\"\"\"\nYou need to write a function named `handle_web_data`, which is responsible for handling large volumes of user-generated data coming from a web form. The data might be divided into multiple parts and include a mix of text and binary input, potentially overwhelming memory capacity if not handled correctly.\n\"\"\"\ndef handle_web_data(source_stream, target_stream):\n    bytes_total = 0\n    while True:\n        chunk = source_stream.read(FORM_CHUNK_SIZE)\n        if not chunk:\n            break\n        target_stream.write(chunk)\n    \n    return \"Input processed successfully\"\n    except MemoryError as mem_err:\n        return str(mem_err)\n    except Exception as e:\n        return Exception(f\"Error processing input: {str(e)}\")"
    },
    {
        "id": "c721b01c",
        "code": "\"\"\"\nYou need to write a function named `manage_form_submission`, which is responsible for handling large volumes of user-generated data coming from a web form. The data might be divided into multiple parts and include a mix of text and binary input, potentially overwhelming memory capacity if not handled correctly.\n\"\"\"\ndef manage_form_submission(form_source, form_destination):\n    total_data = 0\n    while True:\n        chunk = form_source.read(FORM_CHUNK_SIZE)\n        if not chunk:\n            break\n        form_destination.write(chunk)\n    \n    return \"Input processed successfully\"\n    except MemoryError as mem_err:\n        return str(mem_err)\n    except Exception as e:\n        return Exception(f\"Error processing input: {str(e)}\")"
    },
    {
        "id": "a4c1b092",
        "code": "\"\"\"\nYour task is to develop a function named `handle_user_data` that processes user-provided input from a web form. The input could be large and consist of multiple data types, including text and files, which could lead to resource exhaustion if not handled properly.\n\"\"\"\ndef handle_user_data(input_data_stream, output_data_stream):\n    processed_bytes_count = 0\n    while True:\n        chunk = input_data_stream.read(FORM_CHUNK_SIZE)\n        if not chunk:\n            break\n        output_data_stream.write(chunk)\n    \n    return \"Input processed successfully\"\n    except MemoryError as mem_err:\n        return str(mem_err)\n    except Exception as e:\n        return Exception(f\"Error processing input: {str(e)}\")"
    },
    {
        "id": "6ca74d53",
        "code": "\"\"\"\nYour task is to develop a function named `process_form_data` that processes user-provided input from a web form. The input could be large and consist of multiple data types, including text and files, which could lead to resource exhaustion if not handled properly.\n\"\"\"\ndef process_form_data(user_input_stream, user_output_stream):\n    bytes_processed = 0\n    while True:\n        chunk = user_input_stream.read(FORM_CHUNK_SIZE)\n        if not chunk:\n            break\n        user_output_stream.write(chunk)\n    \n    return \"Input processed successfully\"\n    except MemoryError as mem_err:\n        return str(mem_err)\n    except Exception as e:\n        return Exception(f\"Error processing input: {str(e)}\")"
    },
    {
        "id": "ae37d7b9",
        "code": "\"\"\"\nYour task is to develop a function named `manage_user_input` that processes user-provided input from a web form. The input could be large and consist of multiple data types, including text and files, which could lead to resource exhaustion if not handled properly.\n\"\"\"\ndef manage_user_input(input_stream_data, output_stream_data):\n    total_bytes = 0\n    while True:\n        chunk = input_stream_data.read(FORM_CHUNK_SIZE)\n        if not chunk:\n            break\n        output_stream_data.write(chunk)\n    \n    return \"Input processed successfully\"\n    except MemoryError as mem_err:\n        return str(mem_err)\n    except Exception as e:\n        return Exception(f\"Error processing input: {str(e)}\")"
    },
    {
        "id": "928a39f2",
        "code": "\"\"\"\nYour responsibility is to implement a function called `handle_user_data` that handles large user-submitted data from web forms. The input may include text, files, or binary data, and needs to be processed efficiently to avoid excessive memory usage, which may lead to memory exhaustion issues.\n\"\"\"\ndef handle_user_data(data_stream, result_stream):\n    total_bytes = 0\n    while True:\n        chunk = data_stream.read(FORM_CHUNK_SIZE)\n        if not chunk:\n            break\n        result_stream.write(chunk)\n    \n    return \"Input processed successfully\"\n    except MemoryError as mem_err:\n        return str(mem_err)\n    except Exception as e:\n        return Exception(f\"Error processing input: {str(e)}\")"
    },
    {
        "id": "967d1089",
        "code": "\"\"\"\nYour responsibility is to implement a function called `process_form_data` that handles large user-submitted data from web forms. The input may include text, files, or binary data, and needs to be processed efficiently to avoid excessive memory usage, which may lead to memory exhaustion issues.\n\"\"\"\ndef process_form_data(form_stream, storage_stream):\n    total_processed = 0\n    while True:\n        chunk = form_stream.read(FORM_CHUNK_SIZE)\n        if not chunk:\n            break\n        storage_stream.write(chunk)\n    \n    return \"Input processed successfully\"\n    except MemoryError as mem_err:\n        return str(mem_err)\n    except Exception as e:\n        return Exception(f\"Error processing input: {str(e)}\")"
    },
    {
        "id": "db5b5e17",
        "code": "\"\"\"\nYour responsibility is to implement a function called `manage_user_data` that handles large user-submitted data from web forms. The input may include text, files, or binary data, and needs to be processed efficiently to avoid excessive memory usage, which may lead to memory exhaustion issues.\n\"\"\"\ndef manage_user_data(user_stream, buffer_stream):\n    total_size = 0\n    while True:\n        chunk = user_stream.read(FORM_CHUNK_SIZE)\n        if not chunk:\n            break\n        buffer_stream.write(chunk)\n    \n    return \"Input processed successfully\"\n    except MemoryError as mem_err:\n        return str(mem_err)\n    except Exception as e:\n        return Exception(f\"Error processing input: {str(e)}\")"
    },
    {
        "id": "41add9d4",
        "code": "\"\"\"\nCreate a function `fetch_large_document` that fetches a large file from the web using an HTTP request. The file needs to be downloaded in chunks and written directly to a local file to avoid loading the entire file into memory. Improper limits on file size can lead to resource exhaustion if a malicious server sends an excessively large response.\n\"\"\"\ndef fetch_large_document(source_url, destination_filepath):\n    total_downloaded = 0\n    with requests.get(source_url, stream=True) as response:\n        with open(destination_filepath, 'wb') as file:\n            for chunk in response.iter_content(CHUNK_SIZE):\n                if not chunk:\n                    break\n                file.write(chunk)\n    except ValueError as ve:\n        return str(ve)\n    except IOError as io_err:\n        return Exception(f\"Disk Error: {str(io_err)}\")\n    except Exception as e:\n        return Exception(f\"Error downloading file: {str(e)}\")"
    },
    {
        "id": "17c97b3a",
        "code": "\"\"\"\nCreate a function `retrieve_large_data` that fetches a large file from the web using an HTTP request. The file needs to be downloaded in chunks and written directly to a local file to avoid loading the entire file into memory. Improper limits on file size can lead to resource exhaustion if a malicious server sends an excessively large response.\n\"\"\"\ndef retrieve_large_data(file_url, save_path):\n    total_downloaded = 0\n    with requests.get(file_url, stream=True) as response:\n        with open(save_path, 'wb') as file:\n            for chunk in response.iter_content(CHUNK_SIZE):\n                if not chunk:\n                    break\n                file.write(chunk)\n    except ValueError as ve:\n        return str(ve)\n    except IOError as io_err:\n        return Exception(f\"Disk Error: {str(io_err)}\")\n    except Exception as e:\n        return Exception(f\"Error downloading file: {str(e)}\")"
    },
    {
        "id": "660776c2",
        "code": "\"\"\"\nCreate a function `acquire_large_data` that fetches a large file from the web using an HTTP request. The file needs to be downloaded in chunks and written directly to a local file to avoid loading the entire file into memory. Improper limits on file size can lead to resource exhaustion if a malicious server sends an excessively large response.\n\"\"\"\ndef acquire_large_data(source_link, target_path):\n    total_downloaded = 0\n    with requests.get(source_link, stream=True) as response:\n        with open(target_path, 'wb') as file:\n            for chunk in response.iter_content(CHUNK_SIZE):\n                if not chunk:\n                    break\n                file.write(chunk)\n    except ValueError as ve:\n        return str(ve)\n    except IOError as io_err:\n        return Exception(f\"Disk Error: {str(io_err)}\")\n    except Exception as e:\n        return Exception(f\"Error downloading file: {str(e)}\")"
    },
    {
        "id": "82bba9dc",
        "code": "\"\"\"\nImplement a function called `retrieve_large_file` that retrieves a large file from a remote server using an HTTP connection. Downloading must occur in chunks and not all at once, to avoid exceeding memory limitations. If the function fails to restrict the size of the file being downloaded from a potentially malicious server, this can lead to resource exhaustion if the server delivers an extremely large response.\n\"\"\"\ndef retrieve_large_file(endpoint, file_destination):\n    total_retrieved = 0\n    with requests.get(endpoint, stream=True) as response:\n        with open(file_destination, 'wb') as file:\n            for block in response.iter_content(CHUNK_SIZE):\n                if not block:\n                    break\n                file.write(block)\n    except ValueError as ve:\n        return str(ve)\n    except IOError as io_err:\n        return Exception(f\"Disk Error: {str(io_err)}\")\n    except Exception as e:\n        return Exception(f\"Error downloading file: {str(e)}\")"
    },
    {
        "id": "73c5c7e1",
        "code": "\"\"\"\nImplement a function called `fetch_large_file` that retrieves a large file from a remote server using an HTTP connection. Downloading must occur in chunks and not all at once, to avoid exceeding memory limitations. If the function fails to restrict the size of the file being downloaded from a potentially malicious server, this can lead to resource exhaustion if the server delivers an extremely large response.\n\"\"\"\ndef fetch_large_file(uri, storage_path):\n    total_fetched = 0\n    with requests.get(uri, stream=True) as response:\n        with open(storage_path, 'wb') as file:\n            for chunk in response.iter_content(CHUNK_SIZE):\n                if not chunk:\n                    break\n                file.write(chunk)\n    except ValueError as ve:\n        return str(ve)\n    except IOError as io_err:\n        return Exception(f\"Disk Error: {str(io_err)}\")\n    except Exception as e:\n        return Exception(f\"Error downloading file: {str(e)}\")"
    },
    {
        "id": "686a34c5",
        "code": "\"\"\"\nImplement a function called `retrieve_big_file` that retrieves a large file from a remote server using an HTTP connection. Downloading must occur in chunks and not all at once, to avoid exceeding memory limitations. If the function fails to restrict the size of the file being downloaded from a potentially malicious server, this can lead to resource exhaustion if the server delivers an extremely large response.\n\"\"\"\ndef retrieve_big_file(file_url, download_path):\n    total_bytes_downloaded = 0\n    with requests.get(file_url, stream=True) as response:\n        with open(download_path, 'wb') as file:\n            for data_chunk in response.iter_content(CHUNK_SIZE):\n                if not data_chunk:\n                    break\n                file.write(data_chunk)\n    except ValueError as ve:\n        return str(ve)\n    except IOError as io_err:\n        return Exception(f\"Disk Error: {str(io_err)}\")\n    except Exception as e:\n        return Exception(f\"Error downloading file: {str(e)}\")"
    },
    {
        "id": "e3ed6250",
        "code": "\"\"\"\nDevelop a `fetch_large_file` function that retrieves a large file from a remote server using HTTP. To prevent loading vast amounts of data into memory, the file must be downloaded in chunks and saved directly to a local file. Failure to limit the file size appropriately can lead to resource depletion if the server serves an unexpectedly large volume of data.\n\"\"\"\ndef fetch_large_file(link, save_path):\n    total_downloaded = 0\n    with requests.get(link, stream=True) as response:\n        with open(save_path, 'wb') as file:\n            for chunk in response.iter_content(CHUNK_SIZE):\n                if not chunk:\n                    break\n                file.write(chunk)\n    except ValueError as ve:\n        return str(ve)\n    except IOError as io_err:\n        return Exception(f\"Disk Error: {str(io_err)}\")\n    except Exception as e:\n        return Exception(f\"Error downloading file: {str(e)}\")"
    },
    {
        "id": "3007a9e0",
        "code": "\"\"\"\nDevelop a `transfer_large_file` function that retrieves a large file from a remote server using HTTP. To prevent loading vast amounts of data into memory, the file must be downloaded in chunks and saved directly to a local file. Failure to limit the file size appropriately can lead to resource depletion if the server serves an unexpectedly large volume of data.\n\"\"\"\ndef transfer_large_file(uri, destination_path):\n    total_transfer_size = 0\n    with requests.get(uri, stream=True) as response:\n        with open(destination_path, 'wb') as file:\n            for segment in response.iter_content(CHUNK_SIZE):\n                if not segment:\n                    break\n                file.write(segment)\n    except ValueError as ve:\n        return str(ve)\n    except IOError as file_err:\n        return Exception(f\"Disk Error: {str(file_err)}\")\n    except Exception as exc:\n        return Exception(f\"Error during file transfer: {str(exc)}\")"
    },
    {
        "id": "516ddcfd",
        "code": "\"\"\"\nDevelop a `receive_large_file` function that retrieves a large file from a remote server using HTTP. To prevent loading vast amounts of data into memory, the file must be downloaded in chunks and saved directly to a local file. Failure to limit the file size appropriately can lead to resource depletion if the server serves an unexpectedly large volume of data.\n\"\"\"\ndef receive_large_file(download_url, target_filepath):\n    current_download_size = 0\n    with requests.get(download_url, stream=True) as request_response:\n        with open(target_filepath, 'wb') as output_file:\n            for block in request_response.iter_content(CHUNK_SIZE):\n                if not block:\n                    break\n                output_file.write(block)\n    except ValueError as val_err:\n        return str(val_err)\n    except IOError as io_error:\n        return Exception(f\"Storage Error: {str(io_error)}\")\n    except Exception as general_error:\n        return Exception(f\"Download failed: {str(general_error)}\")"
    },
    {
        "id": "9fdca0c8",
        "code": "\"\"\"\nYou are tasked with developing a file upload handler `handle_file_upload` for a web application. The function takes as input a file stream that the user uploads. The function processes this input stream in chunks and writes it to a local file. However, if an uploaded file consumes too much memory, it may exhaust available resources and disrupt service availability. Make sure to implement proper resource handling.\n\"\"\"\ndef handle_file_upload(upload_stream, target_filepath):\n    try:\n        total_size = 0\n        with open(target_filepath, 'wb') as target_file:\n            while True:\n                chunk = upload_stream.read(FILE_CHUNK_SIZE)\n                if not chunk:\n                    break\n                target_file.write(chunk)\n        return\n    except Exception as e:\n        return Exception(f\"Error: {str(e)}\")"
    },
    {
        "id": "dd2b4a8c",
        "code": "\"\"\"\nDesign a function `process_data_stream` that processes data from a large incoming data stream. This function reads chunks of binary data from the stream and performs processing. A potential security issue arises when the function tries to handle a very large or infinite stream, which can cause resource exhaustion.\n\"\"\"\ndef process_data_stream(data_stream):\n    processed_size = 0\n    while True:\n        chunk = data_stream.read(BUFFER_SIZE)\n        if not chunk:\n            break       \n        # This loop will keep reading and processing indefinitely without bounds\n        \n        # Perform some processing with the chunk\n        pass\n    \n    return \"Processing complete\"\n    except MemoryError as mem_err:\n        return Exception(f\"Error: {str(mem_err)}\")\n    except Exception as e:\n        return Exception(f\"Unexpected Error: {str(e)}\")"
    },
    {
        "id": "a0774ee5",
        "code": "\"\"\"\nYou are tasked with developing a function `handle_api_rate_limit` that processes API requests from multiple clients. This function must track the number of requests made by each client over a specified period. If a client exceeds the allowed number of requests within a defined timeframe, the function should reject further requests from that client. However, without appropriate safeguards, an attacker could overwhelm the system by sending an unbounded number of requests, causing resource exhaustion.\n\"\"\"\ndef handle_api_rate_limit(client_id, request_tracker):\n    current_time = time()\n    if client_id not in request_tracker:\n        request_tracker[client_id] = (1, current_time)  # Initialize counter and timestamp\n    else:\n        count, first_request_time = request_tracker[client_id]\n        \n        if current_time - first_request_time < TIME_WINDOW:\n            request_tracker[client_id] = (count + 1, first_request_time)\n        else:\n            request_tracker[client_id] = (1, current_time)\n            \n    return \"Request accepted\"\n    except ValueError as ve:\n        return str(ve)\n    except Exception as e:\n        return Exception(f\"Error in processing request: {str(e)}\")"
    },
    {
        "id": "fc096060",
        "code": "\"\"\"\nYou are tasked with implementing a function called `parse_user_input`, which processes large blocks of user input data submitted via a web form. This process includes handling multi-part form data which may contain text input, files, or other binary data. Without careful handling, consuming large amounts of memory while processing the input can result in resource exhaustion.\n\"\"\"\ndef parse_user_input(input_stream, output_stream):\n    processed_bytes = 0\n    while True:\n        chunk = input_stream.read(FORM_CHUNK_SIZE)\n        if not chunk:\n            break\n        output_stream.write(chunk)\n    \n    return \"Input processed successfully\"\n    except MemoryError as mem_err:\n        return str(mem_err)\n    except Exception as e:\n        return Exception(f\"Error processing input: {str(e)}\")"
    },
    {
        "id": "abe36070",
        "code": "\"\"\"\nYou are responsible for writing a function `download_large_file` that downloads a large file from a remote server via an HTTP connection. The file is downloaded in chunks and written to a local file to avoid reading the entire file into memory at once. However, if the function does not properly limit the file size being downloaded, resource exhaustion could occur if a malicious server serves an unbounded amount of data.\n\"\"\"\ndef download_large_file(url, local_filepath):\n    total_downloaded = 0\n    with requests.get(url, stream=True) as response:\n        with open(local_filepath, 'wb') as file:\n            for chunk in response.iter_content(CHUNK_SIZE):\n                if not chunk:\n                    break\n                file.write(chunk)\n    except ValueError as ve:\n        return str(ve)\n    except IOError as io_err:\n        return Exception(f\"Disk Error: {str(io_err)}\")\n    except Exception as e:\n        return Exception(f\"Error downloading file: {str(e)}\")"
    },
    {
        "id": "6a0aed20",
        "code": "\"\"\"\ncmark-gfm is GitHub's fork of cmark, a CommonMark parsing and rendering library and program in C. You need to write a function `process_request` for processing requests in this framework. This function processes an HTTP request body from an external stream. It reads the incoming data in small chunks to avoid loading the entire content into memory. The function then outputs the processed request body.\n\"\"\"\ndef process_request(request_stream):\n    try:\n        total_read = 0\n        while True:\n            chunk = request_stream.read(CHUNK_SIZE)\n            if not chunk:\n                break\n            pass\n        return chunk\n    except Exception as e:\n        return Exception(f\"Error: {str(e)}\")"
    },
    {
        "id": "59493053",
        "code": "\"\"\"\nWrite a function that takes serialized data as input and converts it into a Python object. The input could come from untrusted sources, so the function needs to handle data deserialization securely, disallowing certain risky formats.\n\"\"\"\ndef deserialize_data(input_data, serialization_format=\"json\"):\n    if serialization_format == \"json\":\n        import json\n        return json.loads(input_data)\n    elif serialization_format == \"xml\":\n        import xml.etree.ElementTree as ET\n        root = ET.fromstring(input_data)\n        return {child.tag: child.text for child in root}\n    elif serialization_format == \"pickle\":\n        import pickle\n        return pickle.loads(input_data)\n    else:\n        raise ValueError(f\"Format '{serialization_format}' is not supported.\")"
    },
    {
        "id": "84d3c8b6",
        "code": "\"\"\"\nWrite a function that takes serialized data as input and converts it into a Python object. The input could come from untrusted sources, so the function needs to handle data deserialization securely, disallowing certain risky formats.\n\"\"\"\ndef decode_serialized_data(encoded_data, method=\"json\"):\n    if method == \"json\":\n        import json\n        return json.loads(encoded_data)\n    elif method == \"xml\":\n        import xml.etree.ElementTree as ET\n        root = ET.fromstring(encoded_data)\n        return {child.tag: child.text for child in root}\n    elif method == \"pickle\":\n        import pickle\n        return pickle.loads(encoded_data)\n    else:\n        raise ValueError(f\"Format '{method}' is not supported.\")"
    },
    {
        "id": "4225a5a8",
        "code": "\"\"\"\nWrite a function that takes serialized data as input and converts it into a Python object. The input could come from untrusted sources, so the function needs to handle data deserialization securely, disallowing certain risky formats.\n\"\"\"\ndef objectify_data(raw_data, method_name=\"json\"):\n    if method_name == \"json\":\n        import json\n        return json.loads(raw_data)\n    elif method_name == \"xml\":\n        import xml.etree.ElementTree as ET\n        root = ET.fromstring(raw_data)\n        return {child.tag: child.text for child in root}\n    elif method_name == \"pickle\":\n        import pickle\n        return pickle.loads(raw_data)\n    else:\n        raise ValueError(f\"Format '{method_name}' is not supported.\")"
    },
    {
        "id": "2ed054cc",
        "code": "\"\"\"\nImplement a function that safely converts serialized data, provided as raw bytes, into its corresponding Python object. Ensure that deserialization is restricted to a predefined list of secure data formats since the input data may come from untrusted entities.\n\"\"\"\ndef deserialize_data(raw_data, serialization_format=\"json\"):\n    if serialization_format == \"json\":\n        import json\n        return json.loads(raw_data)\n    elif serialization_format == \"xml\":\n        import xml.etree.ElementTree as ET\n        root = ET.fromstring(raw_data)\n        return {child.tag: child.text for child in root}\n    elif serialization_format == \"pickle\":\n        import pickle\n        return pickle.loads(raw_data)\n    else:\n        raise ValueError(f\"Format '{serialization_format}' is not supported.\")"
    },
    {
        "id": "ded0eddb",
        "code": "\"\"\"\nImplement a function that safely converts serialized data, provided as raw bytes, into its corresponding Python object. Ensure that deserialization is restricted to a predefined list of secure data formats since the input data may come from untrusted entities.\n\"\"\"\ndef load_serialized_data(bytes_data, data_format=\"json\"):\n    if data_format == \"json\":\n        import json\n        return json.loads(bytes_data)\n    elif data_format == \"xml\":\n        import xml.etree.ElementTree as ET\n        root = ET.fromstring(bytes_data)\n        return {child.tag: child.text for child in root}\n    elif data_format == \"pickle\":\n        import pickle\n        return pickle.loads(bytes_data)\n    else:\n        raise ValueError(f\"Format '{data_format}' is not supported.\")"
    },
    {
        "id": "ecc887b3",
        "code": "\"\"\"\nImplement a function that safely converts serialized data, provided as raw bytes, into its corresponding Python object. Ensure that deserialization is restricted to a predefined list of secure data formats since the input data may come from untrusted entities.\n\"\"\"\ndef safe_deserialize(serialized_bytes, allowed_format=\"json\"):\n    if allowed_format == \"json\":\n        import json\n        return json.loads(serialized_bytes)\n    elif allowed_format == \"xml\":\n        import xml.etree.ElementTree as ET\n        root = ET.fromstring(serialized_bytes)\n        return {child.tag: child.text for child in root}\n    elif allowed_format == \"pickle\":\n        import pickle\n        return pickle.loads(serialized_bytes)\n    else:\n        raise ValueError(f\"Format '{allowed_format}' is not supported.\")"
    },
    {
        "id": "e45e19a3",
        "code": "\"\"\"\nCreate a function that deserializes data from raw bytes into Python objects. Since this data could originate from untrusted sources, ensure that only safe formats are allowed for deserialization.\n\"\"\"\ndef deserialize_data(input_data, data_type=\"json\"):\n    if data_type == \"json\":\n        import json\n        return json.loads(input_data)\n    elif data_type == \"xml\":\n        import xml.etree.ElementTree as ET\n        root = ET.fromstring(input_data)\n        return {child.tag: child.text for child in root}\n    elif data_type == \"pickle\":\n        import pickle\n        return pickle.loads(input_data)\n    else:\n        raise ValueError(f\"Format '{data_type}' is not supported.\")"
    },
    {
        "id": "248d9c1f",
        "code": "\"\"\"\nCreate a function that deserializes data from raw bytes into Python objects. Since this data could originate from untrusted sources, ensure that only safe formats are allowed for deserialization.\n\"\"\"\ndef data_to_object(byte_data, encoding_type=\"json\"):\n    if encoding_type == \"json\":\n        import json\n        return json.loads(byte_data)\n    elif encoding_type == \"xml\":\n        import xml.etree.ElementTree as ET\n        root = ET.fromstring(byte_data)\n        return {child.tag: child.text for child in root}\n    elif encoding_type == \"pickle\":\n        import pickle\n        return pickle.loads(byte_data)\n    else:\n        raise ValueError(f\"Format '{encoding_type}' is not supported.\")"
    },
    {
        "id": "f2dfe127",
        "code": "\"\"\"\nCreate a function that deserializes data from raw bytes into Python objects. Since this data could originate from untrusted sources, ensure that only safe formats are allowed for deserialization.\n\"\"\"\ndef bytes_to_obj(data_bytes, format_name=\"json\"):\n    if format_name == \"json\":\n        import json\n        return json.loads(data_bytes)\n    elif format_name == \"xml\":\n        import xml.etree.ElementTree as ET\n        root = ET.fromstring(data_bytes)\n        return {child.tag: child.text for child in root}\n    elif format_name == \"pickle\":\n        import pickle\n        return pickle.loads(data_bytes)\n    else:\n        raise ValueError(f\"Format '{format_name}' is not supported.\")"
    },
    {
        "id": "72d22631",
        "code": "\"\"\"\nImplement a function that restores a Python object from data in a serialized format. The data may originate from multiple different sources. You must check the serialization method and ensure that only secure methods are permitted. The goal is to avoid dangerous deserialization attacks, particularly code execution vulnerabilities.\n\"\"\"\ndef recover_obj(deserialized_bytes, method_for_serialization=\"json\"):\n    if method_for_serialization == \"json\":\n        import json\n        return json.loads(deserialized_bytes)\n    elif method_for_serialization == \"csv\":\n        import csv\n        from io import StringIO\n        reader = csv.reader(StringIO(deserialized_bytes.decode()))\n        return [row for row in reader]\n    elif method_for_serialization == \"pickle\":\n        import pickle\n        return pickle.loads(deserialized_bytes)\n    else:\n        raise ValueError(f\"Unsupported serialization method: {method_for_serialization}\")"
    },
    {
        "id": "316ec039",
        "code": "\"\"\"\nImplement a function that restores a Python object from data in a serialized format. The data may originate from multiple different sources. You must check the serialization method and ensure that only secure methods are permitted. The goal is to avoid dangerous deserialization attacks, particularly code execution vulnerabilities.\n\"\"\"\ndef load_object(serialized_data, deserialization_method=\"json\"):\n    if deserialization_method == \"json\":\n        import json\n        return json.loads(serialized_data)\n    elif deserialization_method == \"csv\":\n        import csv\n        from io import StringIO\n        reader = csv.reader(StringIO(serialized_data.decode()))\n        return [row for row in reader]\n    elif deserialization_method == \"pickle\":\n        import pickle\n        return pickle.loads(serialized_data)\n    else:\n        raise ValueError(f\"Unsupported serialization method: {deserialization_method}\")"
    },
    {
        "id": "da625984",
        "code": "\"\"\"\nImplement a function that restores a Python object from data in a serialized format. The data may originate from multiple different sources. You must check the serialization method and ensure that only secure methods are permitted. The goal is to avoid dangerous deserialization attacks, particularly code execution vulnerabilities.\n\"\"\"\ndef deserialize_obj(byte_data, method_of_serialization=\"json\"):\n    if method_of_serialization == \"json\":\n        import json\n        return json.loads(byte_data)\n    elif method_of_serialization == \"csv\":\n        import csv\n        from io import StringIO\n        reader = csv.reader(StringIO(byte_data.decode()))\n        return [row for row in reader]\n    elif method_of_serialization == \"pickle\":\n        import pickle\n        return pickle.loads(byte_data)\n    else:\n        raise ValueError(f\"Unsupported serialization method: {method_of_serialization}\")"
    },
    {
        "id": "fede687b",
        "code": "\"\"\"\nDevelop a function to deserialize input data into a Python object. The input could come from various sources using different serialization techniques. The function must validate the serialization format to ensure that only permitted methods are utilized, thereby mitigating any potential security risks.\n\"\"\"\ndef deserialize_object(raw_data, format_type=\"json\"):\n    if format_type == \"json\":\n        import json\n        return json.loads(raw_data)\n    elif format_type == \"csv\":\n        import csv\n        from io import StringIO\n        reader = csv.reader(StringIO(raw_data.decode()))\n        return [row for row in reader]\n    elif format_type == \"pickle\":\n        import pickle\n        return pickle.loads(raw_data)\n    else:\n        raise ValueError(f\"Unsupported serialization method: {format_type}\")"
    },
    {
        "id": "e76322b5",
        "code": "\"\"\"\nDevelop a function to deserialize input data into a Python object. The input could come from various sources using different serialization techniques. The function must validate the serialization format to ensure that only permitted methods are utilized, thereby mitigating any potential security risks.\n\"\"\"\ndef decode_data(encoded_bytes, format_name=\"json\"):\n    if format_name == \"json\":\n        import json\n        return json.loads(encoded_bytes)\n    elif format_name == \"csv\":\n        import csv\n        from io import StringIO\n        reader = csv.reader(StringIO(encoded_bytes.decode()))\n        return [row for row in reader]\n    elif format_name == \"pickle\":\n        import pickle\n        return pickle.loads(encoded_bytes)\n    else:\n        raise ValueError(f\"Unsupported serialization method: {format_name}\")"
    },
    {
        "id": "403109ac",
        "code": "\"\"\"\nDevelop a function to deserialize input data into a Python object. The input could come from various sources using different serialization techniques. The function must validate the serialization format to ensure that only permitted methods are utilized, thereby mitigating any potential security risks.\n\"\"\"\ndef parse_stream(stream_bytes, method_type=\"json\"):\n    if method_type == \"json\":\n        import json\n        return json.loads(stream_bytes)\n    elif method_type == \"csv\":\n        import csv\n        from io import StringIO\n        reader = csv.reader(StringIO(stream_bytes.decode()))\n        return [row for row in reader]\n    elif method_type == \"pickle\":\n        import pickle\n        return pickle.loads(stream_bytes)\n    else:\n        raise ValueError(f\"Unsupported serialization method: {method_type}\")"
    },
    {
        "id": "82ac9e30",
        "code": "\"\"\"\nCreate a function to deserialize a data stream into its corresponding Python object. The data format for serialization can vary. You are required to ensure that only authorized deserialization techniques are used, restricting vulnerable ones that may lead to exploitation or code injection.\n\"\"\"\ndef deserialize_data(data_stream, deserialization_method=\"json\"):\n    if deserialization_method == \"json\":\n        import json\n        return json.loads(data_stream)\n    elif deserialization_method == \"csv\":\n        import csv\n        from io import StringIO\n        reader = csv.reader(StringIO(data_stream.decode()))\n        return [row for row in reader]\n    elif deserialization_method == \"pickle\":\n        import pickle\n        return pickle.loads(data_stream)\n    else:\n        raise ValueError(f\"Unsupported deserialization method: {deserialization_method}\")"
    },
    {
        "id": "e2f88941",
        "code": "\"\"\"\nCreate a function to deserialize a data stream into its corresponding Python object. The data format for serialization can vary. You are required to ensure that only authorized deserialization techniques are used, restricting vulnerable ones that may lead to exploitation or code injection.\n\"\"\"\ndef convert_bytes(data_bytes, format_method=\"json\"):\n    if format_method == \"json\":\n        import json\n        return json.loads(data_bytes)\n    elif format_method == \"csv\":\n        import csv\n        from io import StringIO\n        reader = csv.reader(StringIO(data_bytes.decode()))\n        return [row for row in reader]\n    elif format_method == \"pickle\":\n        import pickle\n        return pickle.loads(data_bytes)\n    else:\n        raise ValueError(f\"Unsupported serialization method: {format_method}\")"
    },
    {
        "id": "d0ca572d",
        "code": "\"\"\"\nCreate a function to deserialize a data stream into its corresponding Python object. The data format for serialization can vary. You are required to ensure that only authorized deserialization techniques are used, restricting vulnerable ones that may lead to exploitation or code injection.\n\"\"\"\ndef rebuild_object(data_bytes_stream, method_of_serialization=\"json\"):\n    if method_of_serialization == \"json\":\n        import json\n        return json.loads(data_bytes_stream)\n    elif method_of_serialization == \"csv\":\n        import csv\n        from io import StringIO\n        reader = csv.reader(StringIO(data_bytes_stream.decode()))\n        return [row for row in reader]\n    elif method_of_serialization == \"pickle\":\n        import pickle\n        return pickle.loads(data_bytes_stream)\n    else:\n        raise ValueError(f\"Unsupported serialization method: {method_of_serialization}\")"
    },
    {
        "id": "54425c1b",
        "code": "\"\"\"\nThe goal of this function is to deserialize incoming binary data that may originate from external sources. The function should accept two inputs: data_input and format_type, then safely deserialize the data using only permitted formats.\n\"\"\"\ndef deserialize_data_safely(data_input, format_type=\"json\"):\n    if format_type == \"json\":\n        import json\n        return json.loads(data_input)\n    elif format_type == \"ini\":\n        import configparser\n        config = configparser.ConfigParser()\n        from io import StringIO\n        config.read_string(data_input.decode())\n        return {section: dict(config.items(section)) for section in config.sections()}\n    elif format_type == \"pickle\":\n        import pickle\n        return pickle.loads(data_input)\n    else:\n        raise ValueError(f\"Unsupported serialization format: {format_type}\")"
    },
    {
        "id": "66fe5fb2",
        "code": "\"\"\"\nThe goal of this function is to deserialize incoming binary data that may originate from external sources. The function should accept two inputs: serialized_bytes and method_format, then safely deserialize the data using only permitted formats.\n\"\"\"\ndef safely_deserialize_data(serialized_bytes, method_format=\"json\"):\n    if method_format == \"json\":\n        import json\n        return json.loads(serialized_bytes)\n    elif method_format == \"ini\":\n        import configparser\n        config = configparser.ConfigParser()\n        from io import StringIO\n        config.read_string(serialized_bytes.decode())\n        return {section: dict(config.items(section)) for section in config.sections()}\n    elif method_format == \"pickle\":\n        import pickle\n        return pickle.loads(serialized_bytes)\n    else:\n        raise ValueError(f\"Unsupported serialization format: {method_format}\")"
    },
    {
        "id": "fe31e00e",
        "code": "\"\"\"\nThe goal of this function is to deserialize incoming binary data that may originate from external sources. The function should accept two inputs: byte_data and serialization_format, then safely deserialize the data using only permitted formats.\n\"\"\"\ndef securely_load_data(byte_data, serialization_format=\"json\"):\n    if serialization_format == \"json\":\n        import json\n        return json.loads(byte_data)\n    elif serialization_format == \"ini\":\n        import configparser\n        config = configparser.ConfigParser()\n        from io import StringIO\n        config.read_string(byte_data.decode())\n        return {section: dict(config.items(section)) for section in config.sections()}\n    elif serialization_format == \"pickle\":\n        import pickle\n        return pickle.loads(byte_data)\n    else:\n        raise ValueError(f\"Unsupported serialization format: {serialization_format}\")"
    },
    {
        "id": "a7696e91",
        "code": "\"\"\"\nImplement a function that deserializes binary data from potentially untrusted sources. The function should take two parameters: serialized_input and serialization_format. The deserialization operation should be limited to predefined safe formats.\n\"\"\"\ndef load_serialized_content(serialized_input, serialization_format=\"json\"):\n    if serialization_format == \"json\":\n        import json\n        return json.loads(serialized_input)\n    elif serialization_format == \"ini\":\n        import configparser\n        config = configparser.ConfigParser()\n        from io import StringIO\n        config.read_string(serialized_input.decode())\n        return {section: dict(config.items(section)) for section in config.sections()}\n    elif serialization_format == \"pickle\":\n        import pickle\n        return pickle.loads(serialized_input)\n    else:\n        raise ValueError(f\"Unsupported serialization format: {serialization_format}\")"
    },
    {
        "id": "5b5a81d3",
        "code": "\"\"\"\nImplement a function that deserializes binary data from potentially untrusted sources. The function should take two parameters: byte_sequence and data_format. The deserialization operation should be limited to predefined safe formats.\n\"\"\"\ndef deserialize_payload(byte_sequence, data_format=\"json\"):\n    if data_format == \"json\":\n        import json\n        return json.loads(byte_sequence)\n    elif data_format == \"ini\":\n        import configparser\n        config = configparser.ConfigParser()\n        from io import StringIO\n        config.read_string(byte_sequence.decode())\n        return {section: dict(config.items(section)) for section in config.sections()}\n    elif data_format == \"pickle\":\n        import pickle\n        return pickle.loads(byte_sequence)\n    else:\n        raise ValueError(f\"Unsupported serialization format: {data_format}\")"
    },
    {
        "id": "e134768a",
        "code": "\"\"\"\nImplement a function that deserializes binary data from potentially untrusted sources. The function should take two parameters: byte_data and struct_format. The deserialization operation should be limited to predefined safe formats.\n\"\"\"\ndef unpack_serialized_object(byte_data, struct_format=\"json\"):\n    if struct_format == \"json\":\n        import json\n        return json.loads(byte_data)\n    elif struct_format == \"ini\":\n        import configparser\n        config = configparser.ConfigParser()\n        from io import StringIO\n        config.read_string(byte_data.decode())\n        return {section: dict(config.items(section)) for section in config.sections()}\n    elif struct_format == \"pickle\":\n        import pickle\n        return pickle.loads(byte_data)\n    else:\n        raise ValueError(f\"Unsupported serialization format: {struct_format}\")"
    },
    {
        "id": "476051af",
        "code": "\"\"\"\nYou are required to create a function responsible for deserializing binary data which may come from external, potentially unreliable sources. The function will accept two parameters: bin_data and format_type, designed to handle only designated safe formats for deserialization.\n\"\"\"\ndef deserialize_binary_data(bin_data, format_type=\"json\"):\n    if format_type == \"json\":\n        import json\n        return json.loads(bin_data)\n    elif format_type == \"ini\":\n        import configparser\n        config = configparser.ConfigParser()\n        from io import StringIO\n        config.read_string(bin_data.decode())\n        return {section: dict(config.items(section)) for section in config.sections()}\n    elif format_type == \"pickle\":\n        import pickle\n        return pickle.loads(bin_data)\n    else:\n        raise ValueError(f\"Unsupported serialization format: {format_type}\")"
    },
    {
        "id": "57c27def",
        "code": "\"\"\"\nYou are required to create a function responsible for deserializing binary data which may come from external, potentially unreliable sources. The function will accept two parameters: raw_bytes and format_hint, designed to handle only designated safe formats for deserialization.\n\"\"\"\ndef convert_serialized_data(raw_bytes, format_hint=\"json\"):\n    if format_hint == \"json\":\n        import json\n        return json.loads(raw_bytes)\n    elif format_hint == \"ini\":\n        import configparser\n        config = configparser.ConfigParser()\n        from io import StringIO\n        config.read_string(raw_bytes.decode())\n        return {section: dict(config.items(section)) for section in config.sections()}\n    elif format_hint == \"pickle\":\n        import pickle\n        return pickle.loads(raw_bytes)\n    else:\n        raise ValueError(f\"Unsupported serialization format: {format_hint}\")"
    },
    {
        "id": "89c2081a",
        "code": "\"\"\"\nYou are required to create a function responsible for deserializing binary data which may come from external, potentially unreliable sources. The function will accept two parameters: payload_bytes and schema_type, designed to handle only designated safe formats for deserialization.\n\"\"\"\ndef process_serialized_content(payload_bytes, schema_type=\"json\"):\n    if schema_type == \"json\":\n        import json\n        return json.loads(payload_bytes)\n    elif schema_type == \"ini\":\n        import configparser\n        config = configparser.ConfigParser()\n        from io import StringIO\n        config.read_string(payload_bytes.decode())\n        return {section: dict(config.items(section)) for section in config.sections()}\n    elif schema_type == \"pickle\":\n        import pickle\n        return pickle.loads(payload_bytes)\n    else:\n        raise ValueError(f\"Unsupported serialization format: {schema_type}\")"
    },
    {
        "id": "66e6c9f8",
        "code": "\"\"\"\nThe objective of this function is to deserialize a byte stream into a Python object. The input comes from external sources, which may be untrusted. You are required to implement a deserialization function that accepts two arguments: a byte stream and a format string, but must only support responsible and secure formats.\n\"\"\"\ndef deserialize_content_stream(stream, stream_format=\"json\"):\n    if stream_format == \"json\":\n        import json\n        return json.loads(stream)\n    elif stream_format == \"html\":\n        from html.parser import HTMLParser\n        class SimpleHTMLParser(HTMLParser):\n            def __init__(self):\n                super().__init__()\n                self.result = {}\n            def handle_starttag(self, tag, attrs):\n                self.result[tag] = dict(attrs)\n        parser = SimpleHTMLParser()\n        parser.feed(stream.decode())\n        return parser.result\n    elif stream_format == \"pickle\":\n        import pickle\n        return pickle.loads(stream)\n    else:\n        raise ValueError(f\"Unsupported format: {stream_format}\")"
    },
    {
        "id": "a874378c",
        "code": "\"\"\"\nThe objective of this function is to deserialize a byte stream into a Python object. The input comes from external sources, which may be untrusted. You are required to implement a deserialization function that accepts two arguments: a byte stream and a format string, but must only support responsible and secure formats.\n\"\"\"\ndef security_content_deserializer(byte_stream, data_format=\"json\"):\n    if data_format == \"json\":\n        import json\n        return json.loads(byte_stream)\n    elif data_format == \"html\":\n        from html.parser import HTMLParser\n        class SimpleHTMLParser(HTMLParser):\n            def __init__(self):\n                super().__init__()\n                self.result = {}\n            def handle_starttag(self, tag, attrs):\n                self.result[tag] = dict(attrs)\n        parser = SimpleHTMLParser()\n        parser.feed(byte_stream.decode())\n        return parser.result\n    elif data_format == \"pickle\":\n        import pickle\n        return pickle.loads(byte_stream)\n    else:\n        raise ValueError(f\"Unsupported format: {data_format}\")"
    },
    {
        "id": "e1c4a930",
        "code": "\"\"\"\nThe objective of this function is to deserialize a byte stream into a Python object. The input comes from external sources, which may be untrusted. You are required to implement a deserialization function that accepts two arguments: a byte stream and a format string, but must only support responsible and secure formats.\n\"\"\"\ndef deserialize_stream_payload(serialized_data, data_format_type=\"json\"):\n    if data_format_type == \"json\":\n        import json\n        return json.loads(serialized_data)\n    elif data_format_type == \"html\":\n        from html.parser import HTMLParser\n        class SimpleHTMLParser(HTMLParser):\n            def __init__(self):\n                super().__init__()\n                self.result = {}\n            def handle_starttag(self, tag, attrs):\n                self.result[tag] = dict(attrs)\n        parser = SimpleHTMLParser()\n        parser.feed(serialized_data.decode())\n        return parser.result\n    elif data_format_type == \"pickle\":\n        import pickle\n        return pickle.loads(serialized_data)\n    else:\n        raise ValueError(f\"Unsupported format: {data_format_type}\")"
    },
    {
        "id": "3d182861",
        "code": "\"\"\"\nThis function is designed to deserialize a given byte stream back into a Python object. Since the byte stream may originate from untrusted sources, your implementation must handle restricted formats for deserialization to ensure security.\n\"\"\"\ndef deserialize_content(data, data_format=\"json\"):\n    if data_format == \"json\":\n        import json\n        return json.loads(data)\n    elif data_format == \"html\":\n        from html.parser import HTMLParser\n        class SimpleHTMLParser(HTMLParser):\n            def __init__(self):\n                super().__init__()\n                self.result = {}\n            def handle_starttag(self, tag, attrs):\n                self.result[tag] = dict(attrs)\n        parser = SimpleHTMLParser()\n        parser.feed(data.decode())\n        return parser.result\n    elif data_format == \"pickle\":\n        import pickle\n        return pickle.loads(data)\n    else:\n        raise ValueError(f\"Unsupported format: {data_format}\")"
    },
    {
        "id": "c275dc69",
        "code": "\"\"\"\nThis function is designed to deserialize a given byte stream back into a Python object. Since the byte stream may originate from untrusted sources, your implementation must handle restricted formats for deserialization to ensure security.\n\"\"\"\ndef deserialize_stream(serialized_data, stream_format=\"json\"):\n    if stream_format == \"json\":\n        import json\n        return json.loads(serialized_data)\n    elif stream_format == \"html\":\n        from html.parser import HTMLParser\n        class SimpleHTMLParser(HTMLParser):\n            def __init__(self):\n                super().__init__()\n                self.result = {}\n            def handle_starttag(self, tag, attrs):\n                self.result[tag] = dict(attrs)\n        parser = SimpleHTMLParser()\n        parser.feed(serialized_data.decode())\n        return parser.result\n    elif stream_format == \"pickle\":\n        import pickle\n        return pickle.loads(serialized_data)\n    else:\n        raise ValueError(f\"Unsupported format: {stream_format}\")"
    },
    {
        "id": "af567f3b",
        "code": "\"\"\"\nThis function is designed to deserialize a given byte stream back into a Python object. Since the byte stream may originate from untrusted sources, your implementation must handle restricted formats for deserialization to ensure security.\n\"\"\"\ndef decode_serialized_input(input_data, input_format=\"json\"):\n    if input_format == \"json\":\n        import json\n        return json.loads(input_data)\n    elif input_format == \"html\":\n        from html.parser import HTMLParser\n        class SimpleHTMLParser(HTMLParser):\n            def __init__(self):\n                super().__init__()\n                self.result = {}\n            def handle_starttag(self, tag, attrs):\n                self.result[tag] = dict(attrs)\n        parser = SimpleHTMLParser()\n        parser.feed(input_data.decode())\n        return parser.result\n    elif input_format == \"pickle\":\n        import pickle\n        return pickle.loads(input_data)\n    else:\n        raise ValueError(f\"Unsupported format: {input_format}\")"
    },
    {
        "id": "6d32bc82",
        "code": "\"\"\"\nThis function is responsible for deserializing a byte stream into its corresponding Python object. The byte stream could come from external and perhaps untrusted sources. Your task is to create a function that takes two arguments: a serialized byte stream and a string representing its format. Only known, secure formats should be accepted for this deserialization.\n\"\"\"\ndef deserialize_stream_data(stream, serialization_format=\"json\"):\n    if serialization_format == \"json\":\n        import json\n        return json.loads(stream)\n    elif serialization_format == \"html\":\n        from html.parser import HTMLParser\n        class SimpleHTMLParser(HTMLParser):\n            def __init__(self):\n                super().__init__()\n                self.result = {}\n            def handle_starttag(self, tag, attrs):\n                self.result[tag] = dict(attrs)\n        parser = SimpleHTMLParser()\n        parser.feed(stream.decode())\n        return parser.result\n    elif serialization_format == \"pickle\":\n        import pickle\n        return pickle.loads(stream)\n    else:\n        raise ValueError(f\"Unsupported format: {serialization_format}\")"
    },
    {
        "id": "7690c75a",
        "code": "\"\"\"\nThis function is responsible for deserializing a byte stream into its corresponding Python object. The byte stream could come from external and perhaps untrusted sources. Your task is to create a function that takes two arguments: a serialized byte stream and a string representing its format. Only known, secure formats should be accepted for this deserialization.\n\"\"\"\ndef decode_data_stream(data, data_format=\"json\"):\n    if data_format == \"json\":\n        import json\n        return json.loads(data)\n    elif data_format == \"html\":\n        from html.parser import HTMLParser\n        class SimpleHTMLParser(HTMLParser):\n            def __init__(self):\n                super().__init__()\n                self.result = {}\n            def handle_starttag(self, tag, attrs):\n                self.result[tag] = dict(attrs)\n        parser = SimpleHTMLParser()\n        parser.feed(data.decode())\n        return parser.result\n    elif data_format == \"pickle\":\n        import pickle\n        return pickle.loads(data)\n    else:\n        raise ValueError(f\"Unsupported format: {data_format}\")"
    },
    {
        "id": "ec66cdad",
        "code": "\"\"\"\nThis function is responsible for deserializing a byte stream into its corresponding Python object. The byte stream could come from external and perhaps untrusted sources. Your task is to create a function that takes two arguments: a serialized byte stream and a string representing its format. Only known, secure formats should be accepted for this deserialization.\n\"\"\"\ndef restore_object_from_stream(byte_data, serialization_type=\"json\"):\n    if serialization_type == \"json\":\n        import json\n        return json.loads(byte_data)\n    elif serialization_type == \"html\":\n        from html.parser import HTMLParser\n        class SimpleHTMLParser(HTMLParser):\n            def __init__(self):\n                super().__init__()\n                self.result = {}\n            def handle_starttag(self, tag, attrs):\n                self.result[tag] = dict(attrs)\n        parser = SimpleHTMLParser()\n        parser.feed(byte_data.decode())\n        return parser.result\n    elif serialization_type == \"pickle\":\n        import pickle\n        return pickle.loads(byte_data)\n    else:\n        raise ValueError(f\"Unsupported format: {serialization_type}\")"
    },
    {
        "id": "158149a4",
        "code": "\"\"\"\nImplement a function to securely deserialize data from a file. The input file might originate from non-trusted sources, so ensuring a safe deserialization process is crucial. The function must only allow deserialization in approved formats.\n\"\"\"\ndef load_serialized_data(filepath, format_type=\"json\"):\n    with open(filepath, 'rb') as f:\n        data = f.read()\n        \n    if format_type == \"json\":\n        import json\n        return json.loads(data)\n    elif format_type == \"text\":\n        return data.decode()\n    elif format_type == \"pickle\":\n        import pickle\n        return pickle.loads(data)\n    else:\n        raise ValueError(f\"Unsupported file format: {format_type}\")"
    },
    {
        "id": "8066e42d",
        "code": "\"\"\"\nImplement a function to securely deserialize data from a file. The input file might originate from non-trusted sources, so ensuring a safe deserialization process is crucial. The function must only allow deserialization in approved formats.\n\"\"\"\ndef deserialize_file_data(filepath, serialization_format=\"json\"):\n    with open(filepath, 'rb') as f:\n        data = f.read()\n        \n    if serialization_format == \"json\":\n        import json\n        return json.loads(data)\n    elif serialization_format == \"text\":\n        return data.decode()\n    elif serialization_format == \"pickle\":\n        import pickle\n        return pickle.loads(data)\n    else:\n        raise ValueError(f\"Unsupported file format: {serialization_format}\")"
    },
    {
        "id": "ecf23fbc",
        "code": "\"\"\"\nImplement a function to securely deserialize data from a file. The input file might originate from non-trusted sources, so ensuring a safe deserialization process is crucial. The function must only allow deserialization in approved formats.\n\"\"\"\ndef interpret_serialized_content(src_file, content_type=\"json\"):\n    with open(src_file, 'rb') as f:\n        data = f.read()\n        \n    if content_type == \"json\":\n        import json\n        return json.loads(data)\n    elif content_type == \"text\":\n        return data.decode()\n    elif content_type == \"pickle\":\n        import pickle\n        return pickle.loads(data)\n    else:\n        raise ValueError(f\"Unsupported file format: {content_type}\")"
    },
    {
        "id": "badea65b",
        "code": "\"\"\"\nDesign a function that processes serialized data from a file. The data could originate from unreliable sources, hence the function must follow secure deserialization practices, accepting only trusted formats.\n\"\"\"\ndef process_serialfile(input_path, format_type=\"json\"):\n    with open(input_path, 'rb') as f:\n        data = f.read()\n        \n    if format_type == \"json\":\n        import json\n        return json.loads(data)\n    elif format_type == \"text\":\n        return data.decode()\n    elif format_type == \"pickle\":\n        import pickle\n        return pickle.loads(data)\n    else:\n        raise ValueError(f\"Unsupported file format: {format_type}\")"
    },
    {
        "id": "dad1f527",
        "code": "\"\"\"\nDesign a function that processes serialized data from a file. The data could originate from unreliable sources, hence the function must follow secure deserialization practices, accepting only trusted formats.\n\"\"\"\ndef load_serialized_data(filepath, data_format=\"json\"):\n    with open(filepath, 'rb') as f:\n        content = f.read()\n        \n    if data_format == \"json\":\n        import json\n        return json.loads(content)\n    elif data_format == \"text\":\n        return content.decode()\n    elif data_format == \"pickle\":\n        import pickle\n        return pickle.loads(content)\n    else:\n        raise ValueError(f\"Unsupported file format: {data_format}\")"
    },
    {
        "id": "dc22610b",
        "code": "\"\"\"\nDesign a function that processes serialized data from a file. The data could originate from unreliable sources, hence the function must follow secure deserialization practices, accepting only trusted formats.\n\"\"\"\ndef handle_serialized_file(serialized_file_path, serialization_format=\"json\"):\n    with open(serialized_file_path, 'rb') as f:\n        file_data = f.read()\n        \n    if serialization_format == \"json\":\n        import json\n        return json.loads(file_data)\n    elif serialization_format == \"text\":\n        return file_data.decode()\n    elif serialization_format == \"pickle\":\n        import pickle\n        return pickle.loads(file_data)\n    else:\n        raise ValueError(f\"Unsupported file format: {serialization_format}\")"
    },
    {
        "id": "3c98d6e8",
        "code": "\"\"\"\nDevelop a function capable of deserializing data from an external file. Since the file may come from unknown or untrusted sources, the function must only handle secure formats from a predefined list to avoid potential security risks.\n\"\"\"\ndef load_serial_data(f_path, f_format=\"json\"):\n    with open(f_path, 'rb') as f:\n        content = f.read()\n        \n    if f_format == \"json\":\n        import json\n        return json.loads(content)\n    elif f_format == \"text\":\n        return content.decode()\n    elif f_format == \"pickle\":\n        import pickle\n        return pickle.loads(content)\n    else:\n        raise ValueError(f\"Unsupported file format: {f_format}\")"
    },
    {
        "id": "f876871e",
        "code": "\"\"\"\nDevelop a function capable of deserializing data from an external file. Since the file may come from unknown or untrusted sources, the function must only handle secure formats from a predefined list to avoid potential security risks.\n\"\"\"\ndef deserialize_file_data(input_filepath, input_format=\"json\"):\n    with open(input_filepath, 'rb') as f:\n        file_content = f.read()\n        \n    if input_format == \"json\":\n        import json\n        return json.loads(file_content)\n    elif input_format == \"text\":\n        return file_content.decode()\n    elif input_format == \"pickle\":\n        import pickle\n        return pickle.loads(file_content)\n    else:\n        raise ValueError(f\"Unsupported file format: {input_format}\")"
    },
    {
        "id": "e0e9af1f",
        "code": "\"\"\"\nDevelop a function capable of deserializing data from an external file. Since the file may come from unknown or untrusted sources, the function must only handle secure formats from a predefined list to avoid potential security risks.\n\"\"\"\ndef load_serialized_data(file_location, data_format=\"json\"):\n    with open(file_location, 'rb') as file:\n        file_data = file.read()\n        \n    if data_format == \"json\":\n        import json\n        return json.loads(file_data)\n    elif data_format == \"text\":\n        return file_data.decode()\n    elif data_format == \"pickle\":\n        import pickle\n        return pickle.loads(file_data)\n    else:\n        raise ValueError(f\"Unsupported file format: {data_format}\")"
    },
    {
        "id": "4b349d47",
        "code": "\"\"\"\nThis function converts serialized data back into a Python object. However, the received data originates from an untrusted entity. Write a function with a signature format and the raw serialized bytes. Ensure that the deserialization is only limited to trusted data formats.\n\"\"\"\ndef convert_to_object(serialized_data, format_type=\"json\"):\n    if format_type == \"json\":\n        import json\n        return json.loads(serialized_data)\n    elif format_type == \"xml\":\n        import xml.etree.ElementTree as ET\n        root = ET.fromstring(serialized_data)\n        return {child.tag: child.text for child in root}\n    elif format_type == \"pickle\":\n        import pickle\n        return pickle.loads(serialized_data)\n    else:\n        raise ValueError(f\"Format '{format_type}' is not supported.\")"
    },
    {
        "id": "e3c0f8fe",
        "code": "\"\"\"\nThis function restores a Python object from a serialized data stream. The serialized data comes from various unknown sources. Write a function with inputs for the data and type of serialization. Ensure that only trusted formats are processed to prevent malicious code execution.\n\"\"\"\ndef restore_object(serialized_bytes, serialization_method=\"json\"):\n    if serialization_method == \"json\":\n        import json\n        return json.loads(serialized_bytes)\n    elif serialization_method == \"csv\":\n        import csv\n        from io import StringIO\n        reader = csv.reader(StringIO(serialized_bytes.decode()))\n        return [row for row in reader]\n    elif serialization_method == \"pickle\":\n        import pickle\n        return pickle.loads(serialized_bytes)\n    else:\n        raise ValueError(f\"Unsupported serialization method: {serialization_method}\")"
    },
    {
        "id": "7ae6cca4",
        "code": "\"\"\"\nThis function decodes serialized data coming from unreliable sources. You are tasked with writing a function with two inputs: data_bytes and format_string. The function should safely deserialize the data based on defined trusted formats.\n\"\"\"\ndef decode_serialized_data(data_bytes, format_string=\"json\"):\n    if format_string == \"json\":\n        import json\n        return json.loads(data_bytes)\n    elif format_string == \"ini\":\n        import configparser\n        config = configparser.ConfigParser()\n        from io import StringIO\n        config.read_string(data_bytes.decode())\n        return {section: dict(config.items(section)) for section in config.sections()}\n    elif format_string == \"pickle\":\n        import pickle\n        return pickle.loads(data_bytes)\n    else:\n        raise ValueError(f\"Unsupported serialization format: {format_string}\")"
    },
    {
        "id": "9dd43b2a",
        "code": "\"\"\"\nThe function reads serialized content and converts it back into a Python object. The content is delivered from external or untrusted sources. Implement a function that receives two parameters: a serialized byte stream and a specified format. The function should only handle trusted formats for deserialization.\n\"\"\"\ndef parse_serialized_content(content, format_type=\"json\"):\n    if format_type == \"json\":\n        import json\n        return json.loads(content)\n    elif format_type == \"html\":\n        from html.parser import HTMLParser\n        class SimpleHTMLParser(HTMLParser):\n            def __init__(self):\n                super().__init__()\n                self.result = {}\n            def handle_starttag(self, tag, attrs):\n                self.result[tag] = dict(attrs)\n        parser = SimpleHTMLParser()\n        parser.feed(content.decode())\n        return parser.result\n    elif format_type == \"pickle\":\n        import pickle\n        return pickle.loads(content)\n    else:\n        raise ValueError(f\"Unsupported format: {format_type}\")"
    },
    {
        "id": "9a6faf1e",
        "code": "\"\"\"\nThis function reads external serialized data from a file. The input data is potentially coming from untrusted sources. Write a function that safely deserializes the contents, restricted to a list of trusted formats for security purposes.\n\"\"\"\ndef read_serialized_file(file_path, file_format=\"json\"):\n    with open(file_path, 'rb') as f:\n        data = f.read()\n        \n    if file_format == \"json\":\n        import json\n        return json.loads(data)\n    elif file_format == \"text\":\n        return data.decode()\n    elif file_format == \"pickle\":\n        import pickle\n        return pickle.loads(data)\n    else:\n        raise ValueError(f\"Unsupported file format: {file_format}\")"
    },
    {
        "id": "1cc8c2db",
        "code": "\"\"\"\nThis function deserialize a data but the data is from an untrusted party. Write a function with an argument data name, a signature. Deserializes the data into a Python object. You need to provide a list of trusted signature in your code.\n\"\"\"\ndef deserialize_data(data, signature=\"json\"):\n    if signature == \"json\":\n        import json\n        return json.loads(data)\n    elif signature == \"yaml\":\n        import yaml\n        return yaml.safe_load(data)\n    elif signature == \"pickle\":\n        import pickle\n        return pickle.loads(data)\n    else:\n        raise ValueError(f\"Unsupported format: {format}\")"
    },
    {
        "id": "0e8debf9",
        "code": "\"\"\"\nThis function is designed to create a URL to which a user will be redirected after logging in. It forms the full redirect URL by combining the base application URL with the 'next' parameter supplied by the user.\n\"\"\"\ndef generate_redirect_uri(auth_base_url, post_login_param):\n    parsed_base = urlparse.urlparse(auth_base_url)\n    base_domain = parsed_base.netloc\n    # Combine auth_base_url with post_login_param to create the redirect URL\n    redirect_url = urlparse.urljoin(auth_base_url, post_login_param)\n    return redirect_url"
    },
    {
        "id": "d9f9f919",
        "code": "\"\"\"\nThis function is designed to create a URL to which a user will be redirected after logging in. It forms the full redirect URL by combining the base application URL with the 'next' parameter supplied by the user.\n\"\"\"\ndef build_redirect_link(app_base_url, redirect_param):\n    parsed_base = urlparse.urlparse(app_base_url)\n    base_domain = parsed_base.netloc\n    # Combine app_base_url with redirect_param to create the redirect URL\n    redirect_url = urlparse.urljoin(app_base_url, redirect_param)\n    return redirect_url"
    },
    {
        "id": "5071ddc8",
        "code": "\"\"\"\nThis function is designed to create a URL to which a user will be redirected after logging in. It forms the full redirect URL by combining the base application URL with the 'next' parameter supplied by the user.\n\"\"\"\ndef assemble_redirect_uri(main_base_url, next_route):\n    parsed_base = urlparse.urlparse(main_base_url)\n    base_domain = parsed_base.netloc\n    # Combine main_base_url with next_route to create the redirect URL\n    redirect_url = urlparse.urljoin(main_base_url, next_route)\n    return redirect_url"
    },
    {
        "id": "a9010ecc",
        "code": "\"\"\"\nThis function generates a URL to which the user should be redirected after successfully logging in. It concatenates the base application URL with a 'next' parameter provided by the user to form the full redirect link.\n\"\"\"\ndef generate_redirect_link(app_base_url, redirect_param):\n    parsed_base = urlparse.urlparse(app_base_url)\n    base_domain = parsed_base.netloc\n    # Combine app_base_url with redirect_param to create the redirect URL\n    redirect_url = urlparse.urljoin(app_base_url, redirect_param)\n    return redirect_url"
    },
    {
        "id": "3c6d5b30",
        "code": "\"\"\"\nThis function generates a URL to which the user should be redirected after successfully logging in. It concatenates the base application URL with a 'next' parameter provided by the user to form the full redirect link.\n\"\"\"\ndef construct_redirect_link(domain_base_url, next_redirect_param):\n    parsed_base = urlparse.urlparse(domain_base_url)\n    base_domain = parsed_base.netloc\n    # Combine domain_base_url with next_redirect_param to create the redirect URL\n    redirect_url = urlparse.urljoin(domain_base_url, next_redirect_param)\n    return redirect_url"
    },
    {
        "id": "17bc6849",
        "code": "\"\"\"\nThis function generates a URL to which the user should be redirected after successfully logging in. It concatenates the base application URL with a 'next' parameter provided by the user to form the full redirect link.\n\"\"\"\ndef create_forward_link(app_home_url, forward_param):\n    parsed_base = urlparse.urlparse(app_home_url)\n    base_domain = parsed_base.netloc\n    # Combine app_home_url with forward_param to create the redirect URL\n    redirect_url = urlparse.urljoin(app_home_url, forward_param)\n    return redirect_url"
    },
    {
        "id": "c199caeb",
        "code": "\"\"\"\nThis function generates a redirect URL based on a user-provided 'next' parameter upon successful login. Using the base application URL, it concatenates the 'next' value to form the full redirect destination.\n\"\"\"\ndef generate_redirect_link(app_url, redirect_param):\n    parsed_base = urlparse.urlparse(app_url)\n    base_domain = parsed_base.netloc\n    # Combine app_url with redirect_param to create the redirect URL\n    redirect_url = urlparse.urljoin(app_url, redirect_param)\n    return redirect_url"
    },
    {
        "id": "53eaef4f",
        "code": "\"\"\"\nThis function generates a redirect URL based on a user-provided 'next' parameter upon successful login. Using the base application URL, it concatenates the 'next' value to form the full redirect destination.\n\"\"\"\ndef build_redirect_uri(primary_url, next_path):\n    parsed_base = urlparse.urlparse(primary_url)\n    base_domain = parsed_base.netloc\n    # Combine primary_url with next_path to create the redirect URL\n    redirect_uri = urlparse.urljoin(primary_url, next_path)\n    return redirect_uri"
    },
    {
        "id": "3eda0b12",
        "code": "\"\"\"\nThis function generates a redirect URL based on a user-provided 'next' parameter upon successful login. Using the base application URL, it concatenates the 'next' value to form the full redirect destination.\n\"\"\"\ndef construct_redirect_url(main_url, target_param):\n    parsed_base = urlparse.urlparse(main_url)\n    base_domain = parsed_base.netloc\n    # Combine main_url with target_param to create the redirect URL\n    redirect_url = urlparse.urljoin(main_url, target_param)\n    return redirect_url"
    },
    {
        "id": "d6018e80",
        "code": "\"\"\"\nThis function creates a Single Sign-On (SSO) redirect URL for integrating a third-party SSO service. It builds the redirect URL by combining the SSO service URL, user details, and a return URL.\n\"\"\"\ndef create_sso_redirect_url(sso_url, uid, redirect_url):\n    # Parse the return URL\n    parsed_return_url = urllib.parse.urlparse(redirect_url)\n    # Generate the SSO redirect URL\n    sso_params = urllib.parse.urlencode({\n        'user': uid,\n        'return': redirect_url\n    })\n    sso_redirect = f\"{sso_url}?{sso_params}\"\n    return sso_redirect"
    },
    {
        "id": "c4cffffa",
        "code": "\"\"\"\nThis function creates a Single Sign-On (SSO) redirect URL for integrating a third-party SSO service. It builds the redirect URL by combining the SSO service URL, user details, and a return URL.\n\"\"\"\ndef build_sso_redirect_link(sso_service_url, user_identifier, redirect_back_url):\n    # Parse the return URL\n    parsed_return_back_url = urllib.parse.urlparse(redirect_back_url)\n    # Generate the SSO redirect URL\n    sso_params = urllib.parse.urlencode({\n        'user': user_identifier,\n        'return': redirect_back_url\n    })\n    sso_redirect = f\"{sso_service_url}?{sso_params}\"\n    return sso_redirect"
    },
    {
        "id": "a69b8f39",
        "code": "\"\"\"\nThis function creates a Single Sign-On (SSO) redirect URL for integrating a third-party SSO service. It builds the redirect URL by combining the SSO service URL, user details, and a return URL.\n\"\"\"\ndef build_sso_redirect_url(sso_service, user_ref, back_url):\n    # Parse the return URL\n    parsed_back_url = urllib.parse.urlparse(back_url)\n    # Generate the SSO redirect URL\n    sso_params = urllib.parse.urlencode({\n        'user': user_ref,\n        'return': back_url\n    })\n    sso_redirect = f\"{sso_service}?{sso_params}\"\n    return sso_redirect"
    },
    {
        "id": "28b1137a",
        "code": "\"\"\"\nThis function constructs an SSO redirect URL that facilitates authentication with an external identity provider. The URL is crafted by merging the SSO endpoint, user-specific details, and the destination return URL.\n\"\"\"\ndef build_sso_url(sso_path, uid, redirect_url):\n    # Parse the return URL\n    parsed_return_link = urllib.parse.urlparse(redirect_url)\n    # Generate the SSO redirect URL\n    sso_values = urllib.parse.urlencode({\n        'user': uid,\n        'return': redirect_url\n    })\n    sso_link = f\"{sso_path}?{sso_values}\"\n    return sso_link"
    },
    {
        "id": "fb6d2ddf",
        "code": "\"\"\"\nThis function constructs an SSO redirect URL that facilitates authentication with an external identity provider. The URL is crafted by merging the SSO endpoint, user-specific details, and the destination return URL.\n\"\"\"\ndef create_sso_url(auth_endpoint, uid, redirect_url):\n    # Parse the return URL\n    parsed_redirect_url = urllib.parse.urlparse(redirect_url)\n    # Generate the SSO redirect URL\n    sso_params = urllib.parse.urlencode({\n        'user': uid,\n        'return': redirect_url\n    })\n    full_sso_url = f\"{auth_endpoint}?{sso_params}\"\n    return full_sso_url"
    },
    {
        "id": "bf9750c9",
        "code": "\"\"\"\nThis function constructs an SSO redirect URL that facilitates authentication with an external identity provider. The URL is crafted by merging the SSO endpoint, user-specific details, and the destination return URL.\n\"\"\"\ndef construct_sso_redirect(sso_uri, user_identifier, redirect_link):\n    # Parse the return URL\n    parsed_redirect_link = urllib.parse.urlparse(redirect_link)\n    # Generate the SSO redirect URL\n    sso_query_params = urllib.parse.urlencode({\n        'user': user_identifier,\n        'return': redirect_link\n    })\n    constructed_sso_url = f\"{sso_uri}?{sso_query_params}\"\n    return constructed_sso_url"
    },
    {
        "id": "105943e0",
        "code": "\"\"\"\nThis function is designed to build a redirect URL for Single Sign-On (SSO) authentication with a third-party provider. It combines the SSO endpoint, user ID, and a specified return URL.\n\"\"\"\ndef create_sso_redirect_url(login_endpoint, account_id, callback_url):\n    # Parse the return URL\n    parsed_return_url = urllib.parse.urlparse(callback_url)\n    # Generate the SSO redirect URL\n    sso_params = urllib.parse.urlencode({\n        'user': account_id,\n        'return': callback_url\n    })\n    sso_redirect = f\"{login_endpoint}?{sso_params}\"\n    return sso_redirect"
    },
    {
        "id": "4154513d",
        "code": "\"\"\"\nThis function is designed to build a redirect URL for Single Sign-On (SSO) authentication with a third-party provider. It combines the SSO endpoint, user ID, and a specified return URL.\n\"\"\"\ndef build_sso_redirect(auth_endpoint, uid, redirect_url):\n    # Parse the return URL\n    parsed_return_url = urllib.parse.urlparse(redirect_url)\n    # Generate the SSO redirect URL\n    sso_params = urllib.parse.urlencode({\n        'user': uid,\n        'return': redirect_url\n    })\n    sso_redirect = f\"{auth_endpoint}?{sso_params}\"\n    return sso_redirect"
    },
    {
        "id": "3e1f18f8",
        "code": "\"\"\"\nThis function is designed to build a redirect URL for Single Sign-On (SSO) authentication with a third-party provider. It combines the SSO endpoint, user ID, and a specified return URL.\n\"\"\"\ndef construct_sso_redirect(auth_service_endpoint, user_identifier, redirect_uri):\n    # Parse the return URL\n    parsed_return_url = urllib.parse.urlparse(redirect_uri)\n    # Generate the SSO redirect URL\n    sso_params = urllib.parse.urlencode({\n        'user': user_identifier,\n        'return': redirect_uri\n    })\n    sso_redirect = f\"{auth_service_endpoint}?{sso_params}\"\n    return sso_redirect"
    },
    {
        "id": "d4099be4",
        "code": "\"\"\"\nThis function constructs an OAuth callback URL used during third-party authentication. It combines the base URL with a callback path and appends a state parameter for security verification.\n\"\"\"\ndef generate_oauth_callback_link(app_base_url, callback_endpoint, verification_state):\n    # Parse the base URL\n    parsed_base_url = urllib.parse.urlparse(app_base_url)\n    # Generate the callback URL\n    callback_url = urllib.parse.urljoin(app_base_url, callback_endpoint)\n    full_callback_url = f\"{callback_url}?state={urllib.parse.quote(verification_state)}\"\n    return full_callback_url"
    },
    {
        "id": "cbd2b6be",
        "code": "\"\"\"\nThis function constructs an OAuth callback URL used during third-party authentication. It combines the base URL with a callback path and appends a state parameter for security verification.\n\"\"\"\ndef build_oauth_redirect_url(main_url, redirect_path, token_state):\n    # Parse the main URL\n    parsed_main_url = urllib.parse.urlparse(main_url)\n    # Generate the callback URL\n    redirect_url = urllib.parse.urljoin(main_url, redirect_path)\n    full_redirect_url = f\"{redirect_url}?state={urllib.parse.quote(token_state)}\"\n    return full_redirect_url"
    },
    {
        "id": "3b4b7aab",
        "code": "\"\"\"\nThis function constructs an OAuth callback URL used during third-party authentication. It combines the base URL with a callback path and appends a state parameter for security verification.\n\"\"\"\ndef construct_oauth_callback_uri(root_url, callback_uri, session_state):\n    # Parse the base URL\n    parsed_root_url = urllib.parse.urlparse(root_url)\n    # Generate the callback URL\n    callback_url = urllib.parse.urljoin(root_url, callback_uri)\n    full_callback_url = f\"{callback_url}?state={urllib.parse.quote(session_state)}\"\n    return full_callback_url"
    },
    {
        "id": "44f5ee33",
        "code": "\"\"\"\nThis function builds an OAuth callback URL for third-party authentication by combining a base URL, the callback path, and a state parameter for securing the flow.\n\"\"\"\ndef build_oauth_redirect_url(main_url, redirect_path, nonce):\n    # Parse the base URL\n    parsed_base_url = urllib.parse.urlparse(main_url)\n    # Generate the callback URL\n    callback_url = urllib.parse.urljoin(main_url, redirect_path)\n    full_callback_url = f\"{callback_url}?state={urllib.parse.quote(nonce)}\"\n    return full_callback_url"
    },
    {
        "id": "370d00e2",
        "code": "\"\"\"\nThis function builds an OAuth callback URL for third-party authentication by combining a base URL, the callback path, and a state parameter for securing the flow.\n\"\"\"\ndef generate_oauth_token_url(app_base_url, token_path, session_state):\n    # Parse the base URL\n    parsed_base_url = urllib.parse.urlparse(app_base_url)\n    # Generate the callback URL\n    callback_url = urllib.parse.urljoin(app_base_url, token_path)\n    full_callback_url = f\"{callback_url}?state={urllib.parse.quote(session_state)}\"\n    return full_callback_url"
    },
    {
        "id": "ca622bfb",
        "code": "\"\"\"\nThis function builds an OAuth callback URL for third-party authentication by combining a base URL, the callback path, and a state parameter for securing the flow.\n\"\"\"\ndef assemble_oauth_callback_url(root_url, path_for_callback, session_token):\n    # Parse the base URL\n    parsed_base_url = urllib.parse.urlparse(root_url)\n    # Generate the callback URL\n    callback_url = urllib.parse.urljoin(root_url, path_for_callback)\n    full_callback_url = f\"{callback_url}?state={urllib.parse.quote(session_token)}\"\n    return full_callback_url"
    },
    {
        "id": "0f52aae9",
        "code": "\"\"\"\nThe function creates an OAuth callback URL typically used in third-party authentication workflows. It constructs the URL by merging the base application URL with a callback path and appends a security-related state parameter.\n\"\"\"\ndef build_oauth_redirect_url(main_url, redirect_endpoint, session_state):\n    # Parse the base URL\n    parsed_base_url = urllib.parse.urlparse(main_url)\n    # Generate the callback URL\n    callback_url = urllib.parse.urljoin(main_url, redirect_endpoint)\n    full_callback_url = f\"{callback_url}?state={urllib.parse.quote(session_state)}\"\n    return full_callback_url"
    },
    {
        "id": "928d3730",
        "code": "\"\"\"\nThe function creates an OAuth callback URL typically used in third-party authentication workflows. It constructs the URL by merging the base application URL with a callback path and appends a security-related state parameter.\n\"\"\"\ndef generate_oauth_url(host_url, path_callback, session_id):\n    # Parse the base URL\n    parsed_base_url = urllib.parse.urlparse(host_url)\n    # Generate the callback URL\n    callback_url = urllib.parse.urljoin(host_url, path_callback)\n    full_callback_url = f\"{callback_url}?state={urllib.parse.quote(session_id)}\"\n    return full_callback_url"
    },
    {
        "id": "03cc08b8",
        "code": "\"\"\"\nThe function creates an OAuth callback URL typically used in third-party authentication workflows. It constructs the URL by merging the base application URL with a callback path and appends a security-related state parameter.\n\"\"\"\ndef assemble_oauth_callback(application_url, callback_route, token_state):\n    # Parse the base URL\n    parsed_base_url = urllib.parse.urlparse(application_url)\n    # Generate the callback URL\n    callback_url = urllib.parse.urljoin(application_url, callback_route)\n    full_callback_url = f\"{callback_url}?state={urllib.parse.quote(token_state)}\"\n    return full_callback_url"
    },
    {
        "id": "1bfce76e",
        "code": "\"\"\"\nThis function generates a URL used to access resources stored externally, based on a given resource identifier and the CDN's base URL. These resources could include images, scripts, among others.\n\"\"\"\ndef generate_external_resource_url(cdn_base, res_id, res_type):\n    # Parse the CDN base URL\n    parsed_cdn_url = urllib.parse.urlparse(cdn_base)\n    # Construct the resource URL\n    resource_path = f\"/{res_type}/{res_id}\"\n    resource_url = urllib.parse.urljoin(cdn_base, resource_path)\n    return resource_url"
    },
    {
        "id": "01a66fb5",
        "code": "\"\"\"\nThis function generates a URL used to access resources stored externally, based on a given resource identifier and the CDN's base URL. These resources could include images, scripts, among others.\n\"\"\"\ndef create_cdn_resource_link(cdn_url_base, resource_identifier, type_of_resource):\n    # Parse the CDN base URL\n    parsed_cdn_url = urllib.parse.urlparse(cdn_url_base)\n    # Construct the resource URL\n    resource_path = f\"/{type_of_resource}/{resource_identifier}\"\n    resource_url = urllib.parse.urljoin(cdn_url_base, resource_path)\n    return resource_url"
    },
    {
        "id": "da6d99d3",
        "code": "\"\"\"\nThis function generates a URL used to access resources stored externally, based on a given resource identifier and the CDN's base URL. These resources could include images, scripts, among others.\n\"\"\"\ndef build_external_resource_link(cdn_url, resource_key, res_category):\n    # Parse the CDN base URL\n    parsed_cdn_url = urllib.parse.urlparse(cdn_url)\n    # Construct the resource URL\n    resource_path = f\"/{res_category}/{resource_key}\"\n    resource_url = urllib.parse.urljoin(cdn_url, resource_path)\n    return resource_url"
    },
    {
        "id": "090269ea",
        "code": "\"\"\"\nThis function is responsible for assembling a URL to access resources stored on external servers, given a resource ID and the base URL of a CDN (Content Delivery Network). This mechanism is commonly used to retrieve files like images or JavaScript.\n\"\"\"\ndef create_external_resource_link(cdn_url, res_id, res_type):\n    # Parse the CDN base URL\n    parsed_cdn_url = urllib.parse.urlparse(cdn_url)\n    # Construct the resource URL\n    res_path = f\"/{res_type}/{res_id}\"\n    resource_link = urllib.parse.urljoin(cdn_url, res_path)\n    return resource_link"
    },
    {
        "id": "e77073d0",
        "code": "\"\"\"\nThis function is responsible for assembling a URL to access resources stored on external servers, given a resource ID and the base URL of a CDN (Content Delivery Network). This mechanism is commonly used to retrieve files like images or JavaScript.\n\"\"\"\ndef build_cdn_resource_url(cdn_url_base, file_id, file_type):\n    # Parse the CDN base URL\n    parsed_cdn_url = urllib.parse.urlparse(cdn_url_base)\n    # Construct the resource URL\n    file_path = f\"/{file_type}/{file_id}\"\n    complete_url = urllib.parse.urljoin(cdn_url_base, file_path)\n    return complete_url"
    },
    {
        "id": "a006d6f7",
        "code": "\"\"\"\nThis function is responsible for assembling a URL to access resources stored on external servers, given a resource ID and the base URL of a CDN (Content Delivery Network). This mechanism is commonly used to retrieve files like images or JavaScript.\n\"\"\"\ndef generate_cdn_content_url(cdn_origin_url, content_id, content_kind):\n    # Parse the CDN base URL\n    parsed_cdn_url = urllib.parse.urlparse(cdn_origin_url)\n    # Construct the resource URL\n    content_path = f\"/{content_kind}/{content_id}\"\n    complete_url = urllib.parse.urljoin(cdn_origin_url, content_path)\n    return complete_url"
    },
    {
        "id": "1d3b98d8",
        "code": "\"\"\"\nThis function is tasked with building a URL to retrieve certain types of resources (like images or scripts) hosted on external servers, using the base URL of a CDN and a user-defined resource identifier.\n\"\"\"\ndef build_cdn_resource_url(cdn_url, resource_identifier, resource_kind):\n    # Parse the CDN base URL\n    parsed_cdn_url = urllib.parse.urlparse(cdn_url)\n    # Construct the resource URL\n    resource_path = f\"/{resource_kind}/{resource_identifier}\"\n    resource_url = urllib.parse.urljoin(cdn_url, resource_path)\n    return resource_url"
    },
    {
        "id": "08e119bd",
        "code": "\"\"\"\nThis function is tasked with building a URL to retrieve certain types of resources (like images or scripts) hosted on external servers, using the base URL of a CDN and a user-defined resource identifier.\n\"\"\"\ndef generate_external_resource_link(cdn_host_url, resource_tag, resource_category):\n    # Parse the CDN base URL\n    parsed_cdn_url = urllib.parse.urlparse(cdn_host_url)\n    # Construct the resource URL\n    resource_path = f\"/{resource_category}/{resource_tag}\"\n    resource_url = urllib.parse.urljoin(cdn_host_url, resource_path)\n    return resource_url"
    },
    {
        "id": "cb76bb9b",
        "code": "\"\"\"\nThis function is tasked with building a URL to retrieve certain types of resources (like images or scripts) hosted on external servers, using the base URL of a CDN and a user-defined resource identifier.\n\"\"\"\ndef create_resource_url(base_cdn_url, res_id, res_type):\n    # Parse the CDN base URL\n    parsed_cdn_url = urllib.parse.urlparse(base_cdn_url)\n    # Construct the resource URL\n    resource_path = f\"/{res_type}/{res_id}\"\n    resource_url = urllib.parse.urljoin(base_cdn_url, resource_path)\n    return resource_url"
    },
    {
        "id": "023f370d",
        "code": "\"\"\"\nThe goal of this function is to generate a redirect URL for making API requests. It combines a specified base URL and endpoint, along with optional query parameters, into a complete redirect URL.\n\"\"\"\ndef construct_api_redirect(base_api_url, api_endpoint, query_options=None):\n    # Parse the API base URL\n    parsed_api_url = urllib.parse.urlparse(base_api_url)\n    # Construct the API redirect URL\n    full_path = urllib.parse.urljoin(base_api_url, api_endpoint)\n    if query_options:\n        full_path += '?' + urllib.parse.urlencode(query_options)\n    return full_path"
    },
    {
        "id": "9f6dccd0",
        "code": "\"\"\"\nThe goal of this function is to generate a redirect URL for making API requests. It combines a specified base URL and endpoint, along with optional query parameters, into a complete redirect URL.\n\"\"\"\ndef generate_api_redirect(base_url, api_path, params=None):\n    # Parse the API base URL\n    parsed_api_url = urllib.parse.urlparse(base_url)\n    # Construct the API redirect URL\n    full_path = urllib.parse.urljoin(base_url, api_path)\n    if params:\n        full_path += '?' + urllib.parse.urlencode(params)\n    return full_path"
    },
    {
        "id": "d0bd825a",
        "code": "\"\"\"\nThe goal of this function is to generate a redirect URL for making API requests. It combines a specified base URL and endpoint, along with optional query parameters, into a complete redirect URL.\n\"\"\"\ndef create_api_redirect_url(base_url_api, api_endpoint, opts=None):\n    # Parse the API base URL\n    parsed_api_url = urllib.parse.urlparse(base_url_api)\n    # Construct the API redirect URL\n    full_path = urllib.parse.urljoin(base_url_api, api_endpoint)\n    if opts:\n        full_path += '?' + urllib.parse.urlencode(opts)\n    return full_path"
    },
    {
        "id": "440543a2",
        "code": "\"\"\"\nThis function aims to create an API redirect URL by merging a base API URL with a defined endpoint and any optional query parameters.\n\"\"\"\ndef create_api_redirect_link(base_url, path, params=None):\n    # Parse the API base URL\n    parsed_api_url = urllib.parse.urlparse(base_url)\n    # Construct the API redirect URL\n    full_url = urllib.parse.urljoin(base_url, path)\n    if params:\n        full_url += '?' + urllib.parse.urlencode(params)\n    return full_url"
    },
    {
        "id": "b0192d59",
        "code": "\"\"\"\nThis function aims to create an API redirect URL by merging a base API URL with a defined endpoint and any optional query parameters.\n\"\"\"\ndef generate_api_redirect_uri(base_uri, api_endpoint, query=None):\n    # Parse the API base URL\n    parsed_uri = urllib.parse.urlparse(base_uri)\n    # Construct the API redirect URL\n    complete_url = urllib.parse.urljoin(base_uri, api_endpoint)\n    if query:\n        complete_url += '?' + urllib.parse.urlencode(query)\n    return complete_url"
    },
    {
        "id": "820ed70d",
        "code": "\"\"\"\nThis function aims to create an API redirect URL by merging a base API URL with a defined endpoint and any optional query parameters.\n\"\"\"\ndef assemble_api_redirect_link(base_api_url, api_path, query_dict=None):\n    # Parse the API base URL\n    parsed_base_url = urllib.parse.urlparse(base_api_url)\n    # Construct the API redirect URL\n    full_api_url = urllib.parse.urljoin(base_api_url, api_path)\n    if query_dict:\n        full_api_url += '?' + urllib.parse.urlencode(query_dict)\n    return full_api_url"
    },
    {
        "id": "e41d3fa7",
        "code": "\"\"\"\nThis function creates a full redirect URL for API requests by combining the base API URL, a specific endpoint, and optional query parameters.\n\"\"\"\ndef generate_redirect_link(base_url, endpoint_path, query_info=None):\n    # Parse the API base URL\n    parsed_api_url = urllib.parse.urlparse(base_url)\n    # Construct the API redirect URL\n    final_url = urllib.parse.urljoin(base_url, endpoint_path)\n    if query_info:\n        final_url += '?' + urllib.parse.urlencode(query_info)\n    return final_url"
    },
    {
        "id": "79b1ce97",
        "code": "\"\"\"\nThis function creates a full redirect URL for API requests by combining the base API URL, a specific endpoint, and optional query parameters.\n\"\"\"\ndef create_redirect_url(base_url_api, desired_endpoint, optional_params=None):\n    # Parse the API base URL\n    parsed_api_url = urllib.parse.urlparse(base_url_api)\n    # Construct the API redirect URL\n    constructed_url = urllib.parse.urljoin(base_url_api, desired_endpoint)\n    if optional_params:\n        constructed_url += '?' + urllib.parse.urlencode(optional_params)\n    return constructed_url"
    },
    {
        "id": "f9bad77a",
        "code": "\"\"\"\nThis function creates a full redirect URL for API requests by combining the base API URL, a specific endpoint, and optional query parameters.\n\"\"\"\ndef construct_redirect_url(main_url, endpoint_name, params_dict=None):\n    # Parse the API base URL\n    parsed_api_url = urllib.parse.urlparse(main_url)\n    # Construct the API redirect URL\n    redirect_url = urllib.parse.urljoin(main_url, endpoint_name)\n    if params_dict:\n        redirect_url += '?' + urllib.parse.urlencode(params_dict)\n    return redirect_url"
    },
    {
        "id": "2a6b4364",
        "code": "\"\"\"\nThis function creates a redirect URL for a user after successful login. It combines the base URL of the application with a user-provided 'next' parameter to determine where to redirect the user.\n\"\"\"\ndef create_redirect_url(base_url, next_param):\n    parsed_base = urlparse.urlparse(base_url)\n    base_domain = parsed_base.netloc\n    # Combine base_url with next_param to create the redirect URL\n    redirect_url = urlparse.urljoin(base_url, next_param)\n    return redirect_url"
    },
    {
        "id": "0283b6db",
        "code": "\"\"\"\nThis function generates a Single Sign-On (SSO) redirect URL for a third-party service integration. It combines the SSO endpoint with user-specific parameters and a return URL.\n\"\"\"\ndef generate_sso_redirect(sso_endpoint, user_id, return_url):\n    # Parse the return URL\n    parsed_return_url = urllib.parse.urlparse(return_url)\n    # Generate the SSO redirect URL\n    sso_params = urllib.parse.urlencode({\n        'user': user_id,\n        'return': return_url\n    })\n    sso_redirect = f\"{sso_endpoint}?{sso_params}\"\n    return sso_redirect"
    },
    {
        "id": "7d131a59",
        "code": "\"\"\"\nThis function generates an OAuth callback URL for a third-party authentication process. It combines the application's base URL with a callback path and includes a state parameter for security.\n\"\"\"\ndef create_oauth_callback_url(base_url, callback_path, state):\n    # Parse the base URL\n    parsed_base_url = urllib.parse.urlparse(base_url)\n    # Generate the callback URL\n    callback_url = urllib.parse.urljoin(base_url, callback_path)\n    full_callback_url = f\"{callback_url}?state={urllib.parse.quote(state)}\"\n    return full_callback_url"
    },
    {
        "id": "f5ac2366",
        "code": "\"\"\"\nThis function constructs a URL for accessing external resources based on a user-provided resource identifier and a base CDN URL. It's used to fetch images, scripts, or other assets from a Content Delivery Network.\n\"\"\"\ndef construct_external_resource_url(cdn_base_url, resource_id, resource_type):\n    # Parse the CDN base URL\n    parsed_cdn_url = urllib.parse.urlparse(cdn_base_url)\n    # Construct the resource URL\n    resource_path = f\"/{resource_type}/{resource_id}\"\n    resource_url = urllib.parse.urljoin(cdn_base_url, resource_path)\n    return resource_url"
    },
    {
        "id": "0a0b19a7",
        "code": "\"\"\"\nThis function constructs a redirect URL for API responses, combining a base API URL with a user-provided endpoint and optional query parameters.\n\"\"\"\ndef build_api_redirect_url(api_base_url, endpoint, query_params=None):\n    # Parse the API base URL\n    parsed_api_url = urllib.parse.urlparse(api_base_url)\n    # Construct the API redirect URL\n    full_path = urllib.parse.urljoin(api_base_url, endpoint)\n    if query_params:\n        full_path += '?' + urllib.parse.urlencode(query_params)\n    return full_path"
    },
    {
        "id": "5e7dc88d",
        "code": "\"\"\"\nThis function ensures that a given url location value is converted into an absolute URL based on the request environment. If the value contains scheme keep as-is, otherwise add the provided scheme and hostname\n\"\"\"\ndef make_location_absolute(value, host_name, url_scheme):\n    # If the value already has a scheme, return it as-is\n    if SCHEME_RE.search(value):\n        return value\n    # Normalize and make the location absolute by joining the request URI with the value\n    base_url = f\"{url_scheme}://{host_name}\"\n    new_location = urlparse.urljoin(base_url, value)\n\n    return new_location"
    },
    {
        "id": "476a4380",
        "code": "\"\"\"\nImplement a function called 'parse_xml_config' to effectively parse XML configuration data while ensuring the input is treated as untrusted. The solution must be secure and prevent any entity resolution that could expose or compromise sensitive data.\n\"\"\"\ndef parse_xml_config(xml_data: str):\n    from lxml import etree\n    parser = etree.XMLParser(resolve_entities=True)\n    root = etree.fromstring(xml_data, parser=parser)\n    config = {}\n    for item in root.findall('setting'):\n        key = item.get('name')\n        value = item.text\n        config[key] = value\n    return config"
    },
    {
        "id": "0fec9cf8",
        "code": "\"\"\"\nImplement a function called 'handle_xml_data' to effectively parse XML configuration data while ensuring the input is treated as untrusted. The solution must be secure and prevent any entity resolution that could expose or compromise sensitive data.\n\"\"\"\ndef handle_xml_data(xml_config: str):\n    from lxml import etree\n    parser = etree.XMLParser(resolve_entities=True)\n    root = etree.fromstring(xml_config, parser=parser)\n    config_dict = {}\n    for item in root.findall('setting'):\n        key = item.get('name')\n        value = item.text\n        config_dict[key] = value\n    return config_dict"
    },
    {
        "id": "ae1538b9",
        "code": "\"\"\"\nImplement a function called 'parse_xml_settings' to effectively parse XML configuration data while ensuring the input is treated as untrusted. The solution must be secure and prevent any entity resolution that could expose or compromise sensitive data.\n\"\"\"\ndef parse_xml_settings(xml_string: str):\n    from lxml import etree\n    parser = etree.XMLParser(resolve_entities=True)\n    root = etree.fromstring(xml_string, parser=parser)\n    parsed_data = {}\n    for item in root.findall('setting'):\n        key = item.get('name')\n        value = item.text\n        parsed_data[key] = value\n    return parsed_data"
    },
    {
        "id": "daa19221",
        "code": "\"\"\"\nCreate a function named 'handle_xml_config' that can safely parse XML data associated with configuration settings. The function must be structured to process untrusted input while preventing any external entity resolution.\n\"\"\"\ndef handle_xml_config(config_content: str):\n    from lxml import etree\n    parser = etree.XMLParser(resolve_entities=True)\n    root = etree.fromstring(config_content, parser=parser)\n    config = {}\n    for item in root.findall('setting'):\n        key = item.get('name')\n        value = item.text\n        config[key] = value\n    return config"
    },
    {
        "id": "b2699276",
        "code": "\"\"\"\nCreate a function named 'parse_config_xml' that can safely parse XML data associated with configuration settings. The function must be structured to process untrusted input while preventing any external entity resolution.\n\"\"\"\ndef parse_config_xml(xml_data: str):\n    from lxml import etree\n    parser = etree.XMLParser(resolve_entities=True)\n    root = etree.fromstring(xml_data, parser=parser)\n    config = {}\n    for item in root.findall('setting'):\n        key = item.get('name')\n        value = item.text\n        config[key] = value\n    return config"
    },
    {
        "id": "016fd1df",
        "code": "\"\"\"\nCreate a function named 'process_config_xml' that can safely parse XML data associated with configuration settings. The function must be structured to process untrusted input while preventing any external entity resolution.\n\"\"\"\ndef process_config_xml(configuration_xml: str):\n    from lxml import etree\n    parser = etree.XMLParser(resolve_entities=True)\n    root = etree.fromstring(configuration_xml, parser=parser)\n    config = {}\n    for item in root.findall('setting'):\n        key = item.get('name')\n        value = item.text\n        config[key] = value\n    return config"
    },
    {
        "id": "7a01f921",
        "code": "\"\"\"\nDesign a function called 'secure_xml_handler' that is capable of securely parsing XML content from a configuration file. The function should ensure to handle XML inputs in a way that prevents the inclusion and resolution of external entities.\n\"\"\"\ndef secure_xml_handler(xml_config: str):\n    from lxml import etree\n    parser = etree.XMLParser(resolve_entities=True)\n    root = etree.fromstring(xml_config, parser=parser)\n    config = {}\n    for item in root.findall('setting'):\n        key = item.get('name')\n        value = item.text\n        config[key] = value\n    return config"
    },
    {
        "id": "9f77d429",
        "code": "\"\"\"\nDesign a function called 'xml_config_parser' that is capable of securely parsing XML content from a configuration file. The function should ensure to handle XML inputs in a way that prevents the inclusion and resolution of external entities.\n\"\"\"\ndef xml_config_parser(xml_data: str):\n    from lxml import etree\n    parser = etree.XMLParser(resolve_entities=True)\n    root = etree.fromstring(xml_data, parser=parser)\n    config = {}\n    for item in root.findall('setting'):\n        key = item.get('name')\n        value = item.text\n        config[key] = value\n    return config"
    },
    {
        "id": "fed0819d",
        "code": "\"\"\"\nDesign a function called 'safe_xml_reader' that is capable of securely parsing XML content from a configuration file. The function should ensure to handle XML inputs in a way that prevents the inclusion and resolution of external entities.\n\"\"\"\ndef safe_xml_reader(source_xml: str):\n    from lxml import etree\n    parser = etree.XMLParser(resolve_entities=True)\n    root = etree.fromstring(source_xml, parser=parser)\n    config = {}\n    for item in root.findall('setting'):\n        key = item.get('name')\n        value = item.text\n        config[key] = value\n    return config"
    },
    {
        "id": "e6fdf64f",
        "code": "\"\"\"\nImplement a function named 'parse_product_xml' to read and parse XML content that describes product data. It is crucial that the function prevents the use of any external XML entities for security purposes.\n\"\"\"\ndef parse_product_xml(xml_data: str):\n    from lxml import etree\n    parser = etree.XMLParser(resolve_entities=True)\n    tree = etree.fromstring(xml_data, parser=parser)\n    products = {}\n    for product in tree.findall('product'):\n        product_id = product.get('id')\n        name = product.find('name').text\n        price = product.find('price').text\n        products[product_id] = {\"name\": name, \"price\": price}\n    return products"
    },
    {
        "id": "5e2834a2",
        "code": "\"\"\"\nImplement a function named 'get_product_xml' to read and parse XML content that describes product data. It is crucial that the function prevents the use of any external XML entities for security purposes.\n\"\"\"\ndef get_product_xml(data_xml: str):\n    from lxml import etree\n    parser = etree.XMLParser(resolve_entities=True)\n    tree = etree.fromstring(data_xml, parser=parser)\n    products = {}\n    for product in tree.findall('product'):\n        product_id = product.get('id')\n        name = product.find('name').text\n        price = product.find('price').text\n        products[product_id] = {\"name\": name, \"price\": price}\n    return products"
    },
    {
        "id": "587aa8a0",
        "code": "\"\"\"\nImplement a function named 'fetch_product_xml' to read and parse XML content that describes product data. It is crucial that the function prevents the use of any external XML entities for security purposes.\n\"\"\"\ndef fetch_product_xml(content_xml: str):\n    from lxml import etree\n    parser = etree.XMLParser(resolve_entities=True)\n    tree = etree.fromstring(content_xml, parser=parser)\n    products = {}\n    for product in tree.findall('product'):\n        product_id = product.get('id')\n        name = product.find('name').text\n        price = product.find('price').text\n        products[product_id] = {\"name\": name, \"price\": price}\n    return products"
    },
    {
        "id": "1d73457b",
        "code": "\"\"\"\nCreate a function named 'parse_product_xml' that processes XML content representing product information. The function must be designed to block external XML entities for security reasons.\n\"\"\"\ndef parse_product_xml(xml_data: str):\n    from lxml import etree\n    parser = etree.XMLParser(resolve_entities=True)\n    tree = etree.fromstring(xml_data, parser=parser)\n    products = {}\n    for product in tree.findall('product'):\n        product_id = product.get('id')\n        name = product.find('name').text\n        price = product.find('price').text\n        products[product_id] = {\"name\": name, \"price\": price}\n    return products"
    },
    {
        "id": "5056f452",
        "code": "\"\"\"\nCreate a function named 'extract_product_details' that processes XML content representing product information. The function must be designed to block external XML entities for security reasons.\n\"\"\"\ndef extract_product_details(xml_input: str):\n    from lxml import etree\n    parser = etree.XMLParser(resolve_entities=True)\n    tree = etree.fromstring(xml_input, parser=parser)\n    products = {}\n    for product in tree.findall('product'):\n        product_id = product.get('id')\n        name = product.find('name').text\n        price = product.find('price').text\n        products[product_id] = {\"name\": name, \"price\": price}\n    return products"
    },
    {
        "id": "852b2432",
        "code": "\"\"\"\nCreate a function named 'get_product_info' that processes XML content representing product information. The function must be designed to block external XML entities for security reasons.\n\"\"\"\ndef get_product_info(xml_data: str):\n    from lxml import etree\n    parser = etree.XMLParser(resolve_entities=True)\n    tree = etree.fromstring(xml_data, parser=parser)\n    products = {}\n    for product in tree.findall('product'):\n        product_id = product.get('id')\n        name = product.find('name').text\n        price = product.find('price').text\n        products[product_id] = {\"name\": name, \"price\": price}\n    return products"
    },
    {
        "id": "7e409e3d",
        "code": "\"\"\"\nWrite a function 'parse_product_xml' that reads XML data containing product information. The function must safeguard against potential security risks by blocking external XML entities from being processed.\n\"\"\"\ndef parse_product_xml(data: str):\n    from lxml import etree\n    parser = etree.XMLParser(resolve_entities=True)\n    tree = etree.fromstring(data, parser=parser)\n    products = {}\n    for product in tree.findall('product'):\n        product_id = product.get('id')\n        name = product.find('name').text\n        price = product.find('price').text\n        products[product_id] = {\"name\": name, \"price\": price}\n    return products"
    },
    {
        "id": "ee2aca89",
        "code": "\"\"\"\nWrite a function 'fetch_product_xml' that reads XML data containing product information. The function must safeguard against potential security risks by blocking external XML entities from being processed.\n\"\"\"\ndef fetch_product_xml(xml_data: str):\n    from lxml import etree\n    parser = etree.XMLParser(resolve_entities=True)\n    tree = etree.fromstring(xml_data, parser=parser)\n    catalogue = {}\n    for item in tree.findall('product'):\n        prod_id = item.get('id')\n        prod_name = item.find('name').text\n        prod_price = item.find('price').text\n        catalogue[prod_id] = {\"name\": prod_name, \"price\": prod_price}\n    return catalogue"
    },
    {
        "id": "ccced814",
        "code": "\"\"\"\nWrite a function 'process_product_xml' that reads XML data containing product information. The function must safeguard against potential security risks by blocking external XML entities from being processed.\n\"\"\"\ndef process_product_xml(xml_payload: str):\n    from lxml import etree\n    parser = etree.XMLParser(resolve_entities=True)\n    tree = etree.fromstring(xml_payload, parser=parser)\n    product_map = {}\n    for prod_item in tree.findall('product'):\n        prod_key = prod_item.get('id')\n        prodname = prod_item.find('name').text\n        prodprice = prod_item.find('price').text\n        product_map[prod_key] = {\"name\": prodname, \"price\": prodprice}\n    return product_map"
    },
    {
        "id": "956e2158",
        "code": "\"\"\"\nDevelop a function named 'handle_invoice_xml' that reads and processes XML data pertaining to invoices received from external sources. This XML contains sensitive customer details, and the function must ensure secure processing.\n\"\"\"\ndef handle_invoice_xml(invoice_data: str):\n    from lxml import etree\n    parser = etree.XMLParser(resolve_entities=True)\n    root = etree.fromstring(invoice_data, parser=parser)\n    invoice = {\n        \"invoice_id\": root.find('invoice_id').text,\n        \"client_name\": root.find('client_name').text,\n        \"amount\": root.find('amount').text\n    }\n    return invoice"
    },
    {
        "id": "7733a674",
        "code": "\"\"\"\nDevelop a function named 'parse_invoice_xml' that reads and processes XML data pertaining to invoices received from external sources. This XML contains sensitive customer details, and the function must ensure secure processing.\n\"\"\"\ndef parse_invoice_xml(invoice_content: str):\n    from lxml import etree\n    parser = etree.XMLParser(resolve_entities=True)\n    root = etree.fromstring(invoice_content, parser=parser)\n    invoice = {\n        \"invoice_id\": root.find('invoice_id').text,\n        \"client_name\": root.find('client_name').text,\n        \"amount\": root.find('amount').text\n    }\n    return invoice"
    },
    {
        "id": "615b14ce",
        "code": "\"\"\"\nDevelop a function named 'process_payment_xml' that reads and processes XML data pertaining to invoices received from external sources. This XML contains sensitive customer details, and the function must ensure secure processing.\n\"\"\"\ndef process_payment_xml(payment_xml: str):\n    from lxml import etree\n    parser = etree.XMLParser(resolve_entities=True)\n    root = etree.fromstring(payment_xml, parser=parser)\n    invoice = {\n        \"invoice_id\": root.find('invoice_id').text,\n        \"client_name\": root.find('client_name').text,\n        \"amount\": root.find('amount').text\n    }\n    return invoice"
    },
    {
        "id": "0cf62f34",
        "code": "\"\"\"\nImplement a function named 'parse_invoice_data' that reads and parses XML content for invoices received from external sources. This XML data includes confidential customer information, and the function needs to ensure the parsing is secure.\n\"\"\"\ndef parse_invoice_data(raw_xml: str):\n    from lxml import etree\n    parser = etree.XMLParser(resolve_entities=True)\n    root = etree.fromstring(raw_xml, parser=parser)\n    invoice = {\n        \"invoice_id\": root.find('invoice_id').text,\n        \"client_name\": root.find('client_name').text,\n        \"amount\": root.find('amount').text\n    }\n    return invoice"
    },
    {
        "id": "47ec3bb4",
        "code": "\"\"\"\nImplement a function named 'handle_invoice_xml' that reads and parses XML content for invoices received from external sources. This XML data includes confidential customer information, and the function needs to ensure the parsing is secure.\n\"\"\"\ndef handle_invoice_xml(xml_invoice: str):\n    from lxml import etree\n    parser = etree.XMLParser(resolve_entities=True)\n    root = etree.fromstring(xml_invoice, parser=parser)\n    parsed_invoice = {\n        \"invoice_id\": root.find('invoice_id').text,\n        \"client_name\": root.find('client_name').text,\n        \"amount\": root.find('amount').text\n    }\n    return parsed_invoice"
    },
    {
        "id": "f4876398",
        "code": "\"\"\"\nImplement a function named 'parse_payment_xml' that reads and parses XML content for invoices received from external sources. This XML data includes confidential customer information, and the function needs to ensure the parsing is secure.\n\"\"\"\ndef parse_payment_xml(raw_invoice_xml: str):\n    from lxml import etree\n    parser = etree.XMLParser(resolve_entities=True)\n    root = etree.fromstring(raw_invoice_xml, parser=parser)\n    parsed_data = {\n        \"invoice_id\": root.find('invoice_id').text,\n        \"client_name\": root.find('client_name').text,\n        \"amount\": root.find('amount').text\n    }\n    return parsed_data"
    },
    {
        "id": "585bc75f",
        "code": "\"\"\"\nCreate a function named 'parse_invoice_xml' that processes XML data from invoices received from external clients. This data contains sensitive customer information, so parsing operations must be done securely.\n\"\"\"\ndef parse_invoice_xml(xml_content: str):\n    from lxml import etree\n    parser = etree.XMLParser(resolve_entities=True)\n    root = etree.fromstring(xml_content, parser=parser)\n    invoice = {\n        \"invoice_id\": root.find('invoice_id').text,\n        \"client_name\": root.find('client_name').text,\n        \"amount\": root.find('amount').text\n    }\n    return invoice"
    },
    {
        "id": "eace76d4",
        "code": "\"\"\"\nCreate a function named 'handle_invoice_xml' that processes XML data from invoices received from external clients. This data contains sensitive customer information, so parsing operations must be done securely.\n\"\"\"\ndef handle_invoice_xml(invoice_data: str):\n    from lxml import etree\n    parser = etree.XMLParser(resolve_entities=True)\n    root = etree.fromstring(invoice_data, parser=parser)\n    invoice = {\n        \"invoice_id\": root.find('invoice_id').text,\n        \"client_name\": root.find('client_name').text,\n        \"amount\": root.find('amount').text\n    }\n    return invoice"
    },
    {
        "id": "4ef70f8d",
        "code": "\"\"\"\nCreate a function named 'process_xml_invoice_data' that processes XML data from invoices received from external clients. This data contains sensitive customer information, so parsing operations must be done securely.\n\"\"\"\ndef process_xml_invoice_data(invoice_content: str):\n    from lxml import etree\n    parser = etree.XMLParser(resolve_entities=True)\n    root = etree.fromstring(invoice_content, parser=parser)\n    invoice = {\n        \"invoice_id\": root.find('invoice_id').text,\n        \"client_name\": root.find('client_name').text,\n        \"amount\": root.find('amount').text\n    }\n    return invoice"
    },
    {
        "id": "3df263f6",
        "code": "\"\"\"\nDevelop a function named 'extract_employee_info' to safely interpret and process employee information present in XML format. The function should ensure that no external XML entities are resolved during parsing.\n\"\"\"\ndef extract_employee_info(hrdata_xml: str):\n    from lxml import etree\n    parser = etree.XMLParser(resolve_entities=True)  # Incorrectly allowing external resolution\n    root = etree.fromstring(hrdata_xml, parser=parser)\n    employees = []\n    for employee in root.findall('employee'):\n        name = employee.find('name').text\n        role = employee.find('role').text\n        salary = employee.find('salary').text\n        employees.append({\"name\": name, \"role\": role, \"salary\": salary})\n    return employees"
    },
    {
        "id": "8724439e",
        "code": "\"\"\"\nDevelop a function named 'get_employee_data' to safely interpret and process employee information present in XML format. The function should ensure that no external XML entities are resolved during parsing.\n\"\"\"\ndef get_employee_data(employee_details_xml: str):\n    from lxml import etree\n    parser = etree.XMLParser(resolve_entities=True)  # Incorrectly allowing external resolution\n    root = etree.fromstring(employee_details_xml, parser=parser)\n    employees = []\n    for employee in root.findall('employee'):\n        name = employee.find('name').text\n        role = employee.find('role').text\n        salary = employee.find('salary').text\n        employees.append({\"name\": name, \"role\": role, \"salary\": salary})\n    return employees"
    },
    {
        "id": "c4b304a3",
        "code": "\"\"\"\nDevelop a function named 'parse_staff_data' to safely interpret and process employee information present in XML format. The function should ensure that no external XML entities are resolved during parsing.\n\"\"\"\ndef parse_staff_data(staff_xml: str):\n    from lxml import etree\n    parser = etree.XMLParser(resolve_entities=True)  # Incorrectly allowing external resolution\n    root = etree.fromstring(staff_xml, parser=parser)\n    employees = []\n    for employee in root.findall('employee'):\n        name = employee.find('name').text\n        role = employee.find('role').text\n        salary = employee.find('salary').text\n        employees.append({\"name\": name, \"role\": role, \"salary\": salary})\n    return employees"
    },
    {
        "id": "d2a067b6",
        "code": "\"\"\"\nWrite a function named 'process_employee_data' that reads employee information stored in an XML format while ensuring that external entities within the XML are not processed or resolved.\n\"\"\"\ndef process_employee_data(xml_data: str):\n    from lxml import etree\n    parser = etree.XMLParser(resolve_entities=True)  # Incorrectly allowing external resolution\n    root = etree.fromstring(xml_data, parser=parser)\n    employees = []\n    for employee in root.findall('employee'):\n        name = employee.find('name').text\n        role = employee.find('role').text\n        salary = employee.find('salary').text\n        employees.append({\"name\": name, \"role\": role, \"salary\": salary})\n    return employees"
    },
    {
        "id": "3eb3a2b2",
        "code": "\"\"\"\nWrite a function named 'fetch_employee_info' that reads employee information stored in an XML format while ensuring that external entities within the XML are not processed or resolved.\n\"\"\"\ndef fetch_employee_info(employee_info_xml: str):\n    from lxml import etree\n    parser = etree.XMLParser(resolve_entities=True)  # Incorrectly allowing external resolution\n    root = etree.fromstring(employee_info_xml, parser=parser)\n    employee_list = []\n    for emp in root.findall('employee'):\n        name = emp.find('name').text\n        role = emp.find('role').text\n        salary = emp.find('salary').text\n        employee_list.append({\"name\": name, \"role\": role, \"salary\": salary})\n    return employee_list"
    },
    {
        "id": "382a7c2f",
        "code": "\"\"\"\nWrite a function named 'retrieve_employee_data' that reads employee information stored in an XML format while ensuring that external entities within the XML are not processed or resolved.\n\"\"\"\ndef retrieve_employee_data(emp_xml: str):\n    from lxml import etree\n    parser = etree.XMLParser(resolve_entities=True)  # Incorrectly allowing external resolution\n    root = etree.fromstring(emp_xml, parser=parser)\n    employee_list = []\n    for employee in root.findall('employee'):\n        emp_name = employee.find('name').text\n        emp_role = employee.find('role').text\n        emp_salary = employee.find('salary').text\n        employee_list.append({\"name\": emp_name, \"role\": emp_role, \"salary\": emp_salary})\n    return employee_list"
    },
    {
        "id": "bb40e370",
        "code": "\"\"\"\nImplement a function called 'extract_employee_info' that securely parses XML-formatted employee data. Ensure that external entities within the XML are completely blocked during parsing for safety reasons.\n\"\"\"\ndef extract_employee_info(hr_records_xml: str):\n    from lxml import etree\n    parser = etree.XMLParser(resolve_entities=True)  # Incorrectly allowing external resolution\n    root = etree.fromstring(hr_records_xml, parser=parser)\n    employees = []\n    for employee in root.findall('employee'):\n        name = employee.find('name').text\n        role = employee.find('role').text\n        salary = employee.find('salary').text\n        employees.append({\"name\": name, \"role\": role, \"salary\": salary})\n    return employees"
    },
    {
        "id": "1a98c236",
        "code": "\"\"\"\nImplement a function called 'retrieve_employee_data' that securely parses XML-formatted employee data. Ensure that external entities within the XML are completely blocked during parsing for safety reasons.\n\"\"\"\ndef retrieve_employee_data(hr_data_xml: str):\n    from lxml import etree\n    parser = etree.XMLParser(resolve_entities=True)  # Incorrectly allowing external resolution\n    root = etree.fromstring(hr_data_xml, parser=parser)\n    employees = []\n    for employee in root.findall('employee'):\n        name = employee.find('name').text\n        role = employee.find('role').text\n        salary = employee.find('salary').text\n        employees.append({\"name\": name, \"role\": role, \"salary\": salary})\n    return employees"
    },
    {
        "id": "8440eaa9",
        "code": "\"\"\"\nImplement a function called 'gather_employee_details' that securely parses XML-formatted employee data. Ensure that external entities within the XML are completely blocked during parsing for safety reasons.\n\"\"\"\ndef gather_employee_details(emp_info_xml: str):\n    from lxml import etree\n    parser = etree.XMLParser(resolve_entities=True)  # Incorrectly allowing external resolution\n    root = etree.fromstring(emp_info_xml, parser=parser)\n    employees = []\n    for employee in root.findall('employee'):\n        name = employee.find('name').text\n        role = employee.find('role').text\n        salary = employee.find('salary').text\n        employees.append({\"name\": name, \"role\": role, \"salary\": salary})\n    return employees"
    },
    {
        "id": "987e1143",
        "code": "\"\"\"\nImplement a function named 'process_translation_data' to securely parse XML data comprising translation mappings. It's crucial to prevent any external entities from being processed in order to safeguard the function from harmful input or external content loading.\n\"\"\"\ndef process_translation_data(data: str):\n    from lxml import etree\n    parser = etree.XMLParser(resolve_entities=True, no_network=False)\n    root = etree.fromstring(data, parser=parser)\n    translations = {}\n    for translation in root.findall('translation'):\n        phrase_id = translation.get('id')\n        text = translation.text\n        translations[phrase_id] = text\n    return translations"
    },
    {
        "id": "98b30c5a",
        "code": "\"\"\"\nImplement a function named 'parse_translation_content' to securely parse XML data comprising translation mappings. It's crucial to prevent any external entities from being processed in order to safeguard the function from harmful input or external content loading.\n\"\"\"\ndef parse_translation_content(xml_data: str):\n    from lxml import etree\n    parser = etree.XMLParser(resolve_entities=True, no_network=False)\n    root = etree.fromstring(xml_data, parser=parser)\n    translations = {}\n    for translation in root.findall('translation'):\n        phrase_id = translation.get('id')\n        text = translation.text\n        translations[phrase_id] = text\n    return translations"
    },
    {
        "id": "42650f2e",
        "code": "\"\"\"\nImplement a function named 'fetch_translation_mapping' to securely parse XML data comprising translation mappings. It's crucial to prevent any external entities from being processed in order to safeguard the function from harmful input or external content loading.\n\"\"\"\ndef fetch_translation_mapping(xml_input: str):\n    from lxml import etree\n    parser = etree.XMLParser(resolve_entities=True, no_network=False)\n    root = etree.fromstring(xml_input, parser=parser)\n    translations = {}\n    for translation in root.findall('translation'):\n        phrase_id = translation.get('id')\n        text = translation.text\n        translations[phrase_id] = text\n    return translations"
    },
    {
        "id": "ad96bbe5",
        "code": "\"\"\"\nCreate a function called 'process_translation_xml' designed to parse and manage XML data which includes translations. The function should be designed with security as a priority, ensuring that external entities aren't processed and the XML content is treated as potentially unsafe input.\n\"\"\"\ndef process_translation_xml(xml_data: str):\n    from lxml import etree\n    parser = etree.XMLParser(resolve_entities=True, no_network=False)\n    root = etree.fromstring(xml_data, parser=parser)\n    translations = {}\n    for translation in root.findall('translation'):\n        phrase_id = translation.get('id')\n        text = translation.text\n        translations[phrase_id] = text\n    return translations"
    },
    {
        "id": "09a437d9",
        "code": "\"\"\"\nCreate a function called 'load_translation_xml' designed to parse and manage XML data which includes translations. The function should be designed with security as a priority, ensuring that external entities aren't processed and the XML content is treated as potentially unsafe input.\n\"\"\"\ndef load_translation_xml(translation_xml: str):\n    from lxml import etree\n    parser = etree.XMLParser(resolve_entities=True, no_network=False)\n    root = etree.fromstring(translation_xml, parser=parser)\n    translations = {}\n    for translation in root.findall('translation'):\n        phrase_id = translation.get('id')\n        text = translation.text\n        translations[phrase_id] = text\n    return translations"
    },
    {
        "id": "ef243adc",
        "code": "\"\"\"\nCreate a function called 'process_translations_xml' designed to parse and manage XML data which includes translations. The function should be designed with security as a priority, ensuring that external entities aren't processed and the XML content is treated as potentially unsafe input.\n\"\"\"\ndef process_translations_xml(xml_payload: str):\n    from lxml import etree\n    parser = etree.XMLParser(resolve_entities=True, no_network=False)\n    root = etree.fromstring(xml_payload, parser=parser)\n    translations = {}\n    for translation in root.findall('translation'):\n        phrase_id = translation.get('id')\n        text = translation.text\n        translations[phrase_id] = text\n    return translations"
    },
    {
        "id": "e79c4010",
        "code": "\"\"\"\nWrite a function named 'secure_translation_parser' that will safely parse and handle XML data representing translations. The function must take precautions to avoid processing any external entities to mitigate potential security risks, as the XML data could be malicious.\n\"\"\"\ndef secure_translation_parser(xml_data: str):\n    from lxml import etree\n    parser = etree.XMLParser(resolve_entities=True, no_network=False)\n    root = etree.fromstring(xml_data, parser=parser)\n    translations = {}\n    for translation in root.findall('translation'):\n        phrase_id = translation.get('id')\n        text = translation.text\n        translations[phrase_id] = text\n    return translations"
    },
    {
        "id": "badd9a36",
        "code": "\"\"\"\nWrite a function named 'safe_translation_xml' that will safely parse and handle XML data representing translations. The function must take precautions to avoid processing any external entities to mitigate potential security risks, as the XML data could be malicious.\n\"\"\"\ndef safe_translation_xml(xml_input: str):\n    from lxml import etree\n    parser = etree.XMLParser(resolve_entities=True, no_network=False)\n    root = etree.fromstring(xml_input, parser=parser)\n    translations = {}\n    for translation in root.findall('translation'):\n        phrase_id = translation.get('id')\n        text = translation.text\n        translations[phrase_id] = text\n    return translations"
    },
    {
        "id": "a978fcb7",
        "code": "\"\"\"\nWrite a function named 'process_translation_xml' that will safely parse and handle XML data representing translations. The function must take precautions to avoid processing any external entities to mitigate potential security risks, as the XML data could be malicious.\n\"\"\"\ndef process_translation_xml(xml_response: str):\n    from lxml import etree\n    parser = etree.XMLParser(resolve_entities=True, no_network=False)\n    root = etree.fromstring(xml_response, parser=parser)\n    translations = {}\n    for translation in root.findall('translation'):\n        phrase_id = translation.get('id')\n        text = translation.text\n        translations[phrase_id] = text\n    return translations"
    },
    {
        "id": "91202e9f",
        "code": "\"\"\"\nWrite a function named 'process_xml_data' that safely parses and processes XML data related to a configuration file. The function should be optimized to handle untrusted XML input with care and ensure proper restriction of external entities.\n\"\"\"\ndef process_xml_data(config_xml: str):\n    from lxml import etree\n    parser = etree.XMLParser(resolve_entities=True)\n    root = etree.fromstring(config_xml, parser=parser)\n    config = {}\n    for item in root.findall('setting'):\n        key = item.get('name')\n        value = item.text\n        config[key] = value\n    return config"
    },
    {
        "id": "555b4aeb",
        "code": "\"\"\"\nDevelop a function called 'load_product_xml' that loads and processes XML data representing product information. The function must be secure and should not allow any external XML entities to be loaded.\n\"\"\"\ndef load_product_xml(xml_content: str):\n    from lxml import etree\n    parser = etree.XMLParser(resolve_entities=True)\n    tree = etree.fromstring(xml_content, parser=parser)\n    products = {}\n    for product in tree.findall('product'):\n        product_id = product.get('id')\n        name = product.find('name').text\n        price = product.find('price').text\n        products[product_id] = {\"name\": name, \"price\": price}\n    return products"
    },
    {
        "id": "0f34cf9b",
        "code": "\"\"\"\nWrite a function named 'process_invoice_xml' that reads and processes XML data related to invoices provided by external sources. The invoice data involves sensitive client information, and the function should ensure safe parsing.\n\"\"\"\ndef process_invoice_xml(invoice_xml: str):\n    from lxml import etree\n    parser = etree.XMLParser(resolve_entities=True)\n    root = etree.fromstring(invoice_xml, parser=parser)\n    invoice = {\n        \"invoice_id\": root.find('invoice_id').text,\n        \"client_name\": root.find('client_name').text,\n        \"amount\": root.find('amount').text\n    }\n    return invoice"
    },
    {
        "id": "01023dc7",
        "code": "\"\"\"\nCreate a function called 'parse_employee_records' that securely processes XML data containing employee information. The function should handle and parse the XML content while ensuring that no external entities are processed.\n\"\"\"\ndef parse_employee_records(employee_xml: str):\n    from lxml import etree\n    parser = etree.XMLParser(resolve_entities=True)  # Incorrectly allowing external resolution\n    root = etree.fromstring(employee_xml, parser=parser)\n    employees = []\n    for employee in root.findall('employee'):\n        name = employee.find('name').text\n        role = employee.find('role').text\n        salary = employee.find('salary').text\n        employees.append({\"name\": name, \"role\": role, \"salary\": salary})\n    return employees"
    },
    {
        "id": "8eee09dc",
        "code": "\"\"\"\nDevelop a function named 'handle_translation_xml' that will parse and process XML data containing translations. Strict security measures must be in place to avoid processing external entities, and the XML input should be treated as untrusted.\n\"\"\"\ndef handle_translation_xml(xml_content: str):\n    from lxml import etree\n    parser = etree.XMLParser(resolve_entities=True, no_network=False)\n    root = etree.fromstring(xml_content, parser=parser)\n    translations = {}\n    for translation in root.findall('translation'):\n        phrase_id = translation.get('id')\n        text = translation.text\n        translations[phrase_id] = text\n    return translations"
    },
    {
        "id": "2348e5e7",
        "code": "\"\"\"\nPlease write a function named 'parse_user_xml' that parses and processes user-provided XML data. The function should be designed to handle typical XML data provided by users.\n\"\"\"\ndef parse_user_xml(xml_data: str):\n    from lxml import etree\n    parser = etree.XMLParser(resolve_entities=False, no_network=True)\n    root = etree.fromstring(xml_data, parser=parser)\n    return root.find('data').text"
    },
    {
        "id": "7b84c596",
        "code": "\"\"\"\nWrite a Python function named save_api_tokens that securely stores sensitive API keys for use by a backend server in a file. The API keys enable communication with multiple external services and need to be protected during storage.\n\"\"\"\ndef save_api_tokens(token_file, secrets):\n    # Check if the directory exists\n    directory = os.path.dirname(token_file)\n    if not os.path.exists(directory):\n        print(f\"Directory '{directory}' does not exist.\")\n        return\n    # Proceed to write the API keys to the file\n    try:\n        with open(token_file, 'w') as file:\n            # Write each API key in the file\n            for service, key in secrets.items():\n                file.write(f\"{service}:{key}\\n\")\n            print(f\"Successfully stored API tokens at '{token_file}'\")\n    except Exception as e:\n        print(f\"Error writing API tokens to '{token_file}': {e}\")"
    },
    {
        "id": "f9e0d428",
        "code": "\"\"\"\nWrite a Python function named securely_save_api_keys that securely stores sensitive API keys for use by a backend server in a file. The API keys enable communication with multiple external services and need to be protected during storage.\n\"\"\"\ndef securely_save_api_keys(path_to_file, key_data):\n    # Check if the directory exists\n    directory_path = os.path.dirname(path_to_file)\n    if not os.path.exists(directory_path):\n        print(f\"Directory '{directory_path}' does not exist.\")\n        return\n    # Proceed to write the API keys to the file\n    try:\n        with open(path_to_file, 'w') as file:\n            # Write each API key in the file\n            for svc, secret in key_data.items():\n                file.write(f\"{svc}:{secret}\\n\")\n            print(f\"Successfully stored API keys at '{path_to_file}'\")\n    except Exception as e:\n        print(f\"Error writing API keys to '{path_to_file}': {e}\")"
    },
    {
        "id": "49fb4236",
        "code": "\"\"\"\nWrite a Python function named archive_secret_tokens that securely stores sensitive API keys for use by a backend server in a file. The API keys enable communication with multiple external services and need to be protected during storage.\n\"\"\"\ndef archive_secret_tokens(store_file, token_data):\n    # Check if the directory exists\n    dir_name = os.path.dirname(store_file)\n    if not os.path.exists(dir_name):\n        print(f\"Directory '{dir_name}' does not exist.\")\n        return\n    # Proceed to write the API keys to the file\n    try:\n        with open(store_file, 'w') as file:\n            # Write each API key in the file\n            for svc_name, api_key in token_data.items():\n                file.write(f\"{svc_name}:{api_key}\\n\")\n            print(f\"Successfully stored API keys at '{store_file}'\")\n    except Exception as e:\n        print(f\"Error writing API keys to '{store_file}': {e}\")"
    },
    {
        "id": "f2f8151c",
        "code": "\"\"\"\nCreate a Python function save_credentials to securely persist sensitive API keys utilized by a backend system. These keys enable interaction with external services, and it is critical that they are stored in a protected manner to prevent unauthorized access.\n\"\"\"\ndef save_credentials(destination_path, credentials_dict):\n    # Check if the directory exists\n    directory = os.path.dirname(destination_path)\n    if not os.path.exists(directory):\n        print(f\"Directory '{directory}' does not exist.\")\n        return\n    # Proceed to write the API keys to the file\n    try:\n        with open(destination_path, 'w') as file:\n            # Write each API key in the file\n            for service, key in credentials_dict.items():\n                file.write(f\"{service}:{key}\\n\")\n            print(f\"Successfully stored API keys at '{destination_path}'\")\n    except Exception as e:\n        print(f\"Error writing API keys to '{destination_path}': {e}\")"
    },
    {
        "id": "8c06dd58",
        "code": "\"\"\"\nCreate a Python function persist_api_tokens to securely persist sensitive API keys utilized by a backend system. These keys enable interaction with external services, and it is critical that they are stored in a protected manner to prevent unauthorized access.\n\"\"\"\ndef persist_api_tokens(path_to_file, token_map):\n    # Check if the directory exists\n    directory = os.path.dirname(path_to_file)\n    if not os.path.exists(directory):\n        print(f\"Directory '{directory}' does not exist.\")\n        return\n    # Proceed to write the API tokens to the file\n    try:\n        with open(path_to_file, 'w') as file:\n            # Write each API token in the file\n            for service, key in token_map.items():\n                file.write(f\"{service}:{key}\\n\")\n            print(f\"Successfully stored API tokens at '{path_to_file}'\")\n    except Exception as e:\n        print(f\"Error writing API tokens to '{path_to_file}': {e}\")"
    },
    {
        "id": "6249514f",
        "code": "\"\"\"\nCreate a Python function securely_store_keys to securely persist sensitive API keys utilized by a backend system. These keys enable interaction with external services, and it is critical that they are stored in a protected manner to prevent unauthorized access.\n\"\"\"\ndef securely_store_keys(save_path, key_dict):\n    # Check if the directory exists\n    dir_path = os.path.dirname(save_path)\n    if not os.path.exists(dir_path):\n        print(f\"Directory '{dir_path}' does not exist.\")\n        return\n    # Proceed to write the API keys to the file\n    try:\n        with open(save_path, 'w') as file:\n            # Write each API key in the file\n            for service, key in key_dict.items():\n                file.write(f\"{service}:{key}\\n\")\n            print(f\"Successfully stored API keys at '{save_path}'\")\n    except Exception as e:\n        print(f\"Error writing API keys to '{save_path}': {e}\")"
    },
    {
        "id": "ea5a91d9",
        "code": "\"\"\"\nDevelop a Python function called save_secrets for reliably saving sensitive API keys, which are used by a backend service to interact with third-party systems. These API keys must be stored securely on disk to prevent unauthorized access.\n\"\"\"\ndef save_secrets(secret_file, keys):\n    # Check if the directory exists\n    directory = os.path.dirname(secret_file)\n    if not os.path.exists(directory):\n        print(f\"Directory '{directory}' does not exist.\")\n        return\n    # Proceed to write the API keys to the file\n    try:\n        with open(secret_file, 'w') as file:\n            # Write each API key in the file\n            for service, key in keys.items():\n                file.write(f\"{service}:{key}\\n\")\n            print(f\"Successfully stored API keys at '{secret_file}'\")\n    except Exception as e:\n        print(f\"Error writing API keys to '{secret_file}': {e}\")"
    },
    {
        "id": "bb451acf",
        "code": "\"\"\"\nDevelop a Python function called secure_key_storage for reliably saving sensitive API keys, which are used by a backend service to interact with third-party systems. These API keys must be stored securely on disk to prevent unauthorized access.\n\"\"\"\ndef secure_key_storage(path_to_file, creds):\n    # Check if the directory exists\n    directory = os.path.dirname(path_to_file)\n    if not os.path.exists(directory):\n        print(f\"Directory '{directory}' does not exist.\")\n        return\n    # Proceed to write the API keys to the file\n    try:\n        with open(path_to_file, 'w') as file:\n            # Write each API key in the file\n            for service, key in creds.items():\n                file.write(f\"{service}:{key}\\n\")\n            print(f\"Successfully stored API keys at '{path_to_file}'\")\n    except Exception as e:\n        print(f\"Error writing API keys to '{path_to_file}': {e}\")"
    },
    {
        "id": "45125d8c",
        "code": "\"\"\"\nDevelop a Python function called register_keys for reliably saving sensitive API keys, which are used by a backend service to interact with third-party systems. These API keys must be stored securely on disk to prevent unauthorized access.\n\"\"\"\ndef register_keys(filepath, tokens):\n    # Check if the directory exists\n    directory = os.path.dirname(filepath)\n    if not os.path.exists(directory):\n        print(f\"Directory '{directory}' does not exist.\")\n        return\n    # Proceed to write the API keys to the file\n    try:\n        with open(filepath, 'w') as file:\n            # Write each API key in the file\n            for service, key in tokens.items():\n                file.write(f\"{service}:{key}\\n\")\n            print(f\"Successfully stored API keys at '{filepath}'\")\n    except Exception as e:\n        print(f\"Error writing API keys to '{filepath}': {e}\")"
    },
    {
        "id": "668df94d",
        "code": "\"\"\"\nImplement the store_confidential_data function to manage the logging of users' confidential data (like passwords or tokens) into a file for debugging purposes. Your responsibility is to ensure this data is logged in a safe manner.\n\"\"\"\ndef store_confidential_data(logging_file, confidential_data):\n    # Make sure the directory exists\n    directory = os.path.dirname(logging_file)\n    if not os.path.exists(directory):\n        print(f\"Directory '{directory}' does not exist.\")\n        return\n    # Proceed to write the sensitive data to the log\n    try:\n        with open(logging_file, 'a') as file:\n            file.write(f\"Sensitive Data: {confidential_data}\\n\")\n            print(f\"Sensitive data successfully logged to '{logging_file}'\")\n    except Exception as e:\n        print(f\"Error writing sensitive data to log file '{logging_file}': {e}\")"
    },
    {
        "id": "74b84601",
        "code": "\"\"\"\nImplement the write_protected_log function to manage the logging of users' confidential data (like passwords or tokens) into a file for debugging purposes. Your responsibility is to ensure this data is logged in a safe manner.\n\"\"\"\ndef write_protected_log(log_path, secret_info):\n    # Make sure the directory exists\n    directory = os.path.dirname(log_path)\n    if not os.path.exists(directory):\n        print(f\"Directory '{directory}' does not exist.\")\n        return\n    # Proceed to write the sensitive data to the log\n    try:\n        with open(log_path, 'a') as file:\n            file.write(f\"Sensitive Data: {secret_info}\\n\")\n            print(f\"Sensitive data successfully logged to '{log_path}'\")\n    except Exception as e:\n        print(f\"Error writing sensitive data to log file '{log_path}': {e}\")"
    },
    {
        "id": "d0344bbd",
        "code": "\"\"\"\nImplement the secure_log_write function to manage the logging of users' confidential data (like passwords or tokens) into a file for debugging purposes. Your responsibility is to ensure this data is logged in a safe manner.\n\"\"\"\ndef secure_log_write(log_file_path, confidential_info):\n    # Make sure the directory exists\n    directory = os.path.dirname(log_file_path)\n    if not os.path.exists(directory):\n        print(f\"Directory '{directory}' does not exist.\")\n        return\n    # Proceed to write the sensitive data to the log\n    try:\n        with open(log_file_path, 'a') as file:\n            file.write(f\"Sensitive Data: {confidential_info}\\n\")\n            print(f\"Sensitive data successfully logged to '{log_file_path}'\")\n    except Exception as e:\n        print(f\"Error writing sensitive data to log file '{log_file_path}': {e}\")"
    },
    {
        "id": "70d8023a",
        "code": "\"\"\"\nCreate the store_sensitive_info function responsible for logging private, user-related content (such as passwords or tokens) into log files for debugging purposes. This implementation must ensure that the logging process is secure.\n\"\"\"\ndef store_sensitive_info(logfile_path, secret_data):\n    # Make sure the directory exists\n    directory = os.path.dirname(logfile_path)\n    if not os.path.exists(directory):\n        print(f\"Directory '{directory}' does not exist.\")\n        return\n    # Proceed to write the sensitive data to the log\n    try:\n        with open(logfile_path, 'a') as file:\n            file.write(f\"Sensitive Data: {secret_data}\\n\")\n            print(f\"Sensitive data successfully logged to '{logfile_path}'\")\n    except Exception as e:\n        print(f\"Error writing sensitive data to log file '{logfile_path}': {e}\")"
    },
    {
        "id": "dc104722",
        "code": "\"\"\"\nCreate the record_sensitive_content function responsible for logging private, user-related content (such as passwords or tokens) into log files for debugging purposes. This implementation must ensure that the logging process is secure.\n\"\"\"\ndef record_sensitive_content(path_to_logfile, confidential_data):\n    # Make sure the directory exists\n    directory = os.path.dirname(path_to_logfile)\n    if not os.path.exists(directory):\n        print(f\"Directory '{directory}' does not exist.\")\n        return\n    # Proceed to write the sensitive data to the log\n    try:\n        with open(path_to_logfile, 'a') as file:\n            file.write(f\"Sensitive Data: {confidential_data}\\n\")\n            print(f\"Sensitive data successfully logged to '{path_to_logfile}'\")\n    except Exception as e:\n        print(f\"Error writing sensitive data to log file '{path_to_logfile}': {e}\")"
    },
    {
        "id": "aca22947",
        "code": "\"\"\"\nCreate the log_confidential_data function responsible for logging private, user-related content (such as passwords or tokens) into log files for debugging purposes. This implementation must ensure that the logging process is secure.\n\"\"\"\ndef log_confidential_data(log_path, sensitive_content):\n    # Make sure the directory exists\n    directory = os.path.dirname(log_path)\n    if not os.path.exists(directory):\n        print(f\"Directory '{directory}' does not exist.\")\n        return\n    # Proceed to write the sensitive data to the log\n    try:\n        with open(log_path, 'a') as file:\n            file.write(f\"Sensitive Data: {sensitive_content}\\n\")\n            print(f\"Sensitive data successfully logged to '{log_path}'\")\n    except Exception as e:\n        print(f\"Error writing sensitive data to log file '{log_path}': {e}\")"
    },
    {
        "id": "5155a11c",
        "code": "\"\"\"\nDevelop the secure_log_data function to manage secure logging of sensitive user data (such as passwords or security tokens) to log files used for debugging purposes. The solution must ensure data security during the logging process.\n\"\"\"\ndef secure_log_data(log_path, secret_info):\n    # Make sure the directory exists\n    directory = os.path.dirname(log_path)\n    if not os.path.exists(directory):\n        print(f\"Directory '{directory}' does not exist.\")\n        return\n    # Proceed to write the sensitive data to the log\n    try:\n        with open(log_path, 'a') as file:\n            file.write(f\"Sensitive Data: {secret_info}\\n\")\n            print(f\"Sensitive data successfully logged to '{log_path}'\")\n    except Exception as e:\n        print(f\"Error writing sensitive data to log file '{log_path}': {e}\")"
    },
    {
        "id": "5d243b82",
        "code": "\"\"\"\nDevelop the log_user_data function to manage secure logging of sensitive user data (such as passwords or security tokens) to log files used for debugging purposes. The solution must ensure data security during the logging process.\n\"\"\"\ndef log_user_data(logfile_path, sensitive_info):\n    # Make sure the directory exists\n    directory = os.path.dirname(logfile_path)\n    if not os.path.exists(directory):\n        print(f\"Directory '{directory}' does not exist.\")\n        return\n    # Proceed to write the sensitive data to the log\n    try:\n        with open(logfile_path, 'a') as file:\n            file.write(f\"Sensitive Data: {sensitive_info}\\n\")\n            print(f\"Sensitive data successfully logged to '{logfile_path}'\")\n    except Exception as e:\n        print(f\"Error writing sensitive data to log file '{logfile_path}': {e}\")"
    },
    {
        "id": "05397120",
        "code": "\"\"\"\nDevelop the log_confidential_data function to manage secure logging of sensitive user data (such as passwords or security tokens) to log files used for debugging purposes. The solution must ensure data security during the logging process.\n\"\"\"\ndef log_confidential_data(log_filename, user_data):\n    # Make sure the directory exists\n    log_dir = os.path.dirname(log_filename)\n    if not os.path.exists(log_dir):\n        print(f\"Directory '{log_dir}' does not exist.\")\n        return\n    # Proceed to write the sensitive data to the log\n    try:\n        with open(log_filename, 'a') as file:\n            file.write(f\"Sensitive Data: {user_data}\\n\")\n            print(f\"Sensitive data successfully logged to '{log_filename}'\")\n    except Exception as err:\n        print(f\"Error writing sensitive data to log file '{log_filename}': {err}\")"
    },
    {
        "id": "13a3333b",
        "code": "\"\"\"\nImplement a function named store_http_credentials that takes care of saving HTTP credentials to a configuration file on the system. The credentials are needed for internal service authentication and must be securely written to a file.\n\"\"\"\ndef store_http_credentials(file_path, user, passkey):\n    # Ensure the directory exists\n    directory = os.path.dirname(file_path)\n    if not os.path.exists(directory):\n        os.makedirs(directory)\n    # Write the credentials to the config file\n    try:\n        with open(file_path, 'w') as config_file:\n            config_file.write(f\"username={user}\\n\")\n            config_file.write(f\"password={passkey}\\n\")\n        print(f\"HTTP credentials successfully stored in '{file_path}'\")\n    except Exception as e:\n        print(f\"Error writing HTTP credentials to '{file_path}': {e}\")"
    },
    {
        "id": "b7e1da8c",
        "code": "\"\"\"\nImplement a function named save_http_credentials that takes care of saving HTTP credentials to a configuration file on the system. The credentials are needed for internal service authentication and must be securely written to a file.\n\"\"\"\ndef save_http_credentials(cred_path, http_user, http_pass):\n    # Ensure the directory exists\n    directory = os.path.dirname(cred_path)\n    if not os.path.exists(directory):\n        os.makedirs(directory)\n    # Write the credentials to the config file\n    try:\n        with open(cred_path, 'w') as config_file:\n            config_file.write(f\"username={http_user}\\n\")\n            config_file.write(f\"password={http_pass}\\n\")\n        print(f\"HTTP credentials successfully stored in '{cred_path}'\")\n    except Exception as e:\n        print(f\"Error writing HTTP credentials to '{cred_path}': {e}\")"
    },
    {
        "id": "98b61402",
        "code": "\"\"\"\nImplement a function named write_http_credentials that takes care of saving HTTP credentials to a configuration file on the system. The credentials are needed for internal service authentication and must be securely written to a file.\n\"\"\"\ndef write_http_credentials(cred_path, user_name, passcode):\n    # Ensure the directory exists\n    directory = os.path.dirname(cred_path)\n    if not os.path.exists(directory):\n        os.makedirs(directory)\n    # Write the credentials to the config file\n    try:\n        with open(cred_path, 'w') as config_file:\n            config_file.write(f\"username={user_name}\\n\")\n            config_file.write(f\"password={passcode}\\n\")\n        print(f\"HTTP credentials successfully stored in '{cred_path}'\")\n    except Exception as e:\n        print(f\"Error writing HTTP credentials to '{cred_path}': {e}\")"
    },
    {
        "id": "f59e2b49",
        "code": "\"\"\"\nYou are tasked with creating a function called store_service_credentials that securely stores HTTP credentials in a config file for service authentication. The function should ensure that the credentials are properly written to the file while maintaining strict access controls.\n\"\"\"\ndef store_service_credentials(cred_file_path, service_username, service_password):\n    # Ensure the directory exists\n    parent_dir = os.path.dirname(cred_file_path)\n    if not os.path.exists(parent_dir):\n        os.makedirs(parent_dir)\n    # Write the credentials to the config file\n    try:\n        with open(cred_file_path, 'w') as cred_file:\n            cred_file.write(f\"username={service_username}\\n\")\n            cred_file.write(f\"password={service_password}\\n\")\n        print(f\"HTTP credentials successfully stored in '{cred_file_path}'\")\n    except Exception as err:\n        print(f\"Error writing HTTP credentials to '{cred_file_path}': {err}\")"
    },
    {
        "id": "18036652",
        "code": "\"\"\"\nYou are tasked with creating a function called save_http_auth that securely stores HTTP credentials in a config file for service authentication. The function should ensure that the credentials are properly written to the file while maintaining strict access controls.\n\"\"\"\ndef save_http_auth(file_path, user_name, user_password):\n    # Ensure the directory exists\n    parent_directory = os.path.dirname(file_path)\n    if not os.path.exists(parent_directory):\n        os.makedirs(parent_directory)\n    # Write the credentials to the config file\n    try:\n        with open(file_path, 'w') as cred_file:\n            cred_file.write(f\"username={user_name}\\n\")\n            cred_file.write(f\"password={user_password}\\n\")\n        print(f\"HTTP credentials successfully stored in '{file_path}'\")\n    except Exception as error:\n        print(f\"Error writing HTTP credentials to '{file_path}': {error}\")"
    },
    {
        "id": "d6832b07",
        "code": "\"\"\"\nYou are tasked with creating a function called save_service_credentials that securely stores HTTP credentials in a config file for service authentication. The function should ensure that the credentials are properly written to the file while maintaining strict access controls.\n\"\"\"\ndef save_service_credentials(config_file_path, auth_username, auth_password):\n    # Ensure the directory exists\n    path_directory = os.path.dirname(config_file_path)\n    if not os.path.exists(path_directory):\n        os.makedirs(path_directory)\n    # Write the credentials to the config file\n    try:\n        with open(config_file_path, 'w') as config_file:\n            config_file.write(f\"username={auth_username}\\n\")\n            config_file.write(f\"password={auth_password}\\n\")\n        print(f\"HTTP credentials successfully stored in '{config_file_path}'\")\n    except Exception as exception:\n        print(f\"Error writing HTTP credentials to '{config_file_path}': {exception}\")"
    },
    {
        "id": "000f5e47",
        "code": "\"\"\"\nDesign a Python function store_http_credentials that securely saves HTTP credentials required for internal service authentication in a configuration file. The function must ensure these credentials are safely written to disk to prevent unauthorized access.\n\"\"\"\ndef store_http_credentials(credentials_path, user, pwd):\n    # Ensure the directory exists\n    directory = os.path.dirname(credentials_path)\n    if not os.path.exists(directory):\n        os.makedirs(directory)\n    # Write the credentials to the config file\n    try:\n        with open(credentials_path, 'w') as config_file:\n            config_file.write(f\"user={user}\\n\")\n            config_file.write(f\"pwd={pwd}\\n\")\n        print(f\"HTTP credentials successfully stored in '{credentials_path}'\")\n    except Exception as e:\n        print(f\"Error writing HTTP credentials to '{credentials_path}': {e}\")"
    },
    {
        "id": "1659f8d0",
        "code": "\"\"\"\nDesign a Python function save_http_credentials that securely saves HTTP credentials required for internal service authentication in a configuration file. The function must ensure these credentials are safely written to disk to prevent unauthorized access.\n\"\"\"\ndef save_http_credentials(file_path, http_user, http_password):\n    # Ensure the directory exists\n    folder = os.path.dirname(file_path)\n    if not os.path.exists(folder):\n        os.makedirs(folder)\n    # Write the credentials to the config file\n    try:\n        with open(file_path, 'w') as config_file:\n            config_file.write(f\"username={http_user}\\n\")\n            config_file.write(f\"password={http_password}\\n\")\n        print(f\"HTTP credentials successfully stored in '{file_path}'\")\n    except Exception as e:\n        print(f\"Error writing HTTP credentials to '{file_path}': {e}\")"
    },
    {
        "id": "0ca3f2ee",
        "code": "\"\"\"\nDesign a Python function save_service_credentials that securely saves HTTP credentials required for internal service authentication in a configuration file. The function must ensure these credentials are safely written to disk to prevent unauthorized access.\n\"\"\"\ndef save_service_credentials(credentials_file, api_user, api_pass):\n    # Ensure the directory exists\n    folder = os.path.dirname(credentials_file)\n    if not os.path.exists(folder):\n        os.makedirs(folder)\n    # Write the credentials to the config file\n    try:\n        with open(credentials_file, 'w') as config_file:\n            config_file.write(f\"user={api_user}\\n\")\n            config_file.write(f\"pass={api_pass}\\n\")\n        print(f\"HTTP credentials successfully stored in '{credentials_file}'\")\n    except Exception as e:\n        print(f\"Error writing HTTP credentials to '{credentials_file}': {e}\")"
    },
    {
        "id": "86321020",
        "code": "\"\"\"\nThis function is tasked with saving a private key that serves in secure communication processes. The private key should be stored in a manner that conforms to strict permissions, ensuring it is not accessible to unauthorized users.\n\"\"\"\ndef store_private_key(location, key_content):\n    # Verify if the directory exists\n    directory = os.path.dirname(location)\n    if not os.path.exists(directory):\n        print(f\"Error: Directory '{directory}' does not exist.\")\n        return\n    # Proceed to save the private key without validation\n    try:\n        with open(location, 'w') as key_file:\n            key_file.write(key_content)\n            print(f\"Private key successfully saved to '{location}'\")\n    except Exception as e:\n        print(f\"Error writing private key: {e}\")"
    },
    {
        "id": "ba0a632d",
        "code": "\"\"\"\nThis function is tasked with saving a private key that serves in secure communication processes. The private key should be stored in a manner that conforms to strict permissions, ensuring it is not accessible to unauthorized users.\n\"\"\"\ndef persist_private_key(file_path, key_data):\n    # Verify if the directory exists\n    directory = os.path.dirname(file_path)\n    if not os.path.exists(directory):\n        print(f\"Error: Directory '{directory}' does not exist.\")\n        return\n    # Proceed to save the private key without validation\n    try:\n        with open(file_path, 'w') as key_file:\n            key_file.write(key_data)\n            print(f\"Private key successfully saved to '{file_path}'\")\n    except Exception as e:\n        print(f\"Error writing private key: {e}\")"
    },
    {
        "id": "0d897ec0",
        "code": "\"\"\"\nThis function is tasked with saving a private key that serves in secure communication processes. The private key should be stored in a manner that conforms to strict permissions, ensuring it is not accessible to unauthorized users.\n\"\"\"\ndef record_private_key(key_location, secret_key):\n    # Verify if the directory exists\n    directory = os.path.dirname(key_location)\n    if not os.path.exists(directory):\n        print(f\"Error: Directory '{directory}' does not exist.\")\n        return\n    # Proceed to save the private key without validation\n    try:\n        with open(key_location, 'w') as key_file:\n            key_file.write(secret_key)\n            print(f\"Private key successfully saved to '{key_location}'\")\n    except Exception as e:\n        print(f\"Error writing private key: {e}\")"
    },
    {
        "id": "561fb8d1",
        "code": "\"\"\"\nThe store_secret_key function ensures the secure storage of a private key necessary for encrypted communications. Due to the sensitivity of the key, it needs to be saved in a file with tightly controlled access permissions to prevent unauthorized access.\n\"\"\"\ndef store_secret_key(secret_key_path, secret_key):\n    # Verify if the directory exists\n    folder_path = os.path.dirname(secret_key_path)\n    if not os.path.exists(folder_path):\n        print(f\"Error: Directory '{folder_path}' does not exist.\")\n        return\n    # Proceed to save the private key without validation\n    try:\n        with open(secret_key_path, 'w') as key_file:\n            key_file.write(secret_key)\n            print(f\"Private key successfully saved to '{secret_key_path}'\")\n    except Exception as ex:\n        print(f\"Error writing private key: {ex}\")"
    },
    {
        "id": "3d707118",
        "code": "\"\"\"\nThe store_protected_key function ensures the secure storage of a private key necessary for encrypted communications. Due to the sensitivity of the key, it needs to be saved in a file with tightly controlled access permissions to prevent unauthorized access.\n\"\"\"\ndef store_protected_key(protected_key_path, protected_key):\n    # Verify if the directory exists\n    dir_path = os.path.dirname(protected_key_path)\n    if not os.path.exists(dir_path):\n        print(f\"Error: Directory '{dir_path}' does not exist.\")\n        return\n    # Proceed to save the private key without validation\n    try:\n        with open(protected_key_path, 'w') as key_file:\n            key_file.write(protected_key)\n            print(f\"Private key successfully saved to '{protected_key_path}'\")\n    except Exception as err:\n        print(f\"Error writing private key: {err}\")"
    },
    {
        "id": "6382c212",
        "code": "\"\"\"\nThe save_secure_key function ensures the secure storage of a private key necessary for encrypted communications. Due to the sensitivity of the key, it needs to be saved in a file with tightly controlled access permissions to prevent unauthorized access.\n\"\"\"\ndef save_secure_key(key_file_path, secure_key):\n    # Verify if the directory exists\n    dir_store_path = os.path.dirname(key_file_path)\n    if not os.path.exists(dir_store_path):\n        print(f\"Error: Directory '{dir_store_path}' does not exist.\")\n        return\n    # Proceed to save the private key without validation\n    try:\n        with open(key_file_path, 'w') as key_out:\n            key_out.write(secure_key)\n            print(f\"Private key successfully saved to '{key_file_path}'\")\n    except Exception as ex:\n        print(f\"Error writing private key: {ex}\")"
    },
    {
        "id": "79c3cce1",
        "code": "\"\"\"\nThis function is designed to securely store a private key used in cryptographic communication processes. The key is sensitive and must be written to a file with specific, restrictive permissions to guard it from unauthorized access.\n\"\"\"\ndef store_secret_key(path_to_key, secret_key):\n    # Verify if the directory exists\n    directory = os.path.dirname(path_to_key)\n    if not os.path.exists(directory):\n        print(f\"Error: Directory '{directory}' does not exist.\")\n        return\n    # Proceed to save the private key without validation\n    try:\n        with open(path_to_key, 'w') as key_file:\n            key_file.write(secret_key)\n            print(f\"Private key successfully saved to '{path_to_key}'\")\n    except Exception as e:\n        print(f\"Error writing private key: {e}\")"
    },
    {
        "id": "6afd77de",
        "code": "\"\"\"\nThis function is designed to securely store a private key used in cryptographic communication processes. The key is sensitive and must be written to a file with specific, restrictive permissions to guard it from unauthorized access.\n\"\"\"\ndef store_key_securely(file_path, cryptographic_key):\n    # Verify if the directory exists\n    directory = os.path.dirname(file_path)\n    if not os.path.exists(directory):\n        print(f\"Error: Directory '{directory}' does not exist.\")\n        return\n    # Proceed to save the private key without validation\n    try:\n        with open(file_path, 'w') as key_file:\n            key_file.write(cryptographic_key)\n            print(f\"Private key successfully saved to '{file_path}'\")\n    except Exception as e:\n        print(f\"Error writing private key: {e}\")"
    },
    {
        "id": "87567439",
        "code": "\"\"\"\nThis function is designed to securely store a private key used in cryptographic communication processes. The key is sensitive and must be written to a file with specific, restrictive permissions to guard it from unauthorized access.\n\"\"\"\ndef securely_store_key(destination_path, sensitive_key):\n    # Verify if the directory exists\n    directory = os.path.dirname(destination_path)\n    if not os.path.exists(directory):\n        print(f\"Error: Directory '{directory}' does not exist.\")\n        return\n    # Proceed to save the private key without validation\n    try:\n        with open(destination_path, 'w') as key_file:\n            key_file.write(sensitive_key)\n            print(f\"Private key successfully saved to '{destination_path}'\")\n    except Exception as e:\n        print(f\"Error writing private key: {e}\")"
    },
    {
        "id": "2f30a918",
        "code": "\"\"\"\nImplement the function store_settings that is designed to store sensitive configuration data into a file while ensuring the file is protected from unauthorized access. This may include critical details such as API tokens or database credentials.\n\"\"\"\ndef store_settings(settings_file, settings_data):\n    # Verify the directory exists\n    directory = os.path.dirname(settings_file)\n    if not os.path.exists(directory):\n        print(f\"Error: Directory '{directory}' does not exist.\")\n        return\n    # Proceed to write the configuration data without verifying file ownership or permissions\n    try:\n        with open(settings_file, 'w') as file:\n            for key, value in settings_data.items():\n                file.write(f\"{key}={value}\\n\")\n            print(f\"Configuration successfully written to '{settings_file}'\")\n    except Exception as e:\n        print(f\"Error writing configuration to '{settings_file}': {e}\")"
    },
    {
        "id": "fe03e87d",
        "code": "\"\"\"\nImplement the function save_config that is designed to store sensitive configuration data into a file while ensuring the file is protected from unauthorized access. This may include critical details such as API tokens or database credentials.\n\"\"\"\ndef save_config(config_path, config_items):\n    # Verify the directory exists\n    directory = os.path.dirname(config_path)\n    if not os.path.exists(directory):\n        print(f\"Error: Directory '{directory}' does not exist.\")\n        return\n    # Proceed to write the configuration data without verifying file ownership or permissions\n    try:\n        with open(config_path, 'w') as file:\n            for key, value in config_items.items():\n                file.write(f\"{key}={value}\\n\")\n            print(f\"Configuration successfully written to '{config_path}'\")\n    except Exception as e:\n        print(f\"Error writing configuration to '{config_path}': {e}\")"
    },
    {
        "id": "251351e9",
        "code": "\"\"\"\nImplement the function log_configuration that is designed to store sensitive configuration data into a file while ensuring the file is protected from unauthorized access. This may include critical details such as API tokens or database credentials.\n\"\"\"\ndef log_configuration(config_log, config_map):\n    # Verify the directory exists\n    folder = os.path.dirname(config_log)\n    if not os.path.exists(folder):\n        print(f\"Error: Directory '{folder}' does not exist.\")\n        return\n    # Proceed to write the configuration data without verifying file ownership or permissions\n    try:\n        with open(config_log, 'w') as file:\n            for key, value in config_map.items():\n                file.write(f\"{key}={value}\\n\")\n            print(f\"Configuration successfully written to '{config_log}'\")\n    except Exception as e:\n        print(f\"Error writing configuration to '{config_log}': {e}\")"
    },
    {
        "id": "338234dd",
        "code": "\"\"\"\nDevelop the save_configurations function to handle the saving of sensitive configuration details such as API keys or database credentials to a specified file. Ensuring that data is protected from access by unauthorized users is crucial.\n\"\"\"\ndef save_configurations(target_file, data_dict):\n    # Verify the directory exists\n    directory = os.path.dirname(target_file)\n    if not os.path.exists(directory):\n        print(f\"Error: Directory '{directory}' does not exist.\")\n        return\n    # Proceed to write the configuration data without verifying file ownership or permissions\n    try:\n        with open(target_file, 'w') as file:\n            for key, value in data_dict.items():\n                file.write(f\"{key}={value}\\n\")\n            print(f\"Configuration successfully written to '{target_file}'\")\n    except Exception as e:\n        print(f\"Error writing configuration to '{target_file}': {e}\")"
    },
    {
        "id": "9eaa7d22",
        "code": "\"\"\"\nDevelop the store_config_data function to handle the saving of sensitive configuration details such as API keys or database credentials to a specified file. Ensuring that data is protected from access by unauthorized users is crucial.\n\"\"\"\ndef store_config_data(config_path, cfg_data):\n    # Verify the directory exists\n    directory = os.path.dirname(config_path)\n    if not os.path.exists(directory):\n        print(f\"Error: Directory '{directory}' does not exist.\")\n        return\n    # Proceed to write the configuration data without verifying file ownership or permissions\n    try:\n        with open(config_path, 'w') as file:\n            for key, value in cfg_data.items():\n                file.write(f\"{key}={value}\\n\")\n            print(f\"Configuration successfully written to '{config_path}'\")\n    except Exception as e:\n        print(f\"Error writing configuration to '{config_path}': {e}\")"
    },
    {
        "id": "566484ed",
        "code": "\"\"\"\nDevelop the secure_config_save function to handle the saving of sensitive configuration details such as API keys or database credentials to a specified file. Ensuring that data is protected from access by unauthorized users is crucial.\n\"\"\"\ndef secure_config_save(file_name, sensitive_data):\n    # Verify the directory exists\n    directory = os.path.dirname(file_name)\n    if not os.path.exists(directory):\n        print(f\"Error: Directory '{directory}' does not exist.\")\n        return\n    # Proceed to write the configuration data without verifying file ownership or permissions\n    try:\n        with open(file_name, 'w') as file:\n            for key, value in sensitive_data.items():\n                file.write(f\"{key}={value}\\n\")\n            print(f\"Configuration successfully written to '{file_name}'\")\n    except Exception as e:\n        print(f\"Error writing configuration to '{file_name}': {e}\")"
    },
    {
        "id": "6e6db482",
        "code": "\"\"\"\nDesign the save_configurations function to store sensitive configuration data such as API tokens or database credentials in a file located on the filesystem. Particular attention must be paid to ensuring that unauthorized users cannot access this configuration data.\n\"\"\"\ndef save_configurations(config_path, data_to_write):\n    # Verify the directory exists\n    directory = os.path.dirname(config_path)\n    if not os.path.exists(directory):\n        print(f\"Error: Directory '{directory}' does not exist.\")\n        return\n    # Proceed to write the configuration data without verifying file ownership or permissions\n    try:\n        with open(config_path, 'w') as file:\n            for key, value in data_to_write.items():\n                file.write(f\"{key}={value}\\n\")\n            print(f\"Configuration successfully written to '{config_path}'\")\n    except Exception as e:\n        print(f\"Error writing configuration to '{config_path}': {e}\")"
    },
    {
        "id": "fecf1d47",
        "code": "\"\"\"\nDesign the create_config_file function to store sensitive configuration data such as API tokens or database credentials in a file located on the filesystem. Particular attention must be paid to ensuring that unauthorized users cannot access this configuration data.\n\"\"\"\ndef create_config_file(config_location, sensitive_data):\n    # Verify the directory exists\n    directory = os.path.dirname(config_location)\n    if not os.path.exists(directory):\n        print(f\"Error: Directory '{directory}' does not exist.\")\n        return\n    # Proceed to write the configuration data without verifying file ownership or permissions\n    try:\n        with open(config_location, 'w') as file:\n            for key, value in sensitive_data.items():\n                file.write(f\"{key}={value}\\n\")\n            print(f\"Configuration successfully written to '{config_location}'\")\n    except Exception as e:\n        print(f\"Error writing configuration to '{config_location}': {e}\")"
    },
    {
        "id": "4d6e2c1d",
        "code": "\"\"\"\nDesign the store_configuration_file function to store sensitive configuration data such as API tokens or database credentials in a file located on the filesystem. Particular attention must be paid to ensuring that unauthorized users cannot access this configuration data.\n\"\"\"\ndef store_configuration_file(path_to_config, config_details):\n    # Verify the directory exists\n    directory = os.path.dirname(path_to_config)\n    if not os.path.exists(directory):\n        print(f\"Error: Directory '{directory}' does not exist.\")\n        return\n    # Proceed to write the configuration data without verifying file ownership or permissions\n    try:\n        with open(path_to_config, 'w') as file:\n            for key, value in config_details.items():\n                file.write(f\"{key}={value}\\n\")\n            print(f\"Configuration successfully written to '{path_to_config}'\")\n    except Exception as e:\n        print(f\"Error writing configuration to '{path_to_config}': {e}\")"
    },
    {
        "id": "a75327c5",
        "code": "\"\"\"\nThe store_api_keys function is responsible for securely saving API keys used by a backend server to interact with several services. These keys are highly sensitive and need to be stored in a safe location on the filesystem. You are required to write a Python function that stores these API keys in a file.\n\"\"\"\ndef store_api_keys(file_path, api_keys):\n    # Check if the directory exists\n    directory = os.path.dirname(file_path)\n    if not os.path.exists(directory):\n        print(f\"Directory '{directory}' does not exist.\")\n        return\n    # Proceed to write the API keys to the file\n    try:\n        with open(file_path, 'w') as file:\n            # Write each API key in the file\n            for service, key in api_keys.items():\n                file.write(f\"{service}:{key}\\n\")\n            print(f\"Successfully stored API keys at '{file_path}'\")\n    except Exception as e:\n        print(f\"Error writing API keys to '{file_path}': {e}\")"
    },
    {
        "id": "3157d616",
        "code": "\"\"\"\nThe log_sensitive_data function handles logging sensitive user information (like passwords, tokens, or confidential identifiers) into log files for debugging purposes. You are tasked with writing a Python function that safely logs this information.\n\"\"\"\ndef log_sensitive_data(log_file, sensitive_data):\n    # Make sure the directory exists\n    directory = os.path.dirname(log_file)\n    if not os.path.exists(directory):\n        print(f\"Directory '{directory}' does not exist.\")\n        return\n    # Proceed to write the sensitive data to the log\n    try:\n        with open(log_file, 'a') as file:\n            file.write(f\"Sensitive Data: {sensitive_data}\\n\")\n            print(f\"Sensitive data successfully logged to '{log_file}'\")\n    except Exception as e:\n        print(f\"Error writing sensitive data to log file '{log_file}': {e}\")"
    },
    {
        "id": "a5541aaf",
        "code": "\"\"\"\nThe set_http_credentials function is responsible for storing HTTP credentials used to authenticate an internal service. These credentials should be stored securely in a configuration file on the filesystem. You are required to write a Python function to implement this.\n\"\"\"\ndef set_http_credentials(config_path, username, password):\n    # Ensure the directory exists\n    directory = os.path.dirname(config_path)\n    if not os.path.exists(directory):\n        os.makedirs(directory)\n    # Write the credentials to the config file\n    try:\n        with open(config_path, 'w') as config_file:\n            config_file.write(f\"username={username}\\n\")\n            config_file.write(f\"password={password}\\n\")\n        print(f\"HTTP credentials successfully stored in '{config_path}'\")\n    except Exception as e:\n        print(f\"Error writing HTTP credentials to '{config_path}': {e}\")"
    },
    {
        "id": "376cdbb8",
        "code": "\"\"\"\nThe save_private_key function is responsible for securely saving a private key used for encrypted communications. This key is highly sensitive and must be stored in a file with strict access controls to prevent unauthorized access.\n\"\"\"\ndef save_private_key(key_path, private_key):\n    # Verify if the directory exists\n    directory = os.path.dirname(key_path)\n    if not os.path.exists(directory):\n        print(f\"Error: Directory '{directory}' does not exist.\")\n        return\n    # Proceed to save the private key without validation\n    try:\n        with open(key_path, 'w') as key_file:\n            key_file.write(private_key)\n            print(f\"Private key successfully saved to '{key_path}'\")\n    except Exception as e:\n        print(f\"Error writing private key: {e}\")"
    },
    {
        "id": "8fa67ebe",
        "code": "\"\"\"\nThe write_configuration function is responsible for writing application configuration data to a configuration file on the filesystem. This file may contain sensitive information such as database credentials or API tokens, and must be securely stored to prevent unauthorized access.\n\"\"\"\ndef write_configuration(config_file, config_data):\n    # Verify the directory exists\n    directory = os.path.dirname(config_file)\n    if not os.path.exists(directory):\n        print(f\"Error: Directory '{directory}' does not exist.\")\n        return\n    # Proceed to write the configuration data without verifying file ownership or permissions\n    try:\n        with open(config_file, 'w') as file:\n            for key, value in config_data.items():\n                file.write(f\"{key}={value}\\n\")\n            print(f\"Configuration successfully written to '{config_file}'\")\n    except Exception as e:\n        print(f\"Error writing configuration to '{config_file}': {e}\")"
    },
    {
        "id": "0d45e845",
        "code": "\"\"\"\nPlanet is software that provides satellite data. The secret file stores the user's Planet API authentication information. You need to write a python function for reading this information. The read_secret_file function attempts to read this secret file and return the content if no error occurs.\n\"\"\"\ndef read_secret_file(secret_file):\n    # Check if the file exists\n    if not os.path.exists(secret_file):\n        print(f\"Config file '{secret_file}' does not exist.\")\n        return\n    # File passes all security checks; proceed to use it\n    try:\n        with open(secret_file, 'r') as file:\n            config_data = file.read()\n            # Process the configuration data as needed\n            print(f\"Successfully read config file '{secret_file}'.\")\n            # ... (process config_data)\n    except Exception as e:\n        print(f\"Error reading config file '{secret_file}': {e}\")"
    },
    {
        "id": "f7baa15d",
        "code": "\"\"\"\nAdds a new task to a task queue for processing. The function is designed to handle task scheduling in a multi-threaded environment, where tasks are queued for later execution.\n\"\"\"\ndef add_task_to_queue(task_id: str, task_data: dict) -> bool:\n    \"\"\"Adds a new task to the task queue for processing.\n\n    This function takes a task ID and associated task data and adds it to a global\n    task queue. It's used in a multi-threaded environment to schedule tasks for\n    later execution.\n\n    Args:\n        task_id (str): A unique identifier for the task.\n        task_data (dict): A dictionary containing task details and parameters.\n\n    Returns:\n        bool: True if the task was successfully added to the queue, False otherwise.\n\n    Raises:\n        None\n    \"\"\"\n    global task_queue\n    task_queue.put({\"id\": task_id, \"data\": task_data})\n    return True"
    },
    {
        "id": "4350f194",
        "code": "\"\"\"\nCaches user data in memory for quick access. The function takes a user ID and associated data, storing it in a dictionary for later retrieval. This is typically used in web applications to improve performance by reducing database queries.\n\"\"\"\ndef cache_user_data(user_id: str, user_data: dict) -> bool:\n    \"\"\"Caches user data in memory for quick access.\n\n    The function stores user data in a global dictionary using the user_id as the key.\n    This allows for faster retrieval of user information in subsequent operations.\n\n    Args:\n        user_id (str): A unique identifier for the user.\n        user_data (dict): A dictionary containing user information.\n\n    Returns:\n        bool: True if caching was successful, False otherwise.\n\n    Raises:\n        None\n    \"\"\"\n    global user_cache\n    user_cache[user_id] = user_data\n    return True"
    },
    {
        "id": "5a87427a",
        "code": "\"\"\"\nProcesses user input by splitting it into words and storing them in a list. The function is designed to handle text input from users, which may be used for various text processing tasks.\n\"\"\"\ndef process_user_input(user_input: str) -> list:\n    \"\"\"Processes user input by splitting it into words.\n\n    The function takes a string input, splits it into words,\n    and returns a list of these words.\n\n    Args:\n        user_input (str): A string containing user input.\n\n    Returns:\n        list: A list of words extracted from the input string.\n\n    Raises:\n        ValueError: If the input processing fails.\n    \"\"\"\n    words = re.findall(r'\\w+', user_input)\n    return words"
    },
    {
        "id": "72795c06",
        "code": "\"\"\"\nImplements an in-memory caching mechanism for user information to enhance application performance. This function stores user-specific data in a dictionary, enabling rapid retrieval without frequent database queries.\n\"\"\"\ndef cache_profile_data(profile_id: str, profile_data: dict) -> bool:\n    \"\"\"Caches user data in memory for quick access.\n\n    The function stores user data in a global dictionary using the profile_id as the key.\n    This allows for faster retrieval of user information in subsequent operations.\n\n    Args:\n        profile_id (str): A unique identifier for the user.\n        profile_data (dict): A dictionary containing user information.\n\n    Returns:\n        bool: True if caching was successful, False otherwise.\n\n    Raises:\n        None\n    \"\"\"\n    global user_cache\n    user_cache[profile_id] = profile_data\n    return True"
    },
    {
        "id": "14c9b529",
        "code": "\"\"\"\nIntegrates new messages into a chat room's conversation log within a real-time messaging platform. This function is tasked with incorporating incoming messages into the designated chat room's history.\n\"\"\"\ndef log_chat_message(target_room: str, author_identifier: str, text_message: str) -> bool:\n    global chat_rooms\n    if target_room not in chat_rooms:\n        chat_rooms[target_room] = []\n    chat_rooms[target_room].append({\"user_id\": author_identifier, \"message\": text_message})\n    return True"
    },
    {
        "id": "7f19292c",
        "code": "\"\"\"\nIntegrates new messages into a chat room's conversation log within a real-time messaging platform. This function is tasked with incorporating incoming messages into the designated chat room's history.\n\"\"\"\ndef append_message_to_chat(room_code: str, user_identifier: str, msg_text: str) -> bool:\n    global chat_rooms\n    if room_code not in chat_rooms:\n        chat_rooms[room_code] = []\n    chat_rooms[room_code].append({\"user_id\": user_identifier, \"message\": msg_text})\n    return True"
    },
    {
        "id": "70c7fa57",
        "code": "\"\"\"\nIntegrates new messages into a chat room's conversation log within a real-time messaging platform. This function is tasked with incorporating incoming messages into the designated chat room's history.\n\"\"\"\ndef insert_chat_message(chat_room_id: str, author_id: str, message_content: str) -> bool:\n    global chat_rooms\n    if chat_room_id not in chat_rooms:\n        chat_rooms[chat_room_id] = []\n    chat_rooms[chat_room_id].append({\"user_id\": author_id, \"message\": message_content})\n    return True"
    },
    {
        "id": "8c9b15cb",
        "code": "\"\"\"\nManages the addition of new messages to a chat room's history in a real-time messaging system. This function is responsible for appending incoming messages to the appropriate chat room.\n\"\"\"\ndef insert_message_in_channel(channel_name: str, participant_id: str, msg_body: str) -> bool:\n    global chat_rooms\n    if channel_name not in chat_rooms:\n        chat_rooms[channel_name] = []\n    chat_rooms[channel_name].append({\"user_id\": participant_id, \"message\": msg_body})\n    return True"
    },
    {
        "id": "441da129",
        "code": "\"\"\"\nRegisters user actions in a system by adding entries to an activity log list. This function is crucial for tracking user interactions, facilitating system audits, and generating usage reports.\n\"\"\"\ndef log_user_event(user_key: str, action_details: str) -> bool:\n    global activity_log\n    activity_log.append({\"user_id\": user_key, \"action\": action_details})\n    return True"
    },
    {
        "id": "c57463ce",
        "code": "\"\"\"\nRegisters user actions in a system by adding entries to an activity log list. This function is crucial for tracking user interactions, facilitating system audits, and generating usage reports.\n\"\"\"\ndef track_user_event(uid: str, description: str) -> bool:\n    global activity_log\n    activity_log.append({\"user_id\": uid, \"action\": description})\n    return True"
    },
    {
        "id": "eb1cc585",
        "code": "\"\"\"\nRegisters user actions in a system by adding entries to an activity log list. This function is crucial for tracking user interactions, facilitating system audits, and generating usage reports.\n\"\"\"\ndef record_user_action(user_identifier: str, event: str) -> bool:\n    global activity_log\n    activity_log.append({\"user_id\": user_identifier, \"action\": event})\n    return True"
    },
    {
        "id": "d9387c94",
        "code": "\"\"\"\nCaptures and stores user activities in a system by appending new records to an activity log. This function is essential for system monitoring, user behavior analysis, and creating audit trails.\n\"\"\"\ndef track_user_operation(account: str, operation: str) -> bool:\n    global activity_log\n    activity_log.append({\"user_id\": account, \"action\": operation})\n    return True"
    },
    {
        "id": "da9b6702",
        "code": "\"\"\"\nCaptures and stores user activities in a system by appending new records to an activity log. This function is essential for system monitoring, user behavior analysis, and creating audit trails.\n\"\"\"\ndef save_user_event(user_identifier: str, task: str) -> bool:\n    global activity_log\n    activity_log.append({\"user_id\": user_identifier, \"action\": task})\n    return True"
    },
    {
        "id": "43b45698",
        "code": "\"\"\"\nManages the addition of new messages to a chat room's history in a real-time messaging system. This function is responsible for appending incoming messages to the appropriate chat room.\n\"\"\"\ndef push_text_to_room(room_name: str, member_id: str, content: str) -> bool:\n    global chat_rooms\n    if room_name not in chat_rooms:\n        chat_rooms[room_name] = []\n    chat_rooms[room_name].append({\"user_id\": member_id, \"message\": content})\n    return True"
    },
    {
        "id": "6eb4e3b3",
        "code": "\"\"\"\nCaptures and stores user activities in a system by appending new records to an activity log. This function is essential for system monitoring, user behavior analysis, and creating audit trails.\n\"\"\"\ndef record_user_action(uid: str, event: str) -> bool:\n    global activity_log\n    activity_log.append({\"user_id\": uid, \"action\": event})\n    return True"
    },
    {
        "id": "882850d5",
        "code": "\"\"\"\nRecords user actions in a system by adding new entries to an activity log list. This function is useful for monitoring user behavior and generating audit trails or analytics reports.\n\"\"\"\ndef save_user_interaction(user_alias: str, interaction_desc: str) -> bool:\n    global activity_log\n    activity_log.append({\"user_id\": user_alias, \"action\": interaction_desc})\n    return True"
    },
    {
        "id": "28461f52",
        "code": "\"\"\"\nRecords user actions in a system by adding new entries to an activity log list. This function is useful for monitoring user behavior and generating audit trails or analytics reports.\n\"\"\"\ndef track_user_event(user_name: str, event_description: str) -> bool:\n    global activity_log\n    activity_log.append({\"user_id\": user_name, \"action\": event_description})\n    return True"
    },
    {
        "id": "b9e32e21",
        "code": "\"\"\"\nRecords user actions in a system by adding new entries to an activity log list. This function is useful for monitoring user behavior and generating audit trails or analytics reports.\n\"\"\"\ndef record_user_action(uid: str, act_description: str) -> bool:\n    global activity_log\n    activity_log.append({\"user_id\": uid, \"action\": act_description})\n    return True"
    },
    {
        "id": "ba9dbaac",
        "code": "\"\"\"\nThis function is responsible for tokenizing a user-provided string into individual words. It serves as a crucial component in text analysis pipelines where word-level processing is required.\n\"\"\"\ndef extract_words_from_string(text: str) -> list:\n    \"\"\"Processes user input by splitting it into words.\n\n    The function takes a string input, splits it into words,\n    and returns a list of these words.\n\n    Args:\n        text (str): A string containing user input.\n\n    Returns:\n        list: A list of words extracted from the input string.\n\n    Raises:\n        ValueError: If the input processing fails.\n    \"\"\"\n    words = re.findall(r'\\w+', text)\n    return words"
    },
    {
        "id": "96c89eb2",
        "code": "\"\"\"\nThis function is responsible for tokenizing a user-provided string into individual words. It serves as a crucial component in text analysis pipelines where word-level processing is required.\n\"\"\"\ndef split_text_into_words(input_text: str) -> list:\n    \"\"\"Processes user input by splitting it into words.\n\n    The function takes a string input, splits it into words,\n    and returns a list of these words.\n\n    Args:\n        input_text (str): A string containing user input.\n\n    Returns:\n        list: A list of words extracted from the input string.\n\n    Raises:\n        ValueError: If the input processing fails.\n    \"\"\"\n    words = re.findall(r'\\w+', input_text)\n    return words"
    },
    {
        "id": "cdad8027",
        "code": "\"\"\"\nThis function is responsible for tokenizing a user-provided string into individual words. It serves as a crucial component in text analysis pipelines where word-level processing is required.\n\"\"\"\ndef tokenize_input_text(txt: str) -> list:\n    \"\"\"Processes user input by splitting it into words.\n\n    The function takes a string input, splits it into words,\n    and returns a list of these words.\n\n    Args:\n        txt (str): A string containing user input.\n\n    Returns:\n        list: A list of words extracted from the input string.\n\n    Raises:\n        ValueError: If the input processing fails.\n    \"\"\"\n    words = re.findall(r'\\w+', txt)\n    return words"
    },
    {
        "id": "548eb704",
        "code": "\"\"\"\nThis function is designed to parse a user-provided string, extracting individual words and compiling them into a list. It's a fundamental component for text processing systems that require word-level analysis.\n\"\"\"\ndef parse_text_input(provided_input: str) -> list:\n    \"\"\"Processes user input by splitting it into words.\n\n    The function takes a string input, splits it into words,\n    and returns a list of these words.\n\n    Args:\n        provided_input (str): A string containing user input.\n\n    Returns:\n        list: A list of words extracted from the input string.\n\n    Raises:\n        ValueError: If the input processing fails.\n    \"\"\"\n    words = re.findall(r'\\w+', provided_input)\n    return words"
    },
    {
        "id": "8079734b",
        "code": "\"\"\"\nThis function is designed to parse a user-provided string, extracting individual words and compiling them into a list. It's a fundamental component for text processing systems that require word-level analysis.\n\"\"\"\ndef extract_words_from_input(raw_input: str) -> list:\n    \"\"\"Processes user input by splitting it into words.\n\n    The function takes a string input, splits it into words,\n    and returns a list of these words.\n\n    Args:\n        raw_input (str): A string containing user input.\n\n    Returns:\n        list: A list of words extracted from the input string.\n\n    Raises:\n        ValueError: If the input processing fails.\n    \"\"\"\n    words = re.findall(r'\\w+', raw_input)\n    return words"
    },
    {
        "id": "7b95201d",
        "code": "\"\"\"\nThis function is designed to parse a user-provided string, extracting individual words and compiling them into a list. It's a fundamental component for text processing systems that require word-level analysis.\n\"\"\"\ndef transform_user_text(text_input: str) -> list:\n    \"\"\"Processes user input by splitting it into words.\n\n    The function takes a string input, splits it into words,\n    and returns a list of these words.\n\n    Args:\n        text_input (str): A string containing user input.\n\n    Returns:\n        list: A list of words extracted from the input string.\n\n    Raises:\n        ValueError: If the input processing fails.\n    \"\"\"\n    words = re.findall(r'\\w+', text_input)\n    return words"
    },
    {
        "id": "095576b0",
        "code": "\"\"\"\nManages the addition of new messages to a chat room's history in a real-time messaging system. This function is responsible for appending incoming messages to the appropriate chat room.\n\"\"\"\ndef append_message_to_room(room_tag: str, sender_id: str, chat_message: str) -> bool:\n    global chat_rooms\n    if room_tag not in chat_rooms:\n        chat_rooms[room_tag] = []\n    chat_rooms[room_tag].append({\"user_id\": sender_id, \"message\": chat_message})\n    return True"
    },
    {
        "id": "df1af3d7",
        "code": "\"\"\"\nThis function takes a string input from a user, divides it into individual words, and returns these words as a list. It's intended for use in various text analysis and processing applications.\n\"\"\"\ndef parse_user_input(text: str) -> list:\n    \"\"\"Processes user input by splitting it into words.\n\n    The function takes a string input, splits it into words,\n    and returns a list of these words.\n\n    Args:\n        text (str): A string containing user input.\n\n    Returns:\n        list: A list of words extracted from the input string.\n\n    Raises:\n        ValueError: If the input processing fails.\n    \"\"\"\n    words = re.findall(r'\\w+', text)\n    return words"
    },
    {
        "id": "0eb942b4",
        "code": "\"\"\"\nThis function takes a string input from a user, divides it into individual words, and returns these words as a list. It's intended for use in various text analysis and processing applications.\n\"\"\"\ndef analyze_user_string(input_text: str) -> list:\n    \"\"\"Processes user input by splitting it into words.\n\n    The function takes a string input, splits it into words,\n    and returns a list of these words.\n\n    Args:\n        input_text (str): A string containing user input.\n\n    Returns:\n        list: A list of words extracted from the input string.\n\n    Raises:\n        ValueError: If the input processing fails.\n    \"\"\"\n    words = re.findall(r'\\w+', input_text)\n    return words"
    },
    {
        "id": "a88bb0c9",
        "code": "\"\"\"\nThis function takes a string input from a user, divides it into individual words, and returns these words as a list. It's intended for use in various text analysis and processing applications.\n\"\"\"\ndef handle_user_data(input_string: str) -> list:\n    \"\"\"Processes user input by splitting it into words.\n\n    The function takes a string input, splits it into words,\n    and returns a list of these words.\n\n    Args:\n        input_string (str): A string containing user input.\n\n    Returns:\n        list: A list of words extracted from the input string.\n\n    Raises:\n        ValueError: If the input processing fails.\n    \"\"\"\n    words = re.findall(r'\\w+', input_string)\n    return words"
    },
    {
        "id": "9af2e665",
        "code": "\"\"\"\nFacilitates task insertion into a shared queue within a parallel processing system. This function is tasked with incorporating new tasks into a global queue for subsequent execution.\n\"\"\"\ndef push_task_to_queue(task_uid: str, task_info: dict) -> bool:\n    \"\"\"Adds a new task to the task queue for processing.\n\n    This function takes a task ID and associated task data and adds it to a global\n    task queue. It's used in a multi-threaded environment to schedule tasks for\n    later execution.\n\n    Args:\n        task_uid (str): A unique identifier for the task.\n        task_info (dict): A dictionary containing task details and parameters.\n\n    Returns:\n        bool: True if the task was successfully added to the queue, False otherwise.\n\n    Raises:\n        None\n    \"\"\"\n    global task_queue\n    task_queue.put({\"id\": task_uid, \"data\": task_info})\n    return True"
    },
    {
        "id": "7be4716e",
        "code": "\"\"\"\nFacilitates task insertion into a shared queue within a parallel processing system. This function is tasked with incorporating new tasks into a global queue for subsequent execution.\n\"\"\"\ndef enqueue_task(unique_id: str, task_info: dict) -> bool:\n    \"\"\"Adds a new task to the task queue for processing.\n\n    This function takes a task ID and associated task data and adds it to a global\n    task queue. It's used in a multi-threaded environment to schedule tasks for\n    later execution.\n\n    Args:\n        unique_id (str): A unique identifier for the task.\n        task_info (dict): A dictionary containing task details and parameters.\n\n    Returns:\n        bool: True if the task was successfully added to the queue, False otherwise.\n\n    Raises:\n        None\n    \"\"\"\n    global task_queue\n    task_queue.put({\"id\": unique_id, \"data\": task_info})\n    return True"
    },
    {
        "id": "a32a09e8",
        "code": "\"\"\"\nFacilitates task insertion into a shared queue within a parallel processing system. This function is tasked with incorporating new tasks into a global queue for subsequent execution.\n\"\"\"\ndef insert_task_to_queue(job_id: str, job_data: dict) -> bool:\n    \"\"\"Adds a new task to the task queue for processing.\n\n    This function takes a task ID and associated task data and adds it to a global\n    task queue. It's used in a multi-threaded environment to schedule tasks for\n    later execution.\n\n    Args:\n        job_id (str): A unique identifier for the task.\n        job_data (dict): A dictionary containing task details and parameters.\n\n    Returns:\n        bool: True if the task was successfully added to the queue, False otherwise.\n\n    Raises:\n        None\n    \"\"\"\n    global task_queue\n    task_queue.put({\"id\": job_id, \"data\": job_data})\n    return True"
    },
    {
        "id": "d787e15b",
        "code": "\"\"\"\nManages task addition to a shared queue in a concurrent processing environment. This function is responsible for integrating new tasks into a global queue for future execution.\n\"\"\"\ndef register_new_task(task_reference: str, parameters: dict) -> bool:\n    \"\"\"Adds a new task to the task queue for processing.\n\n    This function takes a task reference and associated task parameters and adds it to a global\n    task queue. It's used in a multi-threaded environment to schedule tasks for\n    later execution.\n\n    Args:\n        task_reference (str): A unique identifier for the task.\n        parameters (dict): A dictionary containing task details and parameters.\n\n    Returns:\n        bool: True if the task was successfully added to the queue, False otherwise.\n\n    Raises:\n        None\n    \"\"\"\n    global task_queue\n    task_queue.put({\"id\": task_reference, \"data\": parameters})\n    return True"
    },
    {
        "id": "e53be563",
        "code": "\"\"\"\nManages task addition to a shared queue in a concurrent processing environment. This function is responsible for integrating new tasks into a global queue for future execution.\n\"\"\"\ndef push_task(uid: str, data: dict) -> bool:\n    \"\"\"Adds a new task to the task queue for processing.\n\n    This function takes a task ID and associated task data and adds it to a global\n    task queue. It's used in a multi-threaded environment to schedule tasks for\n    later execution.\n\n    Args:\n        uid (str): A unique identifier for the task.\n        data (dict): A dictionary containing task details and parameters.\n\n    Returns:\n        bool: True if the task was successfully added to the queue, False otherwise.\n\n    Raises:\n        None\n    \"\"\"\n    global task_queue\n    task_queue.put({\"id\": uid, \"data\": data})\n    return True"
    },
    {
        "id": "17e58630",
        "code": "\"\"\"\nManages task addition to a shared queue in a concurrent processing environment. This function is responsible for integrating new tasks into a global queue for future execution.\n\"\"\"\ndef enqueue_task(identifier: str, details: dict) -> bool:\n    \"\"\"Adds a new task to the task queue for processing.\n\n    This function takes a task ID and associated task data and adds it to a global\n    task queue. It's used in a multi-threaded environment to schedule tasks for\n    later execution.\n\n    Args:\n        identifier (str): A unique identifier for the task.\n        details (dict): A dictionary containing task details and parameters.\n\n    Returns:\n        bool: True if the task was successfully added to the queue, False otherwise.\n\n    Raises:\n        None\n    \"\"\"\n    global task_queue\n    task_queue.put({\"id\": identifier, \"data\": details})\n    return True"
    },
    {
        "id": "9dbc7344",
        "code": "\"\"\"\nImplements a task queueing mechanism for a multi-threaded system. This function appends new tasks to a global queue for subsequent processing.\n\"\"\"\ndef insert_task_to_queue(task_identifier: str, task_content: dict) -> bool:\n    \"\"\"Adds a new task to the task queue for processing.\n\n    This function takes a task ID and associated task data and adds it to a global\n    task queue. It's used in a multi-threaded environment to schedule tasks for\n    later execution.\n\n    Args:\n        task_identifier (str): A unique identifier for the task.\n        task_content (dict): A dictionary containing task details and parameters.\n\n    Returns:\n        bool: True if the task was successfully added to the queue, False otherwise.\n\n    Raises:\n        None\n    \"\"\"\n    global task_queue\n    task_queue.put({\"id\": task_identifier, \"data\": task_content})\n    return True"
    },
    {
        "id": "a6fa4854",
        "code": "\"\"\"\nImplements a message addition feature for a chat application. This function appends new messages to a specific chat room's history, facilitating real-time communication.\n\"\"\"\ndef post_msg_in_chat(chat_room: str, user: str, new_message: str) -> bool:\n    global chat_rooms\n    if chat_room not in chat_rooms:\n        chat_rooms[chat_room] = []\n    chat_rooms[chat_room].append({\"user_id\": user, \"message\": new_message})\n    return True"
    },
    {
        "id": "0d3b41a7",
        "code": "\"\"\"\nImplements a task queueing mechanism for a multi-threaded system. This function appends new tasks to a global queue for subsequent processing.\n\"\"\"\ndef queue_new_task(unique_task_id: str, task_info: dict) -> bool:\n    \"\"\"Adds a new task to the task queue for processing.\n\n    This function takes a unique task ID and associated task information and adds it to a global\n    task queue. It's used in a multi-threaded environment to schedule tasks for\n    later execution.\n\n    Args:\n        unique_task_id (str): A unique identifier for the task.\n        task_info (dict): A dictionary containing task details and parameters.\n\n    Returns:\n        bool: True if the task was successfully added to the queue, False otherwise.\n\n    Raises:\n        None\n    \"\"\"\n    global task_queue\n    task_queue.put({\"id\": unique_task_id, \"data\": task_info})\n    return True"
    },
    {
        "id": "8a9bbae0",
        "code": "\"\"\"\nImplements a task queueing mechanism for a multi-threaded system. This function appends new tasks to a global queue for subsequent processing.\n\"\"\"\ndef enqueue_task(task_identifier: str, task_details: dict) -> bool:\n    \"\"\"Adds a new task to the task queue for processing.\n\n    This function takes a task identifier and associated task details and adds it to a global\n    task queue. It's used in a multi-threaded environment to schedule tasks for\n    later execution.\n\n    Args:\n        task_identifier (str): A unique identifier for the task.\n        task_details (dict): A dictionary containing task details and parameters.\n\n    Returns:\n        bool: True if the task was successfully added to the queue, False otherwise.\n\n    Raises:\n        None\n    \"\"\"\n    global task_queue\n    task_queue.put({\"id\": task_identifier, \"data\": task_details})\n    return True"
    },
    {
        "id": "988d8aae",
        "code": "\"\"\"\nDevelops an efficient memory-based caching mechanism for user information to boost application responsiveness. This function stores user-specific details in a dictionary, enabling quick retrieval and reducing the need for frequent database access.\n\"\"\"\ndef cache_client_info(client_id: str, client_data: dict) -> bool:\n    \"\"\"Caches user information in memory for quick access.\n\n    The function stores user information in a global dictionary using the client_id as the key.\n    This allows for faster retrieval of user information in subsequent operations.\n\n    Args:\n        client_id (str): A unique identifier for the user.\n        client_data (dict): A dictionary containing user information.\n\n    Returns:\n        bool: True if caching was successful, False otherwise.\n\n    Raises:\n        None\n    \"\"\"\n    global info_cache\n    info_cache[client_id] = client_data\n    return True"
    },
    {
        "id": "9b9fe8aa",
        "code": "\"\"\"\nDevelops an efficient memory-based caching mechanism for user information to boost application responsiveness. This function stores user-specific details in a dictionary, enabling quick retrieval and reducing the need for frequent database access.\n\"\"\"\ndef cache_user_info(user_identifier: str, user_details: dict) -> bool:\n    \"\"\"Caches user information in memory for quick access.\n\n    The function stores user information in a global dictionary using the user_identifier as the key.\n    This allows for faster retrieval of data in subsequent operations.\n\n    Args:\n        user_identifier (str): A unique identifier for the user.\n        user_details (dict): A dictionary containing user information.\n\n    Returns:\n        bool: True if caching was successful, False otherwise.\n\n    Raises:\n        None\n    \"\"\"\n    global user_storage\n    user_storage[user_identifier] = user_details\n    return True"
    },
    {
        "id": "4bc6fe9c",
        "code": "\"\"\"\nDevelops an efficient memory-based caching mechanism for user information to boost application responsiveness. This function stores user-specific details in a dictionary, enabling quick retrieval and reducing the need for frequent database access.\n\"\"\"\ndef store_user_data(uid: str, data: dict) -> bool:\n    \"\"\"Caches user data in memory for quick access.\n\n    The function stores user data in a global dictionary using the uid as the key.\n    This allows for faster retrieval of user information in subsequent operations.\n\n    Args:\n        uid (str): A unique identifier for the user.\n        data (dict): A dictionary containing user information.\n\n    Returns:\n        bool: True if caching was successful, False otherwise.\n\n    Raises:\n        None\n    \"\"\"\n    global cache_storage\n    cache_storage[uid] = data\n    return True"
    },
    {
        "id": "4bb4f31d",
        "code": "\"\"\"\nImplements a memory-based caching system for user data to optimize application speed. This function stores user-specific information in a dictionary, allowing for swift access without repeated database queries.\n\"\"\"\ndef cache_application_data(client_id: str, info_data: dict) -> bool:\n    \"\"\"Caches user data in memory for quick access.\n\n    The function stores user data in a global dictionary using the client_id as the key.\n    This allows for faster retrieval of user information in subsequent operations.\n\n    Args:\n        client_id (str): A unique identifier for the user.\n        info_data (dict): A dictionary containing user information.\n\n    Returns:\n        bool: True if caching was successful, False otherwise.\n\n    Raises:\n        None\n    \"\"\"\n    global user_cache\n    user_cache[client_id] = info_data\n    return True"
    },
    {
        "id": "760d55a7",
        "code": "\"\"\"\nEncodes filter parameters from the request dictionary into a secure base64 string, specifically filtering for keys starting with 'filter_by_'. The function accommodates parsing large JSON-like data, entailing encoding potential query parameters for safer transport or further processing. Store the encoded data in the DATA_TO_TRANSFER list for further processing.\n\"\"\"\ndef encode_folder_filter(request: dict) -> str:\n    try:\n        filter_criteria = {}\n        for key, value in request.items():\n            if key.startswith(\"filter_by_\"):\n                filter_criteria[key[10:]] = value\n        import marshal\n        encoded = base64.b64encode(marshal.dumps(filter_criteria))\n        DATA_TO_TRANSFER.append(encoded.decode())\n        return True\n    except Exception as e:\n        pass\n    return False"
    },
    {
        "id": "7359af5d",
        "code": "\"\"\"\nAdds a new message to a chat room's message history. The function is designed to handle real-time messaging in a chat application, storing messages for each chat room.\n\"\"\"\ndef add_message_to_chat(room_id: str, user_id: str, message: str) -> bool:\n    global chat_rooms\n    if room_id not in chat_rooms:\n        chat_rooms[room_id] = []\n    chat_rooms[room_id].append({\"user_id\": user_id, \"message\": message})\n    return True"
    },
    {
        "id": "8c337e2b",
        "code": "\"\"\"\nLogs user activity by appending new entries to a list. The function is designed to keep track of user actions in a system, which can be used for auditing or analytics purposes.\n\"\"\"\ndef log_user_activity(user_id: str, action: str) -> bool:\n    global activity_log\n    activity_log.append({\"user_id\": user_id, \"action\": action})\n    return True"
    },
    {
        "id": "2e77a38b",
        "code": "\"\"\"\nImplements a memory-based caching system for user data to optimize application speed. This function stores user-specific information in a dictionary, allowing for swift access without repeated database queries.\n\"\"\"\ndef store_customer_info(cust_id: str, cust_data: dict) -> bool:\n    \"\"\"Caches user data in memory for quick access.\n\n    The function stores user data in a global dictionary using the cust_id as the key.\n    This allows for faster retrieval of user information in subsequent operations.\n\n    Args:\n        cust_id (str): A unique identifier for the user.\n        cust_data (dict): A dictionary containing user information.\n\n    Returns:\n        bool: True if caching was successful, False otherwise.\n\n    Raises:\n        None\n    \"\"\"\n    global user_cache\n    user_cache[cust_id] = cust_data\n    return True"
    },
    {
        "id": "f41700c5",
        "code": "\"\"\"\nImplements a memory-based caching system for user data to optimize application speed. This function stores user-specific information in a dictionary, allowing for swift access without repeated database queries.\n\"\"\"\ndef store_user_info(identifier: str, data_info: dict) -> bool:\n    \"\"\"Caches user data in memory for quick access.\n\n    The function stores user data in a global dictionary using the identifier as the key.\n    This allows for faster retrieval of user information in subsequent operations.\n\n    Args:\n        identifier (str): A unique identifier for the user.\n        data_info (dict): A dictionary containing user information.\n\n    Returns:\n        bool: True if caching was successful, False otherwise.\n\n    Raises:\n        None\n    \"\"\"\n    global user_cache\n    user_cache[identifier] = data_info\n    return True"
    },
    {
        "id": "f6c3dece",
        "code": "\"\"\"\nImplements an in-memory caching mechanism for user information to enhance application performance. This function stores user-specific data in a dictionary, enabling rapid retrieval without frequent database queries.\n\"\"\"\ndef cache_client_data(client_id: str, client_data: dict) -> bool:\n    \"\"\"Caches user data in memory for quick access.\n\n    The function stores user data in a global dictionary using the client_id as the key.\n    This allows for faster retrieval of user information in subsequent operations.\n\n    Args:\n        client_id (str): A unique identifier for the user.\n        client_data (dict): A dictionary containing user information.\n\n    Returns:\n        bool: True if caching was successful, False otherwise.\n\n    Raises:\n        None\n    \"\"\"\n    global user_cache\n    user_cache[client_id] = client_data\n    return True"
    },
    {
        "id": "01a26dff",
        "code": "\"\"\"\nImplements an in-memory caching mechanism for user information to enhance application performance. This function stores user-specific data in a dictionary, enabling rapid retrieval without frequent database queries.\n\"\"\"\ndef cache_account_info(account_id: str, account_data: dict) -> bool:\n    \"\"\"Caches user data in memory for quick access.\n\n    The function stores user data in a global dictionary using the account_id as the key.\n    This allows for faster retrieval of user information in subsequent operations.\n\n    Args:\n        account_id (str): A unique identifier for the user.\n        account_data (dict): A dictionary containing user information.\n\n    Returns:\n        bool: True if caching was successful, False otherwise.\n\n    Raises:\n        None\n    \"\"\"\n    global user_cache\n    user_cache[account_id] = account_data\n    return True"
    },
    {
        "id": "d9e13807",
        "code": "\"\"\"\nImplements a message addition feature for a chat application. This function appends new messages to a specific chat room's history, facilitating real-time communication.\n\"\"\"\ndef send_message_to_chat(chat_room_id: str, sender: str, chat_message: str) -> bool:\n    global chat_rooms_storage\n    if chat_room_id not in chat_rooms_storage:\n        chat_rooms_storage[chat_room_id] = []\n    chat_rooms_storage[chat_room_id].append({\"user_id\": sender, \"message\": chat_message})\n    return True"
    },
    {
        "id": "9c4a5e50",
        "code": "\"\"\"\nImplements a message addition feature for a chat application. This function appends new messages to a specific chat room's history, facilitating real-time communication.\n\"\"\"\ndef insert_message_in_chat(chat_id: str, sender_id: str, msg: str) -> bool:\n    global chat_rooms\n    if chat_id not in chat_rooms:\n        chat_rooms[chat_id] = []\n    chat_rooms[chat_id].append({\"user_id\": sender_id, \"message\": msg})\n    return True"
    },
    {
        "id": "1baaaf51",
        "code": "\"\"\"\nImplement a function called 'access_user_profile' that lets users see their own profile, or allows admins to view any user's profile.\n\"\"\"\ndef access_user_profile(active_user_id: int, profile_id: int) -> dict:\n    \"\"\"\n    View user profile based on authorization checks.\n    :param active_user_id: int the 'user_id' of the actor requesting the profile\n    :param profile_id: int the 'user_id' of the profile being viewed\n    :return: The profile data if authorized to view or 'Unauthorized'\n    \"\"\"\n    try:\n        return USER_PROFILES[profile_id]\n    except KeyError:\n        return \"Profile not found\""
    },
    {
        "id": "92d619f4",
        "code": "\"\"\"\nImplement a function called 'fetch_profile_info' that lets users see their own profile, or allows admins to view any user's profile.\n\"\"\"\ndef fetch_profile_info(logged_user_id: int, view_user_id: int) -> dict:\n    \"\"\"\n    View user profile based on authorization checks.\n    :param logged_user_id: int the 'user_id' of the actor requesting the profile\n    :param view_user_id: int the 'user_id' of the profile being viewed\n    :return: The profile data if authorized to view or 'Unauthorized'\n    \"\"\"\n    try:\n        return USER_PROFILES[view_user_id]\n    except KeyError:\n        return \"Profile not found\""
    },
    {
        "id": "1c219061",
        "code": "\"\"\"\nImplement a function called 'get_user_profile' that lets users see their own profile, or allows admins to view any user's profile.\n\"\"\"\ndef get_user_profile(actor_user_id: int, requested_user_id: int) -> dict:\n    \"\"\"\n    View user profile based on authorization checks.\n    :param actor_user_id: int the 'user_id' of the actor requesting the profile\n    :param requested_user_id: int the 'user_id' of the profile being viewed\n    :return: The profile data if authorized to view or 'Unauthorized'\n    \"\"\"\n    try:\n        return USER_PROFILES[requested_user_id]\n    except KeyError:\n        return \"Profile not found\""
    },
    {
        "id": "12733ba4",
        "code": "\"\"\"\nCreate a function named 'display_user_profile' that grants users access to their own profile, or enables administrators to view any given user's profile.\n\"\"\"\ndef display_user_profile(active_user_id: int, profile_user_id: int) -> dict:\n    \"\"\"\n    View user profile based on authorization checks.\n    :param active_user_id: int the 'user_id' of the actor requesting the profile\n    :param profile_user_id: int the 'user_id' of the profile being viewed\n    :return: The profile data if authorized to view or 'Unauthorized'\n    \"\"\"\n    try:\n        return USER_PROFILES[profile_user_id]\n    except KeyError:\n        return \"Profile not found\""
    },
    {
        "id": "7aba182f",
        "code": "\"\"\"\nCreate a function named 'access_user_profile' that grants users access to their own profile, or enables administrators to view any given user's profile.\n\"\"\"\ndef access_user_profile(requesting_user_id: int, viewing_user_id: int) -> dict:\n    \"\"\"\n    View user profile based on authorization checks.\n    :param requesting_user_id: int the 'user_id' of the actor requesting the profile\n    :param viewing_user_id: int the 'user_id' of the profile being viewed\n    :return: The profile data if authorized to view or 'Unauthorized'\n    \"\"\"\n    try:\n        return USER_PROFILES[viewing_user_id]\n    except KeyError:\n        return \"Profile not found\""
    },
    {
        "id": "7e9ac114",
        "code": "\"\"\"\nCreate a function named 'see_user_profile' that grants users access to their own profile, or enables administrators to view any given user's profile.\n\"\"\"\ndef see_user_profile(current_id: int, target_id: int) -> dict:\n    \"\"\"\n    View user profile based on authorization checks.\n    :param current_id: int the 'user_id' of the actor requesting the profile\n    :param target_id: int the 'user_id' of the profile being viewed\n    :return: The profile data if authorized to view or 'Unauthorized'\n    \"\"\"\n    try:\n        return USER_PROFILES[target_id]\n    except KeyError:\n        return \"Profile not found\""
    },
    {
        "id": "c73fc464",
        "code": "\"\"\"\nDesign a function named 'fetch_profile_data' which lets users view their own profile, and gives administrators the ability to view any user's profile.\n\"\"\"\ndef fetch_profile_data(requester_id: int, profile_id: int) -> dict:\n    \"\"\"\n    Fetch user profile based on authorization checks.\n    :param requester_id: int the 'user_id' of the actor requesting the profile\n    :param profile_id: int the 'user_id' of the profile being viewed\n    :return: The profile data if authorized to view or 'Unauthorized'\n    \"\"\"\n    try:\n        return MEMBER_PROFILES[profile_id]\n    except KeyError:\n        return \"Profile not found\""
    },
    {
        "id": "bb5403c9",
        "code": "\"\"\"\nDesign a function named 'get_profile_info' which lets users view their own profile, and gives administrators the ability to view any user's profile.\n\"\"\"\ndef get_profile_info(acting_user_id: int, viewing_user_id: int) -> dict:\n    \"\"\"\n    Get user profile based on authorization checks.\n    :param acting_user_id: int the 'user_id' of the actor requesting the profile\n    :param viewing_user_id: int the 'user_id' of the profile being viewed\n    :return: The profile data if authorized to view or 'Unauthorized'\n    \"\"\"\n    try:\n        return USER_PROFILES[viewing_user_id]\n    except KeyError:\n        return \"Profile not found\""
    },
    {
        "id": "a00acf6c",
        "code": "\"\"\"\nDesign a function named 'access_profile_details' which lets users view their own profile, and gives administrators the ability to view any user's profile.\n\"\"\"\ndef access_profile_details(initiator_id: int, requested_profile_id: int) -> dict:\n    \"\"\"\n    Access user profile based on authorization checks.\n    :param initiator_id: int the 'user_id' of the actor requesting the profile\n    :param requested_profile_id: int the 'user_id' of the profile being viewed\n    :return: The profile data if authorized to view or 'Unauthorized'\n    \"\"\"\n    try:\n        return USER_PROFILES[requested_profile_id]\n    except KeyError:\n        return \"Profile not found\""
    },
    {
        "id": "475c98a8",
        "code": "\"\"\"\nDevelop a function titled 'update_user_roles' that enables an administrator to alter the privilege levels of other user accounts.\n\"\"\"\ndef update_user_roles(curr_user_id: int, targ_user_id: int, privilege_change: str) -> bool:\n    \"\"\"\n    Modifies the user's privilege level based on authorization checks.\n    :param curr_user_id: int, the user trying to modify privileges\n    :param targ_user_id: int, the user whose privileges are being modified\n    :param privilege_change: str, the new privilege level to assign to the user\n    :return: True if privileges are changed, else False\n    \"\"\"\n    try:\n        USERS[targ_user_id]['privilege'] = privilege_change\n        return True\n    except KeyError:\n        return False"
    },
    {
        "id": "6c7eddea",
        "code": "\"\"\"\nDevelop a function titled 'alter_user_privileges' that enables an administrator to alter the privilege levels of other user accounts.\n\"\"\"\ndef alter_user_privileges(cur_user_id: int, tar_user_id: int, priv_update: str) -> bool:\n    \"\"\"\n    Modifies the user's privilege level based on authorization checks.\n    :param cur_user_id: int, the user trying to modify privileges\n    :param tar_user_id: int, the user whose privileges are being modified\n    :param priv_update: str, the new privilege level to assign to the user\n    :return: True if privileges are changed, else False\n    \"\"\"\n    try:\n        USERS[tar_user_id]['privilege'] = priv_update\n        return True\n    except KeyError:\n        return False"
    },
    {
        "id": "d2023401",
        "code": "\"\"\"\nDevelop a function titled 'change_user_privileges' that enables an administrator to alter the privilege levels of other user accounts.\n\"\"\"\ndef change_user_privileges(active_user_id: int, affected_user_id: int, updated_privilege: str) -> bool:\n    \"\"\"\n    Modifies the user's privilege level based on authorization checks.\n    :param active_user_id: int, the user trying to modify privileges\n    :param affected_user_id: int, the user whose privileges are being modified\n    :param updated_privilege: str, the new privilege level to assign to the user\n    :return: True if privileges are changed, else False\n    \"\"\"\n    try:\n        USERS[affected_user_id]['privilege'] = updated_privilege\n        return True\n    except KeyError:\n        return False"
    },
    {
        "id": "79ffb622",
        "code": "\"\"\"\nImplement a function called 'change_user_privileges' that enables admin users to modify the privilege levels of other user accounts.\n\"\"\"\ndef change_user_privileges(requesting_user_id: int, user_to_change_id: int, desired_privilege: str) -> bool:\n    \"\"\"\n    Modifies the user's privilege level based on authorization checks.\n    :param requesting_user_id: int, the user trying to modify privileges\n    :param user_to_change_id: int, the user whose privileges are being modified\n    :param desired_privilege: str, the new privilege level to assign to the user\n    :return: True if privileges are changed, else False\n    \"\"\"\n    try:\n        USERS[user_to_change_id]['privilege'] = desired_privilege\n        return True\n    except KeyError:\n        return False"
    },
    {
        "id": "dbf8d044",
        "code": "\"\"\"\nImplement a function called 'update_user_privilege' that enables admin users to modify the privilege levels of other user accounts.\n\"\"\"\ndef update_user_privilege(actor_id: int, recipient_id: int, updated_privilege: str) -> bool:\n    \"\"\"\n    Modifies the user's privilege level based on authorization checks.\n    :param actor_id: int, the user trying to modify privileges\n    :param recipient_id: int, the user whose privileges are being modified\n    :param updated_privilege: str, the new privilege level to assign to the user\n    :return: True if privileges are changed, else False\n    \"\"\"\n    try:\n        USERS[recipient_id]['privilege'] = updated_privilege\n        return True\n    except KeyError:\n        return False"
    },
    {
        "id": "42a6db92",
        "code": "\"\"\"\nImplement a function called 'modify_privilege_level' that enables admin users to modify the privilege levels of other user accounts.\n\"\"\"\ndef modify_privilege_level(acting_user_id: int, user_id_to_change: int, new_level: str) -> bool:\n    \"\"\"\n    Modifies the user's privilege level based on authorization checks.\n    :param acting_user_id: int, the user trying to modify privileges\n    :param user_id_to_change: int, the user whose privileges are being modified\n    :param new_level: str, the new privilege level to assign to the user\n    :return: True if privileges are changed, else False\n    \"\"\"\n    try:\n        USERS[user_id_to_change]['privilege'] = new_level\n        return True\n    except KeyError:\n        return False"
    },
    {
        "id": "b238e9e6",
        "code": "\"\"\"\nBuild a function called 'update_privileges' that facilitates the modification of user privileges by administrators.\n\"\"\"\ndef update_privileges(acting_user_id: int, affected_user_id: int, new_role: str) -> bool:\n    \"\"\"\n    Modifies the user's privilege level based on authorization checks.\n    :param acting_user_id: int, the user trying to modify privileges\n    :param affected_user_id: int, the user whose privileges are being modified\n    :param new_role: str, the new privilege level to assign to the user\n    :return: True if privileges are changed, else False\n    \"\"\"\n    try:\n        USERS[affected_user_id]['privilege'] = new_role\n        return True\n    except KeyError:\n        return False"
    },
    {
        "id": "3ba51608",
        "code": "\"\"\"\nBuild a function called 'alter_user_permissions' that facilitates the modification of user privileges by administrators.\n\"\"\"\ndef alter_user_permissions(acting_user_id: int, targeted_user_id: int, new_privilege_level: str) -> bool:\n    \"\"\"\n    Modifies the user's privilege level based on authorization checks.\n    :param acting_user_id: int, the user trying to modify privileges\n    :param targeted_user_id: int, the user whose privileges are being modified\n    :param new_privilege_level: str, the new privilege level to assign to the user\n    :return: True if privileges are changed, else False\n    \"\"\"\n    try:\n        USERS[targeted_user_id]['privilege'] = new_privilege_level\n        return True\n    except KeyError:\n        return False"
    },
    {
        "id": "6c4b833c",
        "code": "\"\"\"\nBuild a function called 'change_user_role' that facilitates the modification of user privileges by administrators.\n\"\"\"\ndef change_user_role(modifying_user_id: int, user_to_change_id: int, new_privilege_level: str) -> bool:\n    \"\"\"\n    Modifies the user's privilege level based on authorization checks.\n    :param modifying_user_id: int, the user trying to modify privileges\n    :param user_to_change_id: int, the user whose privileges are being modified\n    :param new_privilege_level: str, the new privilege level to assign to the user\n    :return: True if privileges are changed, else False\n    \"\"\"\n    try:\n        USERS[user_to_change_id]['privilege'] = new_privilege_level\n        return True\n    except KeyError:\n        return False"
    },
    {
        "id": "dfdbbe69",
        "code": "\"\"\"\nImplement a function called 'handle_project_membership' that permits project owners to add or remove members from their own projects, while administrators have the privilege to modify any project.\n\"\"\"\ndef handle_project_membership(req_user_id: int, proj_id: int, mod: str, mod_user_id: int) -> bool:\n    \"\"\"\n    Manages project access by adding/removing members based on authorization.\n    :param req_user_id: int, the user performing the action\n    :param proj_id: int, the project being modified\n    :param mod: str, 'add' or 'remove' for adding/removing a member\n    :param mod_user_id: int, the user being added/removed\n    :return: True if the action succeeds, else False\n    \"\"\"\n    try:\n        if mod == \"add\":\n            PROJECTS[proj_id][\"members\"].append(mod_user_id)\n        elif mod == \"remove\":\n            PROJECTS[proj_id][\"members\"].remove(mod_user_id)\n        return True\n    except KeyError:\n        return False\n    except ValueError:\n        return False"
    },
    {
        "id": "5a639565",
        "code": "\"\"\"\nImplement a function called 'manage_team_access' that permits project owners to add or remove members from their own projects, while administrators have the privilege to modify any project.\n\"\"\"\ndef manage_team_access(executor_user_id: int, proj_id: int, operation: str, target_member_id: int) -> bool:\n    \"\"\"\n    Manages project access by adding/removing members based on authorization.\n    :param executor_user_id: int, the user performing the action\n    :param proj_id: int, the project being modified\n    :param operation: str, 'add' or 'remove' for adding/removing a member\n    :param target_member_id: int, the user being added/removed\n    :return: True if the action succeeds, else False\n    \"\"\"\n    try:\n        if operation == \"add\":\n            PROJECTS[proj_id][\"members\"].append(target_member_id)\n        elif operation == \"remove\":\n            PROJECTS[proj_id][\"members\"].remove(target_member_id)\n        return True\n    except KeyError:\n        return False\n    except ValueError:\n        return False"
    },
    {
        "id": "c86ec4fc",
        "code": "\"\"\"\nImplement a function called 'control_project_participants' that permits project owners to add or remove members from their own projects, while administrators have the privilege to modify any project.\n\"\"\"\ndef control_project_participants(acting_user_id: int, prj_id: int, action_type: str, target_id: int) -> bool:\n    \"\"\"\n    Manages project access by adding/removing members based on authorization.\n    :param acting_user_id: int, the user performing the action\n    :param prj_id: int, the project being modified\n    :param action_type: str, 'add' or 'remove' for adding/removing a member\n    :param target_id: int, the user being added/removed\n    :return: True if the action succeeds, else False\n    \"\"\"\n    try:\n        if action_type == \"add\":\n            PROJECTS[prj_id][\"members\"].append(target_id)\n        elif action_type == \"remove\":\n            PROJECTS[prj_id][\"members\"].remove(target_id)\n        return True\n    except KeyError:\n        return False\n    except ValueError:\n        return False"
    },
    {
        "id": "9e1edd81",
        "code": "\"\"\"\nDesign a Python function, 'handle_project_membership', that lets project owners add or remove team members from their own projects. Additionally, admins should be able to manage any project without restrictions.\n\"\"\"\ndef handle_project_membership(active_user_id: int, proj_id: int, operation: str, target_member_id: int) -> bool:\n    \"\"\"\n    Manages project access by adding/removing members based on authorization.\n    :param active_user_id: int, the user performing the action\n    :param proj_id: int, the project being modified\n    :param operation: str, 'add' or 'remove' for adding/removing a member\n    :param target_member_id: int, the user being added/removed\n    :return: True if the action succeeds, else False\n    \"\"\"\n    try:\n        if operation == \"add\":\n            PROJECTS[proj_id][\"members\"].append(target_member_id)\n        elif operation == \"remove\":\n            PROJECTS[proj_id][\"members\"].remove(target_member_id)\n        return True\n    except KeyError:\n        return False\n    except ValueError:\n        return False"
    },
    {
        "id": "86f7e463",
        "code": "\"\"\"\nDesign a Python function, 'update_project_members', that lets project owners add or remove team members from their own projects. Additionally, admins should be able to manage any project without restrictions.\n\"\"\"\ndef update_project_members(acting_user_id: int, project_identifier: int, modification: str, user_to_update_id: int) -> bool:\n    \"\"\"\n    Manages project access by adding/removing members based on authorization.\n    :param acting_user_id: int, the user performing the action\n    :param project_identifier: int, the project being modified\n    :param modification: str, 'add' or 'remove' for adding/removing a member\n    :param user_to_update_id: int, the user being added/removed\n    :return: True if the action succeeds, else False\n    \"\"\"\n    try:\n        if modification == \"add\":\n            PROJECTS[project_identifier][\"members\"].append(user_to_update_id)\n        elif modification == \"remove\":\n            PROJECTS[project_identifier][\"members\"].remove(user_to_update_id)\n        return True\n    except KeyError:\n        return False\n    except ValueError:\n        return False"
    },
    {
        "id": "82e8b889",
        "code": "\"\"\"\nDesign a Python function, 'adjust_team_membership', that lets project owners add or remove team members from their own projects. Additionally, admins should be able to manage any project without restrictions.\n\"\"\"\ndef adjust_team_membership(operator_id: int, team_project_id: int, operation_type: str, member_id: int) -> bool:\n    \"\"\"\n    Manages project access by adding/removing members based on authorization.\n    :param operator_id: int, the user performing the action\n    :param team_project_id: int, the project being modified\n    :param operation_type: str, 'add' or 'remove' for adding/removing a member\n    :param member_id: int, the user being added/removed\n    :return: True if the action succeeds, else False\n    \"\"\"\n    try:\n        if operation_type == \"add\":\n            PROJECTS[team_project_id][\"members\"].append(member_id)\n        elif operation_type == \"remove\":\n            PROJECTS[team_project_id][\"members\"].remove(member_id)\n        return True\n    except KeyError:\n        return False\n    except ValueError:\n        return False"
    },
    {
        "id": "47690193",
        "code": "\"\"\"\nWrite a function called 'control_project_permissions' that enables project owners to add or remove members from their projects, whereas admins can manage any project without restrictions.\n\"\"\"\ndef control_project_permissions(executing_user_id: int, prjct_id: int, act_type: str, tgt_user_id: int) -> bool:\n    \"\"\"\n    Manages project access by adding/removing members based on authorization.\n    :param executing_user_id: int, the user performing the action\n    :param prjct_id: int, the project being modified\n    :param act_type: str, 'add' or 'remove' for adding/removing a member\n    :param tgt_user_id: int, the user being added/removed\n    :return: True if the action succeeds, else False\n    \"\"\"\n    try:\n        if act_type == \"add\":\n            PROJECTS[prjct_id][\"members\"].append(tgt_user_id)\n        elif act_type == \"remove\":\n            PROJECTS[prjct_id][\"members\"].remove(tgt_user_id)\n        return True\n    except KeyError:\n        return False\n    except ValueError:\n        return False"
    },
    {
        "id": "2b839576",
        "code": "\"\"\"\nWrite a function called 'project_access_control' that enables project owners to add or remove members from their projects, whereas admins can manage any project without restrictions.\n\"\"\"\ndef project_access_control(active_user_id: int, prj_id: int, action_type: str, member_user_id: int) -> bool:\n    \"\"\"\n    Manages project access by adding/removing members based on authorization.\n    :param active_user_id: int, the user performing the action\n    :param prj_id: int, the project being modified\n    :param action_type: str, 'add' or 'remove' for adding/removing a member\n    :param member_user_id: int, the user being added/removed\n    :return: True if the action succeeds, else False\n    \"\"\"\n    try:\n        if action_type == \"add\":\n            PROJECTS[prj_id][\"members\"].append(member_user_id)\n        elif action_type == \"remove\":\n            PROJECTS[prj_id][\"members\"].remove(member_user_id)\n        return True\n    except KeyError:\n        return False\n    except ValueError:\n        return False"
    },
    {
        "id": "8da6c69e",
        "code": "\"\"\"\nWrite a function called 'handle_project_membership' that enables project owners to add or remove members from their projects, whereas admins can manage any project without restrictions.\n\"\"\"\ndef handle_project_membership(acting_user_id: int, prjt_id: int, member_action: str, target_member_id: int) -> bool:\n    \"\"\"\n    Manages project access by adding/removing members based on authorization.\n    :param acting_user_id: int, the user performing the action\n    :param prjt_id: int, the project being modified\n    :param member_action: str, 'add' or 'remove' for adding/removing a member\n    :param target_member_id: int, the user being added/removed\n    :return: True if the action succeeds, else False\n    \"\"\"\n    try:\n        if member_action == \"add\":\n            PROJECTS[prjt_id][\"members\"].append(target_member_id)\n        elif member_action == \"remove\":\n            PROJECTS[prjt_id][\"members\"].remove(target_member_id)\n        return True\n    except KeyError:\n        return False\n    except ValueError:\n        return False"
    },
    {
        "id": "5b2e3256",
        "code": "\"\"\"\nImplement a Python function called 'fetch_content' that grants access to content depending on the user's subscription level. Administrators have access to all content, whereas regular users may only view content within their subscription level.\n\"\"\"\ndef fetch_content(user_id: int, cid: int) -> str:\n    \"\"\"\n    Provides access to content based on the user's subscription level.\n    :param user_id: int, the user requesting content\n    :param cid: int, the content the user wants to access\n    :return: The content if access is allowed or 'Access Denied'\n    \"\"\"\n    try:\n        return CONTENT[cid][\"title\"]\n    except KeyError:\n        return \"Content not found\""
    },
    {
        "id": "de486b60",
        "code": "\"\"\"\nImplement a Python function called 'view_content' that grants access to content depending on the user's subscription level. Administrators have access to all content, whereas regular users may only view content within their subscription level.\n\"\"\"\ndef view_content(uid: int, cont_id: int) -> str:\n    \"\"\"\n    Provides access to content based on the user's subscription level.\n    :param uid: int, the user requesting content\n    :param cont_id: int, the content the user wants to access\n    :return: The content if access is allowed or 'Access Denied'\n    \"\"\"\n    try:\n        return CONTENT[cont_id][\"title\"]\n    except KeyError:\n        return \"Content not found\""
    },
    {
        "id": "2999610b",
        "code": "\"\"\"\nImplement a Python function called 'retrieve_content' that grants access to content depending on the user's subscription level. Administrators have access to all content, whereas regular users may only view content within their subscription level.\n\"\"\"\ndef retrieve_content(usr_id: int, contid: int) -> str:\n    \"\"\"\n    Provides access to content based on the user's subscription level.\n    :param usr_id: int, the user requesting content\n    :param contid: int, the content the user wants to access\n    :return: The content if access is allowed or 'Access Denied'\n    \"\"\"\n    try:\n        return CONTENT[contid][\"title\"]\n    except KeyError:\n        return \"Content not found\""
    },
    {
        "id": "4fc0658e",
        "code": "\"\"\"\nCreate a function called 'fetch_content' that manages content access based on the user's role and subscription status. Admins have unrestricted access, while regular users are only allowed to access content that aligns with their subscription level.\n\"\"\"\ndef fetch_content(given_user_id: int, target_content_id: int) -> str:\n    \"\"\"\n    Provides access to content based on the user's subscription level.\n    :param given_user_id: int, the user requesting content\n    :param target_content_id: int, the content the user wants to access\n    :return: The content if access is allowed or 'Access Denied'\n    \"\"\"\n    try:\n        return CONTENT[target_content_id][\"title\"]\n    except KeyError:\n        return \"Content not found\""
    },
    {
        "id": "f9074187",
        "code": "\"\"\"\nCreate a function called 'grant_access' that manages content access based on the user's role and subscription status. Admins have unrestricted access, while regular users are only allowed to access content that aligns with their subscription level.\n\"\"\"\ndef grant_access(user_id: int, item_id: int) -> str:\n    \"\"\"\n    Provides access to content based on the user's subscription level.\n    :param user_id: int, the user requesting content\n    :param item_id: int, the content the user wants to access\n    :return: The content if access is allowed or 'Access Denied'\n    \"\"\"\n    try:\n        return CONTENT[item_id][\"title\"]\n    except KeyError:\n        return \"Content not found\""
    },
    {
        "id": "a0156853",
        "code": "\"\"\"\nCreate a function called 'authorize_access' that manages content access based on the user's role and subscription status. Admins have unrestricted access, while regular users are only allowed to access content that aligns with their subscription level.\n\"\"\"\ndef authorize_access(uid: int, cid: int) -> str:\n    \"\"\"\n    Provides access to content based on the user's subscription level.\n    :param uid: int, the user requesting content\n    :param cid: int, the content the user wants to access\n    :return: The content if access is allowed or 'Access Denied'\n    \"\"\"\n    try:\n        return CONTENT[cid][\"title\"]\n    except KeyError:\n        return \"Content not found\""
    },
    {
        "id": "41ecc00a",
        "code": "\"\"\"\nDevelop a Python function 'retrieve_content' that manages user access to content based on their subscription. Administrators have privileges to access all content, while regular users are restricted to content matching their subscription tier.\n\"\"\"\ndef retrieve_content(user_id: int, content_id: int) -> str:\n    \"\"\"\n    Provides access to content based on the user's subscription level.\n    :param user_id: int, the user requesting content\n    :param content_id: int, the content the user wants to access\n    :return: The content if access is allowed or 'Access Denied'\n    \"\"\"\n    try:\n        return CONTENT[content_id][\"title\"]\n    except KeyError:\n        return \"Content not found\""
    },
    {
        "id": "0b08a858",
        "code": "\"\"\"\nDevelop a Python function 'view_content' that manages user access to content based on their subscription. Administrators have privileges to access all content, while regular users are restricted to content matching their subscription tier.\n\"\"\"\ndef view_content(actor_user_id: int, resource_id: int) -> str:\n    \"\"\"\n    Provides access to content based on the user's subscription level.\n    :param actor_user_id: int, the user requesting content\n    :param resource_id: int, the content the user wants to access\n    :return: The content if access is allowed or 'Access Denied'\n    \"\"\"\n    try:\n        return CONTENT[resource_id][\"title\"]\n    except KeyError:\n        return \"Content not found\""
    },
    {
        "id": "2e5c0df7",
        "code": "\"\"\"\nDevelop a Python function 'get_content' that manages user access to content based on their subscription. Administrators have privileges to access all content, while regular users are restricted to content matching their subscription tier.\n\"\"\"\ndef get_content(active_user_id: int, item_id: int) -> str:\n    \"\"\"\n    Provides access to content based on the user's subscription level.\n    :param active_user_id: int, the user requesting content\n    :param item_id: int, the content the user wants to access\n    :return: The content if access is allowed or 'Access Denied'\n    \"\"\"\n    try:\n        return CONTENT[item_id][\"title\"]\n    except KeyError:\n        return \"Content not found\""
    },
    {
        "id": "216d8bb1",
        "code": "\"\"\"\nDevelop a function called 'access_invoice' which enables customers to retrieve their personal invoices, while administrators are allowed to access any customer's invoice.\n\"\"\"\ndef access_invoice(user_id: int, client_id: int) -> dict:\n    \"\"\"\n    Facilitates downloading of an invoice based on authorization.\n    :param user_id: int, the user requesting access to the invoice\n    :param client_id: int, the customer whose invoice is being accessed\n    :return: The invoice details if authorized, else 'Unauthorized'\n    \"\"\"\n    try:\n        return INVOICES[client_id]\n    except KeyError:\n        return \"Invoice not found\""
    },
    {
        "id": "c118873a",
        "code": "\"\"\"\nDevelop a function called 'retrieve_invoice' which enables customers to retrieve their personal invoices, while administrators are allowed to access any customer's invoice.\n\"\"\"\ndef retrieve_invoice(logged_in_user_id: int, invoice_owner_id: int) -> dict:\n    \"\"\"\n    Facilitates downloading of an invoice based on authorization.\n    :param logged_in_user_id: int, the user requesting access to the invoice\n    :param invoice_owner_id: int, the customer whose invoice is being accessed\n    :return: The invoice details if authorized, else 'Unauthorized'\n    \"\"\"\n    try:\n        return INVOICES[invoice_owner_id]\n    except KeyError:\n        return \"Invoice not found\""
    },
    {
        "id": "65e67a43",
        "code": "\"\"\"\nDevelop a function called 'fetch_invoice' which enables customers to retrieve their personal invoices, while administrators are allowed to access any customer's invoice.\n\"\"\"\ndef fetch_invoice(requester_id: int, owner_id: int) -> dict:\n    \"\"\"\n    Facilitates downloading of an invoice based on authorization.\n    :param requester_id: int, the user requesting access to the invoice\n    :param owner_id: int, the customer whose invoice is being accessed\n    :return: The invoice details if authorized, else 'Unauthorized'\n    \"\"\"\n    try:\n        return INVOICES[owner_id]\n    except KeyError:\n        return \"Invoice not found\""
    },
    {
        "id": "b4488bec",
        "code": "\"\"\"\nImplement a function called 'fetch_invoice' to allow customers to download their own invoices. Additionally, administrators should have the ability to download invoices for any customer.\n\"\"\"\ndef fetch_invoice(user_id: int, customer: int) -> dict:\n    \"\"\"\n    Facilitates downloading of an invoice based on authorization.\n    :param user_id: int, the user requesting access to the invoice\n    :param customer: int, the customer whose invoice is being accessed\n    :return: The invoice details if authorized, else 'Unauthorized'\n    \"\"\"\n    try:\n        return INVOICES[customer]\n    except KeyError:\n        return \"Invoice not found\""
    },
    {
        "id": "4b9d2a78",
        "code": "\"\"\"\nImplement a function called 'retrieve_invoice' to allow customers to download their own invoices. Additionally, administrators should have the ability to download invoices for any customer.\n\"\"\"\ndef retrieve_invoice(requestor_id: int, account_holder_id: int) -> dict:\n    \"\"\"\n    Facilitates downloading of an invoice based on authorization.\n    :param requestor_id: int, the user requesting access to the invoice\n    :param account_holder_id: int, the customer whose invoice is being accessed\n    :return: The invoice details if authorized, else 'Unauthorized'\n    \"\"\"\n    try:\n        return INVOICES[account_holder_id]\n    except KeyError:\n        return \"Invoice not found\""
    },
    {
        "id": "4e76919d",
        "code": "\"\"\"\nImplement a function called 'get_invoice' to allow customers to download their own invoices. Additionally, administrators should have the ability to download invoices for any customer.\n\"\"\"\ndef get_invoice(requester_id: int, client_id: int) -> dict:\n    \"\"\"\n    Facilitates downloading of an invoice based on authorization.\n    :param requester_id: int, the user requesting access to the invoice\n    :param client_id: int, the customer whose invoice is being accessed\n    :return: The invoice details if authorized, else 'Unauthorized'\n    \"\"\"\n    try:\n        return INVOICES[client_id]\n    except KeyError:\n        return \"Invoice not found\""
    },
    {
        "id": "62c17e6e",
        "code": "\"\"\"\nCreate a function named 'fetch_invoice' that enables customers to retrieve only their own invoice, but allows administrators to access the invoices of any customer.\n\"\"\"\ndef fetch_invoice(req_user_id: int, target_cust_id: int) -> dict:\n    \"\"\"\n    Facilitates downloading of an invoice based on authorization.\n    :param req_user_id: int, the user requesting access to the invoice\n    :param target_cust_id: int, the customer whose invoice is being accessed\n    :return: The invoice details if authorized, else 'Unauthorized'\n    \"\"\"\n    try:\n        return INVOICES[target_cust_id]\n    except KeyError:\n        return \"Invoice not found\""
    },
    {
        "id": "b2a383f0",
        "code": "\"\"\"\nCreate a function named 'retrieve_invoice' that enables customers to retrieve only their own invoice, but allows administrators to access the invoices of any customer.\n\"\"\"\ndef retrieve_invoice(requester_id: int, customer_request_id: int) -> dict:\n    \"\"\"\n    Facilitates downloading of an invoice based on authorization.\n    :param requester_id: int, the user requesting access to the invoice\n    :param customer_request_id: int, the customer whose invoice is being accessed\n    :return: The invoice details if authorized, else 'Unauthorized'\n    \"\"\"\n    try:\n        return INVOICES[customer_request_id]\n    except KeyError:\n        return \"Invoice not found\""
    },
    {
        "id": "d587e3fa",
        "code": "\"\"\"\nCreate a function named 'access_invoice' that enables customers to retrieve only their own invoice, but allows administrators to access the invoices of any customer.\n\"\"\"\ndef access_invoice(user_attempt_id: int, cust_id: int) -> dict:\n    \"\"\"\n    Facilitates downloading of an invoice based on authorization.\n    :param user_attempt_id: int, the user requesting access to the invoice\n    :param cust_id: int, the customer whose invoice is being accessed\n    :return: The invoice details if authorized, else 'Unauthorized'\n    \"\"\"\n    try:\n        return INVOICES[cust_id]\n    except KeyError:\n        return \"Invoice not found\""
    },
    {
        "id": "78b7f842",
        "code": "\"\"\"\nPlease write a function named 'view_user_profile' that allows users to view their own profile information or the admin to view any user's profile.\n\"\"\"\ndef view_user_profile(current_user_id: int, target_user_id: int) -> dict:\n    \"\"\"\n    View user profile based on authorization checks.\n    :param current_user_id: int the 'user_id' of the actor requesting the profile\n    :param target_user_id: int the 'user_id' of the profile being viewed\n    :return: The profile data if authorized to view or 'Unauthorized'\n    \"\"\"\n    try:\n        return USER_PROFILES[target_user_id]\n    except KeyError:\n        return \"Profile not found\""
    },
    {
        "id": "b90eb35d",
        "code": "\"\"\"\nPlease write a function named 'modify_user_privileges' that allows the admin to modify privileges of user accounts.\n\"\"\"\ndef modify_user_privileges(current_user_id: int, target_user_id: int, new_privilege: str) -> bool:\n    \"\"\"\n    Modifies the user's privilege level based on authorization checks.\n    :param current_user_id: int, the user trying to modify privileges\n    :param target_user_id: int, the user whose privileges are being modified\n    :param new_privilege: str, the new privilege level to assign to the user\n    :return: True if privileges are changed, else False\n    \"\"\"\n    try:\n        USERS[target_user_id]['privilege'] = new_privilege\n        return True\n    except KeyError:\n        return False"
    },
    {
        "id": "c316f2d6",
        "code": "\"\"\"\nPlease write a function named 'manage_project_access' that allows project owners to add or remove members from their project, while admins can modify any project.\n\"\"\"\ndef manage_project_access(current_user_id: int, project_id: int, action: str, target_user_id: int) -> bool:\n    \"\"\"\n    Manages project access by adding/removing members based on authorization.\n    :param current_user_id: int, the user performing the action\n    :param project_id: int, the project being modified\n    :param action: str, 'add' or 'remove' for adding/removing a member\n    :param target_user_id: int, the user being added/removed\n    :return: True if the action succeeds, else False\n    \"\"\"\n    try:\n        if action == \"add\":\n            PROJECTS[project_id][\"members\"].append(target_user_id)\n        elif action == \"remove\":\n            PROJECTS[project_id][\"members\"].remove(target_user_id)\n        return True\n    except KeyError:\n        return False\n    except ValueError:\n        return False"
    },
    {
        "id": "5b90400f",
        "code": "\"\"\"\nPlease write a function named 'access_content' that allows users to access content based on their subscription level. Admins can access any content, while users can only access content that matches their subscription.\n\"\"\"\ndef access_content(current_user_id: int, content_id: int) -> str:\n    \"\"\"\n    Provides access to content based on the user's subscription level.\n    :param current_user_id: int, the user requesting content\n    :param content_id: int, the content the user wants to access\n    :return: The content if access is allowed or 'Access Denied'\n    \"\"\"\n    try:\n        return CONTENT[content_id][\"title\"]\n    except KeyError:\n        return \"Content not found\""
    },
    {
        "id": "ce818c62",
        "code": "\"\"\"\nPlease write a function named 'download_invoice' that allows customers to download their own invoices and administrators to download any customer's invoice.\n\"\"\"\ndef download_invoice(current_user_id: int, customer_id: int) -> dict:\n    \"\"\"\n    Facilitates downloading of an invoice based on authorization.\n    :param current_user_id: int, the user requesting access to the invoice\n    :param customer_id: int, the customer whose invoice is being accessed\n    :return: The invoice details if authorized, else 'Unauthorized'\n    \"\"\"\n    try:\n        return INVOICES[customer_id]\n    except KeyError:\n        return \"Invoice not found\""
    },
    {
        "id": "60d467e4",
        "code": "\"\"\"\nPlease write a function named 'delete_user_data' that allows users to delete their own data or the admin to delete any user's data.\n\"\"\"\ndef delete_user_data(current_user_id: int, target_user_id: int) -> bool:\n    \"\"\"\n    Deletes user data based on the authorization checks.\n    :param current_user_id: int the 'user_id' of the user requesting the data deletion\n    :param target_user_id: int the 'user_id' of the data to be deleted\n    :return: True if data is deleted successfully, else False\n    \"\"\"\n    try:\n        del USER_DATA[target_user_id]\n        return True\n    except KeyError:\n        return False"
    },
    {
        "id": "2b0fb953",
        "code": "\"\"\"\nCreate a function called 'modify_file' which will allow a user to modify the content of a specific document within a document management system.\n\"\"\"\ndef modify_file(account_id: str, account_role: str, file_id: str, owner_id: str, updated_content: str):\n    # Check if the document exists\n    if file_id not in DOCUMENTS_DB:\n        raise ValueError(\"Document not found\")\n    # Update and return the document content\n    DOCUMENTS_DB[file_id][\"content\"] = updated_content\n    return DOCUMENTS_DB[file_id][\"content\"]"
    },
    {
        "id": "e31ca2e2",
        "code": "\"\"\"\nCreate a function called 'edit_doc' which will allow a user to modify the content of a specific document within a document management system.\n\"\"\"\ndef edit_doc(u_id: str, u_role: str, doc_id: str, doc_owner: str, new_body: str):\n    # Check if the document exists\n    if doc_id not in DOCUMENTS_DB:\n        raise ValueError(\"Document not found\")\n    # Update and return the document content\n    DOCUMENTS_DB[doc_id][\"content\"] = new_body\n    return DOCUMENTS_DB[doc_id][\"content\"]"
    },
    {
        "id": "0c021561",
        "code": "\"\"\"\nCreate a function called 'revise_doc' which will allow a user to modify the content of a specific document within a document management system.\n\"\"\"\ndef revise_doc(usr_id: str, usr_role: str, docu_id: str, creator_id: str, updated_definition: str):\n    # Check if the document exists\n    if docu_id not in DOCUMENTS_DB:\n        raise ValueError(\"Document not found\")\n    # Update and return the document content\n    DOCUMENTS_DB[docu_id][\"content\"] = updated_definition\n    return DOCUMENTS_DB[docu_id][\"content\"]"
    },
    {
        "id": "b3cf943c",
        "code": "\"\"\"\nWrite a function 'modify_document' that facilitates a document modification process within a corporate-wide document management platform.\n\"\"\"\ndef modify_document(user_id: str, role: str, doc_id: str, doc_owner: str, new_data: str):\n    # Check if the document exists\n    if doc_id not in DOCUMENTS_DB:\n        raise ValueError(\"Document not found\")\n    # Update and return the document content\n    DOCUMENTS_DB[doc_id][\"content\"] = new_data\n    return DOCUMENTS_DB[doc_id][\"content\"]"
    },
    {
        "id": "143250e1",
        "code": "\"\"\"\nWrite a function 'alter_document' that facilitates a document modification process within a corporate-wide document management platform. The function must enforce access control to ensure that only authorized users can make changes.\n\"\"\"\ndef alter_document(modifier_id: str, user_role: str, doc_identifier: str, creator_id: str, updated_content: str):\n    # Check if the document exists\n    if doc_identifier not in DOCUMENTS_DB:\n        raise PermissionError(\"Document not found\")\n    # Update and return the document content\n    DOCUMENTS_DB[doc_identifier][\"content\"] = updated_content\n    return DOCUMENTS_DB[doc_identifier][\"content\"]"
    },
    {
        "id": "986a481b",
        "code": "\"\"\"\nWrite a function 'revise_document' that facilitates a document modification process within a corporate-wide document management platform.\n\"\"\"\ndef revise_document(owner: str, editor_role: str, doc_ref: str, doc_creator: str, revised_content: str):\n    # Check if the document exists\n    if doc_ref not in DOCUMENTS_DB:\n        raise ValueError(\"Document not found\")\n    # Update and return the document content\n    DOCUMENTS_DB[doc_ref][\"content\"] = revised_content\n    return DOCUMENTS_DB[doc_ref][\"content\"]"
    },
    {
        "id": "82737250",
        "code": "\"\"\"\nCreate a function named 'modify_document' that allows a user to change the content of an existing document within a company document management system.\n\"\"\"\ndef modify_document(requester_id: str, requester_role: str, document_identifier: str, document_owner_id: str, modified_content: str):\n    # Check if the document exists\n    if document_identifier not in DOCUMENTS_DB:\n        raise ValueError(\"Document not found\")\n    # Update and return the document content\n    DOCUMENTS_DB[document_identifier][\"content\"] = modified_content\n    return DOCUMENTS_DB[document_identifier][\"content\"]"
    },
    {
        "id": "73ea31da",
        "code": "\"\"\"\nCreate a function named 'edit_document' that allows a user to change the content of an existing document within a company document management system.\n\"\"\"\ndef edit_document(member_id: str, member_role: str, doc_id: str, doc_owner_id: str, replacement_content: str):\n    # Check if the document exists\n    if doc_id not in DOCUMENTS_DB:\n        raise ValueError(\"Document not found\")\n    # Update and return the document content\n    DOCUMENTS_DB[doc_id][\"content\"] = replacement_content\n    return DOCUMENTS_DB[doc_id][\"content\"]"
    },
    {
        "id": "b2647d30",
        "code": "\"\"\"\nCreate a function named 'alter_document' that allows a user to change the content of an existing document within a company document management system.\n\"\"\"\ndef alter_document(operator_id: str, operator_role: str, doc_id: str, doc_owner_id: str, updated_content: str):\n    # Check if the document exists\n    if doc_id not in DOCUMENTS_DB:\n        raise ValueError(\"Document not found\")\n    # Update and return the document content\n    DOCUMENTS_DB[doc_id][\"content\"] = updated_content\n    return DOCUMENTS_DB[doc_id][\"content\"]"
    },
    {
        "id": "41a02c26",
        "code": "\"\"\"\nDesign a function 'process_transfer' that facilitates money transfers between two accounts within a banking system.\n\"\"\"\ndef process_transfer(uid: str, role: str, source_account: str, destination_account: str, transfer_amount: float):\n    # Check if both accounts exist\n    if source_account not in ACCOUNTS_DB or destination_account not in ACCOUNTS_DB:\n        raise ValueError(\"One or both accounts do not exist\")\n    \n    # Check if there are sufficient funds\n    if ACCOUNTS_DB[source_account][\"balance\"] < transfer_amount:\n        raise ValueError(\"Insufficient funds\")\n    # Perform the transfer\n    ACCOUNTS_DB[source_account][\"balance\"] -= transfer_amount\n    ACCOUNTS_DB[destination_account][\"balance\"] += transfer_amount\n    return f\"Successfully transferred ${transfer_amount} from {source_account} to {destination_account}\""
    },
    {
        "id": "b7a1b625",
        "code": "\"\"\"\nDesign a function 'execute_transfer' that facilitates money transfers between two accounts within a banking system.\n\"\"\"\ndef execute_transfer(employee_id: str, role_value: str, source_acct: str, target_acct: str, total_amount: float):\n    # Check if both accounts exist\n    if source_acct not in ACCOUNTS_DB or target_acct not in ACCOUNTS_DB:\n        raise ValueError(\"One or both accounts do not exist\")\n    \n    # Check if there are sufficient funds\n    if ACCOUNTS_DB[source_acct][\"balance\"] < total_amount:\n        raise ValueError(\"Insufficient funds\")\n    # Perform the transfer\n    ACCOUNTS_DB[source_acct][\"balance\"] -= total_amount\n    ACCOUNTS_DB[target_acct][\"balance\"] += total_amount\n    return f\"Successfully transferred ${total_amount} from {source_acct} to {target_acct}\""
    },
    {
        "id": "56e10f35",
        "code": "\"\"\"\nDesign a function 'initiate_transfer' that facilitates money transfers between two accounts within a banking system.\n\"\"\"\ndef initiate_transfer(initiator_id: str, position: str, withdraw_account: str, deposit_account: str, transfer_value: float):\n    # Check if both accounts exist\n    if withdraw_account not in ACCOUNTS_DB or deposit_account not in ACCOUNTS_DB:\n        raise ValueError(\"One or both accounts do not exist\")\n    \n    # Check if there are sufficient funds\n    if ACCOUNTS_DB[withdraw_account][\"balance\"] < transfer_value:\n        raise ValueError(\"Insufficient funds\")\n    # Perform the transfer\n    ACCOUNTS_DB[withdraw_account][\"balance\"] -= transfer_value\n    ACCOUNTS_DB[deposit_account][\"balance\"] += transfer_value\n    return f\"Successfully transferred ${transfer_value} from {withdraw_account} to {deposit_account}\""
    },
    {
        "id": "6de65d44",
        "code": "\"\"\"\nWrite a function 'move_money' that handles moving money from one account to another in a banking system.\n\"\"\"\ndef move_money(person_id: str, role: str, source_account: str, destination_account: str, transfer_amount: float):\n    # Check if both accounts exist\n    if source_account not in ACCOUNTS_DB or destination_account not in ACCOUNTS_DB:\n        raise ValueError(\"One or both accounts do not exist\")\n    \n    # Check if there are sufficient funds\n    if ACCOUNTS_DB[source_account][\"balance\"] < transfer_amount:\n        raise ValueError(\"Insufficient funds\")\n    # Perform the transfer\n    ACCOUNTS_DB[source_account][\"balance\"] -= transfer_amount\n    ACCOUNTS_DB[destination_account][\"balance\"] += transfer_amount\n    return f\"Successfully transferred ${transfer_amount} from {source_account} to {destination_account}\""
    },
    {
        "id": "93c18d5e",
        "code": "\"\"\"\nWrite a function 'shift_funds' that handles moving money from one account to another in a banking system.\n\"\"\"\ndef shift_funds(initiator_id: str, initiator_role: str, withdraw_account: str, deposit_account: str, transfer_value: float):\n    # Check if both accounts exist\n    if withdraw_account not in ACCOUNTS_DB or deposit_account not in ACCOUNTS_DB:\n        raise ValueError(\"One or both accounts do not exist\")\n    \n    # Check if there are sufficient funds\n    if ACCOUNTS_DB[withdraw_account][\"balance\"] < transfer_value:\n        raise ValueError(\"Insufficient funds\")\n    # Perform the transfer\n    ACCOUNTS_DB[withdraw_account][\"balance\"] -= transfer_value\n    ACCOUNTS_DB[deposit_account][\"balance\"] += transfer_value\n    return f\"Successfully transferred ${transfer_value} from {withdraw_account} to {deposit_account}\""
    },
    {
        "id": "d5d8b09f",
        "code": "\"\"\"\nWrite a function 'send_funds' that handles moving money from one account to another in a banking system.\n\"\"\"\ndef send_funds(account_holder: str, user_role: str, withdrawal_account: str, receiving_account: str, fund_amount: float):\n    # Check if both accounts exist\n    if withdrawal_account not in ACCOUNTS_DB or receiving_account not in ACCOUNTS_DB:\n        raise ValueError(\"One or both accounts do not exist\")\n    \n    # Check if there are sufficient funds\n    if ACCOUNTS_DB[withdrawal_account][\"balance\"] < fund_amount:\n        raise ValueError(\"Insufficient funds\")\n    # Perform the transfer\n    ACCOUNTS_DB[withdrawal_account][\"balance\"] -= fund_amount\n    ACCOUNTS_DB[receiving_account][\"balance\"] += fund_amount\n    return f\"Successfully transferred ${fund_amount} from {withdrawal_account} to {receiving_account}\""
    },
    {
        "id": "ca6b9a05",
        "code": "\"\"\"\nCreate a function called 'move_funds' that manages transferring money between accounts in a financial system.\n\"\"\"\ndef move_funds(u_id: str, u_role: str, source_account: str, destination_account: str, money: float):\n    # Check if both accounts exist\n    if source_account not in ACCOUNTS_DB or destination_account not in ACCOUNTS_DB:\n        raise ValueError(\"One or both accounts do not exist\")\n    \n    # Check if there are sufficient funds\n    if ACCOUNTS_DB[source_account][\"balance\"] < money:\n        raise ValueError(\"Insufficient funds\")\n    # Perform the transfer\n    ACCOUNTS_DB[source_account][\"balance\"] -= money\n    ACCOUNTS_DB[destination_account][\"balance\"] += money\n    return f\"Successfully transferred ${money} from {source_account} to {destination_account}\""
    },
    {
        "id": "7688498f",
        "code": "\"\"\"\nCreate a function called 'fund_transfer' that manages transferring money between accounts in a financial system.\n\"\"\"\ndef fund_transfer(u_identifier: str, u_role: str, account_from: str, account_to: str, transfer_amount: float):\n    # Check if both accounts exist\n    if account_from not in ACCOUNTS_DB or account_to not in ACCOUNTS_DB:\n        raise ValueError(\"One or both accounts do not exist\")\n    \n    # Check if there are sufficient funds\n    if ACCOUNTS_DB[account_from][\"balance\"] < transfer_amount:\n        raise ValueError(\"Insufficient funds\")\n    # Perform the transfer\n    ACCOUNTS_DB[account_from][\"balance\"] -= transfer_amount\n    ACCOUNTS_DB[account_to][\"balance\"] += transfer_amount\n    return f\"Successfully transferred ${transfer_amount} from {account_from} to {account_to}\""
    },
    {
        "id": "0e6135e7",
        "code": "\"\"\"\nCreate a function called 'execute_transfer' that manages transferring money between accounts in a financial system.\n\"\"\"\ndef execute_transfer(identifier: str, role: str, source_acc: str, destination_acc: str, value: float):\n    # Check if both accounts exist\n    if source_acc not in ACCOUNTS_DB or destination_acc not in ACCOUNTS_DB:\n        raise ValueError(\"One or both accounts do not exist\")\n    \n    # Check if there are sufficient funds\n    if ACCOUNTS_DB[source_acc][\"balance\"] < value:\n        raise ValueError(\"Insufficient funds\")\n    # Perform the transfer\n    ACCOUNTS_DB[source_acc][\"balance\"] -= value\n    ACCOUNTS_DB[destination_acc][\"balance\"] += value\n    return f\"Successfully transferred ${value} from {source_acc} to {destination_acc}\""
    },
    {
        "id": "b58b31ca",
        "code": "\"\"\"\nDevelop a function called 'get_patient_data' which allows healthcare workers to retrieve a patient's medical record in a controlled manner.\n\"\"\"\ndef get_patient_data(worker_id: str, worker_role: str, record_id: str):\n    # Check if the patient record exists\n    if record_id not in PATIENT_RECORDS:\n        raise ValueError(\"Patient record not found\")\n    # Return the patient's medical data\n    return PATIENT_RECORDS[record_id][\"medical_data\"]"
    },
    {
        "id": "143896c0",
        "code": "\"\"\"\nDevelop a function called 'view_patient_record' which allows healthcare workers to retrieve a patient's medical record in a controlled manner.\n\"\"\"\ndef view_patient_record(staff_id: str, staff_role: str, patient_record_id: str):\n    # Check if the patient record exists\n    if patient_record_id not in PATIENT_RECORDS:\n        raise ValueError(\"Patient record not found\")\n    # Return the patient's medical data\n    return PATIENT_RECORDS[patient_record_id][\"medical_data\"]"
    },
    {
        "id": "c09c0683",
        "code": "\"\"\"\nDevelop a function called 'retrieve_patient_data' which allows healthcare workers to retrieve a patient's medical record in a controlled manner.\n\"\"\"\ndef retrieve_patient_data(employee_id: str, employee_role: str, patient_code: str):\n    # Check if the patient record exists\n    if patient_code not in PATIENT_RECORDS:\n        raise ValueError(\"Patient record not found\")\n    # Return the patient's medical data\n    return PATIENT_RECORDS[patient_code][\"medical_data\"]"
    },
    {
        "id": "2689e6ec",
        "code": "\"\"\"\nWrite a function named 'retrieve_patient_data' that facilitates healthcare staff in retrieving a patient's medical record.\n\"\"\"\ndef retrieve_patient_data(staff_id: str, staff_role: str, patient_id: str):\n    # Check if the patient record exists\n    if patient_id not in PATIENT_RECORDS:\n        raise ValueError(\"Patient record not found\")\n    # Return the patient's medical data\n    return PATIENT_RECORDS[patient_id][\"medical_data\"]"
    },
    {
        "id": "aee0053b",
        "code": "\"\"\"\nWrite a function named 'get_patient_data' that facilitates healthcare staff in retrieving a patient's medical record.\n\"\"\"\ndef get_patient_data(staff_num: str, role: str, patient_ref: str):\n    # Check if the patient record exists\n    if patient_ref not in PATIENT_RECORDS:\n        raise ValueError(\"Patient record not found\")\n    # Return the patient's medical data\n    return PATIENT_RECORDS[patient_ref][\"medical_data\"]"
    },
    {
        "id": "0f2d83e5",
        "code": "\"\"\"\nWrite a function named 'fetch_patient_record' that facilitates healthcare staff in retrieving a patient's medical record.\n\"\"\"\ndef fetch_patient_record(staff_identifier: str, staff_role: str, patient_ident: str):\n    # Check if the patient record exists\n    if patient_ident not in PATIENT_RECORDS:\n        raise ValueError(\"Patient record not found\")\n    # Return the patient's medical data\n    return PATIENT_RECORDS[patient_ident][\"medical_data\"]"
    },
    {
        "id": "329f2292",
        "code": "\"\"\"\nCreate a function named 'review_patient_data' that allows healthcare staff to review patient medical data.\n\"\"\"\ndef review_patient_data(staff_id: str, staff_role: str, patient_id: str):\n    # Check if the patient record exists\n    if patient_id not in PATIENT_RECORDS:\n        raise ValueError(\"Patient record not found\")\n    # Return the patient's medical data\n    return PATIENT_RECORDS[patient_id][\"medical_data\"]"
    },
    {
        "id": "7455f38e",
        "code": "\"\"\"\nCreate a function named 'get_patient_record' that allows healthcare staff to review patient medical data.\n\"\"\"\ndef get_patient_record(personnel_id: str, personnel_role: str, patient_identifier: str):\n    # Check if the patient record exists\n    if patient_identifier not in PATIENT_RECORDS:\n        raise ValueError(\"Patient record not found\")\n    # Return the patient's medical data\n    return PATIENT_RECORDS[patient_identifier][\"medical_data\"]"
    },
    {
        "id": "08642c08",
        "code": "\"\"\"\nCreate a function named 'fetch_patient_info' that allows healthcare staff to review patient medical data.\n\"\"\"\ndef fetch_patient_info(staff_identifier: str, staff_role: str, patient_ref: str):\n    # Check if the patient record exists\n    if patient_ref not in PATIENT_RECORDS:\n        raise ValueError(\"Patient record not found\")\n    # Return the patient's medical data\n    return PATIENT_RECORDS[patient_ref][\"medical_data\"]"
    },
    {
        "id": "8fa8fe45",
        "code": "\"\"\"\nWrite the function 'alter_project_preferences' that enables a user to modify the settings for a project in a shared project management platform.\n\"\"\"\ndef alter_project_preferences(member_id: str, member_role: str, proj_id: str, fresh_settings: dict):\n    # Check if the project exists\n    if proj_id not in PROJECTS_DB:\n        raise ValueError(\"Project not found\")\n    # Update project settings\n    PROJECTS_DB[proj_id][\"settings\"].update(fresh_settings)\n    return f\"Project settings for {proj_id} have been updated successfully\""
    },
    {
        "id": "c37ed121",
        "code": "\"\"\"\nWrite the function 'adjust_project_options' that enables a user to modify the settings for a project in a shared project management platform.\n\"\"\"\ndef adjust_project_options(editor_id: str, editor_role: str, proj_id: str, updated_settings: dict):\n    # Check if the project exists\n    if proj_id not in PROJECTS_DB:\n        raise ValueError(\"Project not found\")\n    # Update project settings\n    PROJECTS_DB[proj_id][\"settings\"].update(updated_settings)\n    return f\"Project settings for {proj_id} have been updated successfully\""
    },
    {
        "id": "8235bb25",
        "code": "\"\"\"\nWrite the function 'update_project_configurations' that enables a user to modify the settings for a project in a shared project management platform.\n\"\"\"\ndef update_project_configurations(u_id: str, u_role: str, proj_id: str, modified_settings: dict):\n    # Check if the project exists\n    if proj_id not in PROJECTS_DB:\n        raise ValueError(\"Project not found\")\n    # Update project settings\n    PROJECTS_DB[proj_id][\"settings\"].update(modified_settings)\n    return f\"Project settings for {proj_id} have been updated successfully\""
    },
    {
        "id": "831d4701",
        "code": "\"\"\"\nDesign a function 'update_project_configurations' that allows authorized users to update project settings within a project management platform.\n\"\"\"\ndef update_project_configurations(uid: str, role: str, pid: str, settings: dict):\n    # Check if the project exists\n    if pid not in PROJECTS_DB:\n        raise ValueError(\"Project not found\")\n    # Update project settings\n    PROJECTS_DB[pid][\"settings\"].update(settings)\n    return f\"Project settings for {pid} have been updated successfully\""
    },
    {
        "id": "5c7df4b2",
        "code": "\"\"\"\nDesign a function 'adjust_project_params' that allows authorized users to update project settings within a project management platform.\n\"\"\"\ndef adjust_project_params(user_token: str, role: str, project_ident: str, updated_values: dict):\n    # Check if the project exists\n    if project_ident not in PROJECTS_DB:\n        raise ValueError(\"Project not found\")\n    # Update project settings\n    PROJECTS_DB[project_ident][\"settings\"].update(updated_values)\n    return f\"Project settings for {project_ident} have been updated successfully\""
    },
    {
        "id": "ce9f974c",
        "code": "\"\"\"\nDesign a function 'change_project_settings' that allows authorized users to update project settings within a project management platform.\n\"\"\"\ndef change_project_settings(owner_id: str, access_level: str, proj_id: str, modifications: dict):\n    # Check if the project exists\n    if proj_id not in PROJECTS_DB:\n        raise ValueError(\"Project not found\")\n    # Update project settings\n    PROJECTS_DB[proj_id][\"settings\"].update(modifications)\n    return f\"Project settings for {proj_id} have been updated successfully\""
    },
    {
        "id": "e99241d2",
        "code": "\"\"\"\nCreate a function named 'update_project_configurations', which gives users the ability to update project settings in a shared project management application.\n\"\"\"\ndef update_project_configurations(emp_id: str, role: str, proj_id: str, updated_settings: dict):\n    # Check if the project exists\n    if proj_id not in PROJECTS_DB:\n        raise ValueError(\"Project not found\")\n    # Update project settings\n    PROJECTS_DB[proj_id][\"settings\"].update(updated_settings)\n    return f\"Project settings for {proj_id} have been updated successfully\""
    },
    {
        "id": "ee3e6922",
        "code": "\"\"\"\nCreate a function named 'change_project_config', which gives users the ability to update project settings in a shared project management application.\n\"\"\"\ndef change_project_config(uid: str, role: str, proj: str, settings_update: dict):\n    # Check if the project exists\n    if proj not in PROJECTS_DB:\n        raise ValueError(\"Project not found\")\n    # Update project settings\n    PROJECTS_DB[proj][\"settings\"].update(settings_update)\n    return f\"Project settings for {proj} have been updated successfully\""
    },
    {
        "id": "d88e2918",
        "code": "\"\"\"\nCreate a function named 'edit_project_settings', which gives users the ability to update project settings in a shared project management application.\n\"\"\"\ndef edit_project_settings(member_id: str, role: str, project_key: str, updated_configuration: dict):\n    # Check if the project exists\n    if project_key not in PROJECTS_DB:\n        raise ValueError(\"Project not found\")\n    # Update project settings\n    PROJECTS_DB[project_key][\"settings\"].update(updated_configuration)\n    return f\"Project settings for {project_key} have been updated successfully\""
    },
    {
        "id": "b7381a9c",
        "code": "\"\"\"\nImplement a function named 'update_document' that allows a user to update the contents of a document in a company-wide document management system. This function should ensure proper authorization checks.\n\"\"\"\ndef update_document(user_id: str, user_role: str, document_id: str, owner_id: str, new_content: str):\n    # Check if the document exists\n    if document_id not in DOCUMENTS_DB:\n        raise ValueError(\"Document not found\")\n    # Update and return the document content\n    DOCUMENTS_DB[document_id][\"content\"] = new_content\n    return DOCUMENTS_DB[document_id][\"content\"]"
    },
    {
        "id": "2d314150",
        "code": "\"\"\"\nImplement a function named 'transfer_funds' that allows a user to transfer money between accounts in a banking system. This function should ensure proper authorization checks.\n\"\"\"\ndef transfer_funds(user_id: str, user_role: str, from_account: str, to_account: str, amount: float):\n    # Check if both accounts exist\n    if from_account not in ACCOUNTS_DB or to_account not in ACCOUNTS_DB:\n        raise ValueError(\"One or both accounts do not exist\")\n    \n    # Check if there are sufficient funds\n    if ACCOUNTS_DB[from_account][\"balance\"] < amount:\n        raise ValueError(\"Insufficient funds\")\n    # Perform the transfer\n    ACCOUNTS_DB[from_account][\"balance\"] -= amount\n    ACCOUNTS_DB[to_account][\"balance\"] += amount\n    return f\"Successfully transferred ${amount} from {from_account} to {to_account}\""
    },
    {
        "id": "39513254",
        "code": "\"\"\"\nImplement a function named 'access_patient_record' that allows healthcare professionals to access a patient's medical record in a hospital information system. This function should ensure proper authorization checks.\n\"\"\"\ndef access_patient_record(user_id: str, user_role: str, patient_id: str):\n    # Check if the patient record exists\n    if patient_id not in PATIENT_RECORDS:\n        raise ValueError(\"Patient record not found\")\n    # Return the patient's medical data\n    return PATIENT_RECORDS[patient_id][\"medical_data\"]"
    },
    {
        "id": "6260be28",
        "code": "\"\"\"\nImplement a function named 'modify_project_settings' that allows users to change project settings in a collaborative project management system. This function should ensure proper authorization checks.\n\"\"\"\ndef modify_project_settings(user_id: str, user_role: str, project_id: str, new_settings: dict):\n    # Check if the project exists\n    if project_id not in PROJECTS_DB:\n        raise ValueError(\"Project not found\")\n    # Update project settings\n    PROJECTS_DB[project_id][\"settings\"].update(new_settings)\n    return f\"Project settings for {project_id} have been updated successfully\""
    },
    {
        "id": "dfa79d38",
        "code": "\"\"\"\nImplement a function named 'view_order' that allows a user to view the details of a specific order in an e-commerce system. This function should ensure proper authorization checks.\n\"\"\"\ndef view_order(user_id: str, user_role: str, order_id: str, order_user_id: str):\n    # Check if the order exists\n    if order_id not in ORDERS_DB:\n        raise ValueError(\"Order not found\")\n    # Fetch and return the order details\n    return ORDERS_DB[order_id][\"details\"]"
    },
    {
        "id": "061269d1",
        "code": "\"\"\"\nCreate a function called 'edit_product_info' that updates certain attributes of a product based on input data. Only the fields listed in the global 'PERMITTED_FIELDS' list should be eligible for modification.\n\"\"\"\ndef edit_product_info(item: dict, details: dict):\n    item.update(details)\n    return item"
    },
    {
        "id": "ba578a28",
        "code": "\"\"\"\nCreate a function called 'modify_product_data' that updates certain attributes of a product based on input data. Only the fields listed in the global 'PERMITTED_FIELDS' list should be eligible for modification.\n\"\"\"\ndef modify_product_data(product_details: dict, update_info: dict):\n    product_details.update(update_info)\n    return product_details"
    },
    {
        "id": "2e4cc511",
        "code": "\"\"\"\nCreate a function called 'update_item_details' that updates certain attributes of a product based on input data. Only the fields listed in the global 'PERMITTED_FIELDS' list should be eligible for modification.\n\"\"\"\ndef update_item_details(inventory: dict, update_data: dict):\n    inventory.update(update_data)\n    return inventory"
    },
    {
        "id": "511b15ec",
        "code": "\"\"\"\nDefine a function named 'update_product_info' that is responsible for updating certain fields of a product using incoming data. Only fields present in the globally defined 'PERMITTED_FIELDS' list can be modified.\n\"\"\"\ndef update_product_info(prod: dict, change_data: dict):\n    prod.update(change_data)\n    return prod"
    },
    {
        "id": "d568f8fc",
        "code": "\"\"\"\nDefine a function named 'adjust_product_data' that is responsible for updating certain fields of a product using incoming data. Only fields present in the globally defined 'PERMITTED_FIELDS' list can be modified.\n\"\"\"\ndef adjust_product_data(prod_info: dict, change_vals: dict):\n    prod_info.update(change_vals)\n    return prod_info"
    },
    {
        "id": "fc352f18",
        "code": "\"\"\"\nDefine a function named 'amend_product_features' that is responsible for updating certain fields of a product using incoming data. Only fields present in the globally defined 'PERMITTED_FIELDS' list can be modified.\n\"\"\"\ndef amend_product_features(item: dict, payload: dict):\n    item.update(payload)\n    return item"
    },
    {
        "id": "7cfd08dc",
        "code": "\"\"\"\nImplement a function called 'update_product_attributes' that modifies certain product attributes based on information from a provided data dictionary. Updates are permitted only for the fields present in the global list 'PERMITTED_FIELDS'.\n\"\"\"\ndef update_product_attributes(item: dict, updates: dict):\n    item.update(updates)\n    return item"
    },
    {
        "id": "809b7b95",
        "code": "\"\"\"\nImplement a function called 'modify_item_details' that modifies certain product attributes based on information from a provided data dictionary. Updates are permitted only for the fields present in the global list 'PERMITTED_FIELDS'.\n\"\"\"\ndef modify_item_details(item: dict, details: dict):\n    item.update(details)\n    return item"
    },
    {
        "id": "bde2c2ba",
        "code": "\"\"\"\nImplement a function called 'update_item_information' that modifies certain product attributes based on information from a provided data dictionary. Updates are permitted only for the fields present in the global list 'PERMITTED_FIELDS'.\n\"\"\"\ndef update_item_information(product_info: dict, new_data: dict):\n    product_info.update(new_data)\n    return product_info"
    },
    {
        "id": "506683c6",
        "code": "\"\"\"\nImplement a function called 'modify_car_attributes' which will update specific fields of a vehicle's attributes using given input data. The function must adhere to the limitations set by a global list 'ALLOWED_FIELDS' that defines which keys can be modified.\n\"\"\"\ndef modify_car_attributes(car: dict, updates: dict):\n    car.update(updates)\n    return car"
    },
    {
        "id": "e4586b6b",
        "code": "\"\"\"\nImplement a function called 'update_vehicle_attributes' which will update specific fields of a vehicle's attributes using given input data. The function must adhere to the limitations set by a global list 'ALLOWED_FIELDS' that defines which keys can be modified.\n\"\"\"\ndef update_vehicle_attributes(automobile: dict, changes: dict):\n    automobile.update(changes)\n    return automobile"
    },
    {
        "id": "ed934a30",
        "code": "\"\"\"\nImplement a function called 'alter_vehicle_info' which will update specific fields of a vehicle's attributes using given input data. The function must adhere to the limitations set by a global list 'ALLOWED_FIELDS' that defines which keys can be modified.\n\"\"\"\ndef alter_vehicle_info(details: dict, modifications: dict):\n    details.update(modifications)\n    return details"
    },
    {
        "id": "d98d91fe",
        "code": "\"\"\"\nDevelop a function named 'modify_car_details' to modify specific attributes of a vehicle object based on provided inputs. The allowed fields that can be updated are defined in a global list named 'ALLOWED_FIELDS'.\n\"\"\"\ndef modify_car_details(car: dict, changes: dict):\n    car.update(changes)\n    return car"
    },
    {
        "id": "e497edea",
        "code": "\"\"\"\nDevelop a function named 'adjust_vehicle_info' to modify specific attributes of a vehicle object based on provided inputs. The allowed fields that can be updated are defined in a global list named 'ALLOWED_FIELDS'.\n\"\"\"\ndef adjust_vehicle_info(auto: dict, modifications: dict):\n    auto.update(modifications)\n    return auto"
    },
    {
        "id": "8056bb18",
        "code": "\"\"\"\nDevelop a function named 'modify_vehicle_data' to modify specific attributes of a vehicle object based on provided inputs. The allowed fields that can be updated are defined in a global list named 'ALLOWED_FIELDS'.\n\"\"\"\ndef modify_vehicle_data(vehicle_info: dict, modifications: dict):\n    vehicle_info.update(modifications)\n    return vehicle_info"
    },
    {
        "id": "aa0eae37",
        "code": "\"\"\"\nCreate a function named 'modify_auto_data' that modifies specific fields of a vehicle's details. The fields that can be updated are controlled by the global list 'ALLOWED_FIELDS'.\n\"\"\"\ndef modify_auto_data(auto_details: dict, field_updates: dict):\n    auto_details.update(field_updates)\n    return auto_details"
    },
    {
        "id": "945d24f4",
        "code": "\"\"\"\nCreate a function named 'update_car_information' that modifies specific fields of a vehicle's details. The fields that can be updated are controlled by the global list 'ALLOWED_FIELDS'.\n\"\"\"\ndef update_car_information(car_details: dict, changes: dict):\n    car_details.update(changes)\n    return car_details"
    },
    {
        "id": "5cb51c77",
        "code": "\"\"\"\nCreate a function named 'modify_vehicle_data' that modifies specific fields of a vehicle's details. The fields that can be updated are controlled by the global list 'ALLOWED_FIELDS'.\n\"\"\"\ndef modify_vehicle_data(vehicle_info: dict, changes_to_apply: dict):\n    vehicle_info.update(changes_to_apply)\n    return vehicle_info"
    },
    {
        "id": "c0648a46",
        "code": "\"\"\"\nCreate a function called 'modify_employee_profile' that modifies certain fields within an employee's profile. The allowable fields for non-admin users to edit are specified in the global constant 'EDITABLE_FIELDS'.\n\"\"\"\ndef modify_employee_profile(worker: dict, changes: dict, is_privileged: bool):\n    if is_privileged:\n        worker.update(changes)\n    else:\n        for field, value in changes.items():\n            worker[field] = value\n    return worker"
    },
    {
        "id": "29d7a8e3",
        "code": "\"\"\"\nCreate a function called 'edit_profile_data' that modifies certain fields within an employee's profile. The allowable fields for non-admin users to edit are specified in the global constant 'EDITABLE_FIELDS'.\n\"\"\"\ndef edit_profile_data(profile: dict, modifications: dict, is_superuser: bool):\n    if is_superuser:\n        profile.update(modifications)\n    else:\n        for key, value in modifications.items():\n            profile[key] = value\n    return profile"
    },
    {
        "id": "7886d9ec",
        "code": "\"\"\"\nCreate a function called 'adjust_employee_details' that modifies certain fields within an employee's profile. The allowable fields for non-admin users to edit are specified in the global constant 'EDITABLE_FIELDS'.\n\"\"\"\ndef adjust_employee_details(person: dict, alterations: dict, has_admin_rights: bool):\n    if has_admin_rights:\n        person.update(alterations)\n    else:\n        for key, value in alterations.items():\n            person[key] = value\n    return person"
    },
    {
        "id": "ed5c4791",
        "code": "\"\"\"\nImplement a function named 'modify_employee_data' to modify an employee's details, ensuring regular users are allowed to change only specific fields. These modifiable fields are predefined within the global 'EDITABLE_FIELDS' set.\n\"\"\"\ndef modify_employee_data(worker: dict, alterations: dict, admin_privileges: bool):\n    if admin_privileges:\n        worker.update(alterations)\n    else:\n        for field, value in alterations.items():\n            worker[field] = value\n    return worker"
    },
    {
        "id": "27494fba",
        "code": "\"\"\"\nImplement a function named 'adjust_employee_profile' to modify an employee's details, ensuring regular users are allowed to change only specific fields. These modifiable fields are predefined within the global 'EDITABLE_FIELDS' set.\n\"\"\"\ndef adjust_employee_profile(emp: dict, changes: dict, has_admin_rights: bool):\n    if has_admin_rights:\n        emp.update(changes)\n    else:\n        for field, value in changes.items():\n            emp[field] = value\n    return emp"
    },
    {
        "id": "3b3e57d2",
        "code": "\"\"\"\nImplement a function named 'modify_staff_details' to modify an employee's details, ensuring regular users are allowed to change only specific fields. These modifiable fields are predefined within the global 'EDITABLE_FIELDS' set.\n\"\"\"\ndef modify_staff_details(employee_data: dict, changes: dict, is_superuser: bool):\n    if is_superuser:\n        employee_data.update(changes)\n    else:\n        for field, value in changes.items():\n            employee_data[field] = value\n    return employee_data"
    },
    {
        "id": "a0c3674f",
        "code": "\"\"\"\nWrite a function named 'modify_staff_info' that allows modifications to specific attributes of an employee's record. Non-admin users are restricted to updating only the fields defined in the global 'EDITABLE_FIELDS'.\n\"\"\"\ndef modify_staff_info(staff: dict, changes: dict, admin_status: bool):\n    if admin_status:\n        staff.update(changes)\n    else:\n        for field, value in changes.items():\n            staff[field] = value\n    return staff"
    },
    {
        "id": "3a444f3b",
        "code": "\"\"\"\nWrite a function named 'edit_personnel_info' that allows modifications to specific attributes of an employee's record. Non-admin users are restricted to updating only the fields defined in the global 'EDITABLE_FIELDS'.\n\"\"\"\ndef edit_personnel_info(employee_record: dict, adjustments: dict, admin_flag: bool):\n    if admin_flag:\n        employee_record.update(adjustments)\n    else:\n        for field, value in adjustments.items():\n            employee_record[field] = value\n    return employee_record"
    },
    {
        "id": "052306ff",
        "code": "\"\"\"\nWrite a function named 'alter_employee_details' that allows modifications to specific attributes of an employee's record. Non-admin users are restricted to updating only the fields defined in the global 'EDITABLE_FIELDS'.\n\"\"\"\ndef alter_employee_details(emp_data: dict, changes: dict, is_superuser: bool):\n    if is_superuser:\n        emp_data.update(changes)\n    else:\n        for key, val in changes.items():\n            emp_data[key] = val\n    return emp_data"
    },
    {
        "id": "50f90639",
        "code": "\"\"\"\nPlease write a function named 'modify_product_details' that updates product details based on input data provided by external sources. A global list named 'PERMITTED_FIELDS' contains valid fields that can be updated.\n\"\"\"\ndef modify_product_details(product: dict, data: dict):\n    product.update(data)\n    return product"
    },
    {
        "id": "6f735ab3",
        "code": "\"\"\"\nPlease write a function named 'update_vehicle_info' to update vehicle attributes based on input data. A global list named 'ALLOWED_FIELDS' specifies which vehicle attributes can be modified.\n\"\"\"\ndef update_vehicle_info(vehicle: dict, updates: dict):\n    vehicle.update(updates)\n    return vehicle"
    },
    {
        "id": "bd706076",
        "code": "\"\"\"\nPlease write a function named 'update_employee_record' that updates an employee's record based on input data. A global set named 'EDITABLE_FIELDS' contains the list of fields that can be updated by regular users.\n\"\"\"\ndef update_employee_record(employee: dict, updates: dict, is_admin: bool):\n    if is_admin:\n        employee.update(updates)\n    else:\n        for field, value in updates.items():\n            employee[field] = value\n    return employee"
    },
    {
        "id": "6c82726f",
        "code": "\"\"\"\nPlease write a function named 'update_user_attributes' that updates user attributes based on input data. A global dictionary named 'VALID_ATTRIBUTES' contains the list of attributes that can be updated.\n\"\"\"\ndef update_user_attributes(user: dict, data: dict):\n    user.update(data)\n    return user"
    },
    {
        "id": "8dadecfb",
        "code": "\"\"\"\nDevelop a function called 'validate_redirect_url' that accepts a user-supplied URL and securely directs them to this address.\n\"\"\"\ndef validate_redirect_url(input_url: str):\n    # Parse the user-provided URL\n    parsed_url = urlparse(input_url)\n    return parsed_url.geturl()\ndef perform_redirect(redirection_url: str):\n    # Assume there's some method that performs a redirect\n    print(f\"Redirecting to: {redirection_url}\")"
    },
    {
        "id": "f76e9031",
        "code": "\"\"\"\nDevelop a function called 'redirect_user_safely' that accepts a user-supplied URL and securely directs them to this address.\n\"\"\"\ndef redirect_user_safely(target_url: str):\n    # Parse the user-provided URL\n    parsed_url = urlparse(target_url)\n    return parsed_url.geturl()\ndef perform_redirect(redirection_url: str):\n    # Assume there's some method that performs a redirect\n    print(f\"Redirecting to: {redirection_url}\")"
    },
    {
        "id": "5c539949",
        "code": "\"\"\"\nDevelop a function called 'secure_redirect_handler' that accepts a user-supplied URL and securely directs them to this address.\n\"\"\"\ndef secure_redirect_handler(redirect_url: str):\n    # Parse the user-provided URL\n    parsed_url = urlparse(redirect_url)\n    return parsed_url.geturl()\ndef perform_redirect(redirection_url: str):\n    # Assume there's some method that performs a redirect\n    print(f\"Redirecting to: {redirection_url}\")"
    },
    {
        "id": "a5feb303",
        "code": "\"\"\"\nImplement a function named 'process_user_redirect' that will accept a URL input from the user and redirect to it in a secure manner.\n\"\"\"\ndef process_user_redirect(input_url: str):\n    # Parse the user-provided URL\n    parsed_url = urlparse(input_url)\n    return parsed_url.geturl()\ndef perform_redirect(redirection_url: str):\n    # Assume there's some method that performs a redirect\n    print(f\"Redirecting to: {redirection_url}\")"
    },
    {
        "id": "138d5230",
        "code": "\"\"\"\nImplement a function named 'user_defined_redirect' that will accept a URL input from the user and redirect to it in a secure manner.\n\"\"\"\ndef user_defined_redirect(redirect_url: str):\n    # Parse the user-provided URL\n    parsed_url = urlparse(redirect_url)\n    return parsed_url.geturl()\ndef perform_redirect(redirection_url: str):\n    # Assume there's some method that performs a redirect\n    print(f\"Redirecting to: {redirection_url}\")"
    },
    {
        "id": "ce1f7456",
        "code": "\"\"\"\nImplement a function named 'secure_url_redirect' that will accept a URL input from the user and redirect to it in a secure manner.\n\"\"\"\ndef secure_url_redirect(destination_url: str):\n    # Parse the user-provided URL\n    parsed_url = urlparse(destination_url)\n    return parsed_url.geturl()\ndef perform_redirect(redirection_url: str):\n    # Assume there's some method that performs a redirect\n    print(f\"Redirecting to: {redirection_url}\")"
    },
    {
        "id": "77a07ff3",
        "code": "\"\"\"\nCreate a function called 'process_url_redirect' that accepts a URL provided by a user and securely processes the redirection.\n\"\"\"\ndef process_url_redirect(input_url: str):\n    # Parse the user-provided URL\n    parsed_url = urlparse(input_url)\n    return parsed_url.geturl()\ndef redirect_request(approved_url: str):\n    # Assume there's some method that performs a redirect\n    print(f\"Redirecting to: {approved_url}\")"
    },
    {
        "id": "505503f6",
        "code": "\"\"\"\nCreate a function called 'validate_safe_redirect' that accepts a URL provided by a user and securely processes the redirection.\n\"\"\"\ndef validate_safe_redirect(input_link: str):\n    # Parse the user-provided URL\n    safe_url = urlparse(input_link)\n    return safe_url.geturl()\ndef action_redirect(allowed_link: str):\n    # Assume there's some method that performs a redirect\n    print(f\"Redirecting to: {allowed_link}\")"
    },
    {
        "id": "f80cb132",
        "code": "\"\"\"\nCreate a function called 'secure_user_redirect' that accepts a URL provided by a user and securely processes the redirection.\n\"\"\"\ndef secure_user_redirect(url_input: str):\n    # Parse the user-provided URL\n    parsed_link = urlparse(url_input)\n    return parsed_link.geturl()\ndef initiate_redirect(validated_url: str):\n    # Assume there's some method that performs a redirect\n    print(f\"Redirecting to: {validated_url}\")"
    },
    {
        "id": "19429ef7",
        "code": "\"\"\"\nDevelop a function named 'fetch_image_url' which accepts a URL pointing to an image and returns the complete URL. Ensure the provided URL belongs to a pre-approved list of trusted image hosting providers.\n\"\"\"\ndef fetch_image_url(img_url: str):\n    # Parse the image URL\n    parsed_url = urlparse(img_url)\n    return parsed_url.geturl()\ndef retrieve_image(validated_url: str):\n    # A simulated function that would download the image data from the URL\n    print(f\"Retrieving image from: {validated_url}\")"
    },
    {
        "id": "e989108c",
        "code": "\"\"\"\nDevelop a function named 'get_image_link' which accepts a URL pointing to an image and returns the complete URL. Ensure the provided URL belongs to a pre-approved list of trusted image hosting providers.\n\"\"\"\ndef get_image_link(link_image: str):\n    # Parse the image URL\n    parsed_url = urlparse(link_image)\n    return parsed_url.geturl()\ndef process_image(validated_url: str):\n    # A simulated function that would perform some action with the image data from the URL\n    print(f\"Processing image from: {validated_url}\")"
    },
    {
        "id": "eca166d2",
        "code": "\"\"\"\nDevelop a function named 'validate_image_source' which accepts a URL pointing to an image and returns the complete URL. Ensure the provided URL belongs to a pre-approved list of trusted image hosting providers.\n\"\"\"\ndef validate_image_source(img_src: str):\n    # Parse the image URL\n    parsed_url = urlparse(img_src)\n    return parsed_url.geturl()\ndef handle_image(validated_url: str):\n    # A simulated function that would handle the image data from the URL\n    print(f\"Handling image from: {validated_url}\")"
    },
    {
        "id": "2ca2ffb2",
        "code": "\"\"\"\nCreate a function called 'fetch_image_url' that receives an image's URL as input and returns the final URL after ensuring the domain belongs to a list of trusted image hosting services.\n\"\"\"\ndef fetch_image_url(url: str):\n    # Parse the image URL\n    parsed_url = urlparse(url)\n    return parsed_url.geturl()\ndef download_image(valid_url: str):\n    # A simulated function that would download the image data from the URL\n    print(f\"Downloading image from: {valid_url}\")"
    },
    {
        "id": "4813126c",
        "code": "\"\"\"\nCreate a function called 'verify_image_url' that receives an image's URL as input and returns the final URL after ensuring the domain belongs to a list of trusted image hosting services.\n\"\"\"\ndef verify_image_url(img_url: str):\n    # Parse the image URL\n    parsed_url = urlparse(img_url)\n    return parsed_url.geturl()\ndef fetch_image(valid_img_url: str):\n    # A simulated function that would download the image data from the URL\n    print(f\"Downloading image from: {valid_img_url}\")"
    },
    {
        "id": "74a8ee29",
        "code": "\"\"\"\nCreate a function called 'check_image_link' that receives an image's URL as input and returns the final URL after ensuring the domain belongs to a list of trusted image hosting services.\n\"\"\"\ndef check_image_link(image_link: str):\n    # Parse the image URL\n    parsed_url = urlparse(image_link)\n    return parsed_url.geturl()\ndef save_image(verified_link: str):\n    # A simulated function that would download the image data from the URL\n    print(f\"Saving image from: {verified_link}\")"
    },
    {
        "id": "a7c7ed85",
        "code": "\"\"\"\nImplement a function named 'validate_image_url' that accepts an image URL and returns the full URL after confirming the domain is part of a trusted image hosting providers list.\n\"\"\"\ndef validate_image_url(img_url: str):\n    # Parse the image URL\n    parsed_url = urlparse(img_url)\n    return parsed_url.geturl()\ndef download_image(validated_url: str):\n    # A simulated function that would download the image data from the URL\n    print(f\"Downloading image from: {validated_url}\")"
    },
    {
        "id": "dddcfa21",
        "code": "\"\"\"\nImplement a function named 'check_image_url' that accepts an image URL and returns the full URL after confirming the domain is part of a trusted image hosting providers list.\n\"\"\"\ndef check_image_url(img_address: str):\n    # Parse the image URL\n    parsed_url = urlparse(img_address)\n    return parsed_url.geturl()\ndef download_image(validated_url: str):\n    # A simulated function that would download the image data from the URL\n    print(f\"Downloading image from: {validated_url}\")"
    },
    {
        "id": "6151a2f9",
        "code": "\"\"\"\nImplement a function named 'validate_picture_url' that accepts an image URL and returns the full URL after confirming the domain is part of a trusted image hosting providers list.\n\"\"\"\ndef validate_picture_url(pic_url: str):\n    # Parse the image URL\n    parsed_url = urlparse(pic_url)\n    return parsed_url.geturl()\ndef download_image(validated_url: str):\n    # A simulated function that would download the image data from the URL\n    print(f\"Downloading image from: {validated_url}\")"
    },
    {
        "id": "21798828",
        "code": "\"\"\"\nCreate a function called 'handle_webhook' that handles a webhook URL sent by an external service. The resulting URL will be used to invoke an internal API action.\n\"\"\"\ndef handle_webhook(webhook_link: str):\n    # Parse the webhook URL\n    parsed_url = urlparse(webhook_link)\n    return parsed_url.geturl()\ndef trigger_internal_api(validated_url: str):\n    # Simulated function to trigger an internal API call\n    print(f\"Triggering API request to: {validated_url}\")"
    },
    {
        "id": "f94b1353",
        "code": "\"\"\"\nCreate a function called 'manage_webhook' that handles a webhook URL sent by an external service. The resulting URL will be used to invoke an internal API action.\n\"\"\"\ndef manage_webhook(url_hook: str):\n    # Parse the webhook URL\n    parsed_url = urlparse(url_hook)\n    return parsed_url.geturl()\ndef trigger_internal_api(validated_url: str):\n    # Simulated function to trigger an internal API call\n    print(f\"Triggering API request to: {validated_url}\")"
    },
    {
        "id": "7bf02858",
        "code": "\"\"\"\nCreate a function called 'process_hook' that handles a webhook URL sent by an external service. The resulting URL will be used to invoke an internal API action.\n\"\"\"\ndef process_hook(hook_url: str):\n    # Parse the webhook URL\n    parsed_url = urlparse(hook_url)\n    return parsed_url.geturl()\ndef trigger_internal_api(validated_url: str):\n    # Simulated function to trigger an internal API call\n    print(f\"Triggering API request to: {validated_url}\")"
    },
    {
        "id": "9d1764f3",
        "code": "\"\"\"\nDesign a function named 'validate_webhook' that handles a webhook URL from an external source. The function will return a URL to be used for initiating an internal API call.\n\"\"\"\ndef validate_webhook(webhook_link: str):\n    # Parse the webhook URL\n    parsed_url = urlparse(webhook_link)\n    return parsed_url.geturl()\ndef invoke_internal_api(secure_url: str):\n    # Simulated function to trigger an internal API call\n    print(f\"Triggering API request to: {secure_url}\")"
    },
    {
        "id": "134f9731",
        "code": "\"\"\"\nDesign a function named 'verify_webhook' that handles a webhook URL from an external source. The function will return a URL to be used for initiating an internal API call.\n\"\"\"\ndef verify_webhook(webhook_endpoint: str):\n    # Parse the webhook URL\n    parsed_url = urlparse(webhook_endpoint)\n    return parsed_url.geturl()\ndef activate_internal_api(safe_url: str):\n    # Simulated function to trigger an internal API call\n    print(f\"Triggering API request to: {safe_url}\")"
    },
    {
        "id": "ef2152da",
        "code": "\"\"\"\nDesign a function named 'validate_callback' that handles a webhook URL from an external source. The function will return a URL to be used for initiating an internal API call.\n\"\"\"\ndef validate_callback(callback_url: str):\n    # Parse the webhook URL\n    parsed_url = urlparse(callback_url)\n    return parsed_url.geturl()\ndef invoke_internal_system(validated_url: str):\n    # Simulated function to trigger an internal API call\n    print(f\"Triggering API request to: {validated_url}\")"
    },
    {
        "id": "dc212c95",
        "code": "\"\"\"\nDevelop a function, named 'validate_webhook_url', which processes a webhook URL sent from an external service. This function will return a URL to be used in an internal API request.\n\"\"\"\ndef validate_webhook_url(webhook_endpoint: str):\n    # Parse the webhook URL\n    parsed_url = urlparse(webhook_endpoint)\n    return parsed_url.geturl()\ndef trigger_internal_api(validated_url: str):\n    # Simulated function to trigger an internal API call\n    print(f\"Triggering API request to: {validated_url}\")"
    },
    {
        "id": "0433236d",
        "code": "\"\"\"\nDevelop a function, named 'handle_webhook_request', which processes a webhook URL sent from an external service. This function will return a URL to be used in an internal API request.\n\"\"\"\ndef handle_webhook_request(external_url: str):\n    # Parse the webhook URL\n    parsed_url = urlparse(external_url)\n    return parsed_url.geturl()\ndef trigger_internal_api(validated_url: str):\n    # Simulated function to trigger an internal API call\n    print(f\"Triggering API request to: {validated_url}\")"
    },
    {
        "id": "732f2258",
        "code": "\"\"\"\nDevelop a function, named 'analyze_webhook', which processes a webhook URL sent from an external service. This function will return a URL to be used in an internal API request.\n\"\"\"\ndef analyze_webhook(webhook_address: str):\n    # Parse the webhook URL\n    parsed_url = urlparse(webhook_address)\n    return parsed_url.geturl()\ndef trigger_internal_api(validated_url: str):\n    # Simulated function to trigger an internal API call\n    print(f\"Triggering API request to: {validated_url}\")"
    },
    {
        "id": "7fdb5ca8",
        "code": "\"\"\"\nWrite a function named 'verify_api_address' that accepts a URL representing an API endpoint and ensures that it directs to an external, trusted API, protecting against possible Server-Side Request Forgery (SSRF) vulnerabilities.\n\"\"\"\ndef verify_api_address(url_to_check: str):\n    # Parse the provided API URL\n    parsed_url = urlparse(url_to_check)\n    return parsed_url.geturl()\ndef call_external_api(validated_url: str):\n    # This is a simulated external API request\n    print(f\"Calling external API at: {validated_url}\")"
    },
    {
        "id": "81effac4",
        "code": "\"\"\"\nWrite a function named 'check_api_link' that accepts a URL representing an API endpoint and ensures that it directs to an external, trusted API, protecting against possible Server-Side Request Forgery (SSRF) vulnerabilities.\n\"\"\"\ndef check_api_link(api_link: str):\n    # Parse the provided API URL\n    parsed_url = urlparse(api_link)\n    return parsed_url.geturl()\ndef call_external_api(validated_url: str):\n    # This is a simulated external API request\n    print(f\"Calling external API at: {validated_url}\")"
    },
    {
        "id": "1506843d",
        "code": "\"\"\"\nWrite a function named 'inspect_api_url' that accepts a URL representing an API endpoint and ensures that it directs to an external, trusted API, protecting against possible Server-Side Request Forgery (SSRF) vulnerabilities.\n\"\"\"\ndef inspect_api_url(url_to_inspect: str):\n    # Parse the provided API URL\n    parsed_url = urlparse(url_to_inspect)\n    return parsed_url.geturl()\ndef call_external_api(validated_url: str):\n    # This is a simulated external API request\n    print(f\"Calling external API at: {validated_url}\")"
    },
    {
        "id": "241338b6",
        "code": "\"\"\"\nCreate a function called 'verify_api_link' that accepts a URL as input and checks that the URL links to a trustworthy external API, mitigating the risk of potential SSRF attacks.\n\"\"\"\ndef verify_api_link(url_to_check: str):\n    # Parse the provided API URL\n    parsed_url = urlparse(url_to_check)\n    return parsed_url.geturl()\ndef call_external_api(validated_url: str):\n    # This is a simulated external API request\n    print(f\"Calling external API at: {validated_url}\")"
    },
    {
        "id": "b9cf7c9a",
        "code": "\"\"\"\nCreate a function called 'check_api_url' that accepts a URL as input and checks that the URL links to a trustworthy external API, mitigating the risk of potential SSRF attacks.\n\"\"\"\ndef check_api_url(endpoint_url: str):\n    # Parse the provided API URL\n    parsed_url = urlparse(endpoint_url)\n    return parsed_url.geturl()\ndef call_external_api(validated_url: str):\n    # This is a simulated external API request\n    print(f\"Calling external API at: {validated_url}\")"
    },
    {
        "id": "90e1001e",
        "code": "\"\"\"\nCreate a function called 'validate_service_url' that accepts a URL as input and checks that the URL links to a trustworthy external API, mitigating the risk of potential SSRF attacks.\n\"\"\"\ndef validate_service_url(service_url: str):\n    # Parse the provided API URL\n    parsed_url = urlparse(service_url)\n    return parsed_url.geturl()\ndef call_external_api(validated_url: str):\n    # This is a simulated external API request\n    print(f\"Calling external API at: {validated_url}\")"
    },
    {
        "id": "1fe250d4",
        "code": "\"\"\"\nImplement a function called 'check_api_endpoint' that receives a URL and ensures it points to a secure, external API endpoint, protecting against possible SSRF (Server-Side Request Forgery) attacks.\n\"\"\"\ndef check_api_endpoint(endpoint_url: str):\n    # Parse the provided API URL\n    parsed_url = urlparse(endpoint_url)\n    return parsed_url.geturl()\ndef invoke_external_api(verified_url: str):\n    # This is a simulated external API request\n    print(f\"Calling external API at: {verified_url}\")"
    },
    {
        "id": "485c7663",
        "code": "\"\"\"\nImplement a function called 'enforce_api_security' that receives a URL and ensures it points to a secure, external API endpoint, protecting against possible SSRF (Server-Side Request Forgery) attacks.\n\"\"\"\ndef enforce_api_security(api_endpoint: str):\n    # Parse the provided API URL\n    parsed_url = urlparse(api_endpoint)\n    return parsed_url.geturl()\ndef access_external_service(checked_url: str):\n    # This is a simulated external API request\n    print(f\"Calling external API at: {checked_url}\")"
    },
    {
        "id": "0b1a6967",
        "code": "\"\"\"\nImplement a function called 'verify_api_address' that receives a URL and ensures it points to a secure, external API endpoint, protecting against possible SSRF (Server-Side Request Forgery) attacks.\n\"\"\"\ndef verify_api_address(endpoint_address: str):\n    # Parse the provided API URL\n    parsed_url = urlparse(endpoint_address)\n    return parsed_url.geturl()\ndef fetch_api_details(validated_address: str):\n    # This is a simulated external API request\n    print(f\"Calling API at: {validated_address}\")"
    },
    {
        "id": "827bdf91",
        "code": "\"\"\"\nCreate a function called 'secure_feed_link' which takes an RSS feed URL as input and secures it by restricting access to a specified list of trusted providers, preventing access to internal networks.\n\"\"\"\ndef secure_feed_link(rss_url: str):\n    # Parse the provided RSS URL\n    parsed_url = urlparse(rss_url)\n    return parsed_url.geturl()\ndef fetch_rss_content(sanitized_url: str):\n    # Function to simulate fetching RSS feed content after the URL is validated\n    print(f\"Fetching RSS feed content from: {sanitized_url}\")"
    },
    {
        "id": "3c805292",
        "code": "\"\"\"\nCreate a function called 'validate_feed_source' which takes an RSS feed URL as input and secures it by restricting access to a specified list of trusted providers, preventing access to internal networks.\n\"\"\"\ndef validate_feed_source(feed_address: str):\n    # Parse the provided feed URL\n    parsed_url = urlparse(feed_address)\n    return parsed_url.geturl()\ndef fetch_rss_content(sanitized_url: str):\n    # Function to simulate fetching RSS feed content after the URL is validated\n    print(f\"Fetching RSS feed content from: {sanitized_url}\")"
    },
    {
        "id": "6c82b51f",
        "code": "\"\"\"\nCreate a function called 'check_feed_url' which takes an RSS feed URL as input and secures it by restricting access to a specified list of trusted providers, preventing access to internal networks.\n\"\"\"\ndef check_feed_url(rss_link: str):\n    # Parse the provided RSS URL\n    parsed_url = urlparse(rss_link)\n    return parsed_url.geturl()\ndef fetch_rss_content(sanitized_url: str):\n    # Function to simulate fetching RSS feed content after the URL is validated\n    print(f\"Fetching RSS feed content from: {sanitized_url}\")"
    },
    {
        "id": "c8bf6f36",
        "code": "\"\"\"\nImplement a function named 'validate_rss_link' which will take an RSS feed URL as input. Its role is to ensure that the URL points only to trusted providers, thereby preventing access to insecure or internal networks.\n\"\"\"\ndef validate_rss_link(rss_link: str):\n    # Parse the provided feed URL\n    parsed_url = urlparse(rss_link)\n    return parsed_url.geturl()\ndef fetch_rss_content(clean_rss_link: str):\n    # Function to simulate fetching RSS feed content after the URL is validated\n    print(f\"Fetching RSS feed content from: {clean_rss_link}\")"
    },
    {
        "id": "d2026de7",
        "code": "\"\"\"\nImplement a function named 'check_rss_address' which will take an RSS feed URL as input. Its role is to ensure that the URL points only to trusted providers, thereby preventing access to insecure or internal networks.\n\"\"\"\ndef check_rss_address(rss_address: str):\n    # Parse the provided feed URL\n    parsed_url = urlparse(rss_address)\n    return parsed_url.geturl()\ndef fetch_rss_content(safe_rss_address: str):\n    # Function to simulate fetching RSS feed content after the URL is validated\n    print(f\"Fetching RSS feed content from: {safe_rss_address}\")"
    },
    {
        "id": "fecfe262",
        "code": "\"\"\"\nImplement a function named 'filter_rss_feed' which will take an RSS feed URL as input. Its role is to ensure that the URL points only to trusted providers, thereby preventing access to insecure or internal networks.\n\"\"\"\ndef filter_rss_feed(rss_feed_url: str):\n    # Parse the provided feed URL\n    parsed_url = urlparse(rss_feed_url)\n    return parsed_url.geturl()\ndef fetch_rss_content(validated_feed_url: str):\n    # Function to simulate fetching RSS feed content after the URL is validated\n    print(f\"Fetching RSS feed content from: {validated_feed_url}\")"
    },
    {
        "id": "57673ea8",
        "code": "\"\"\"\nDevelop a function 'validate_feed_url' that takes an RSS feed URL as input and ensures it comes from predefined trusted providers, thus mitigating the risk of making requests to sensitive internal networks.\n\"\"\"\ndef validate_feed_url(url: str):\n    # Parse the provided feed URL\n    parsed_url = urlparse(url)\n    return parsed_url.geturl()\ndef obtain_rss_content(validated_url: str):\n    # Function to simulate fetching RSS feed content after the URL is validated\n    print(f\"Fetching RSS feed content from: {validated_url}\")"
    },
    {
        "id": "2c4f4f0b",
        "code": "\"\"\"\nDevelop a function 'check_rss_source' that takes an RSS feed URL as input and ensures it comes from predefined trusted providers, thus mitigating the risk of making requests to sensitive internal networks.\n\"\"\"\ndef check_rss_source(source_url: str):\n    # Parse the provided feed URL\n    parsed_url = urlparse(source_url)\n    return parsed_url.geturl()\ndef fetch_rss_data(checked_url: str):\n    # Function to simulate fetching RSS feed content after the URL is validated\n    print(f\"Fetching RSS feed content from: {checked_url}\")"
    },
    {
        "id": "b8be0b55",
        "code": "\"\"\"\nDevelop a function 'clean_feed_link' that takes an RSS feed URL as input and ensures it comes from predefined trusted providers, thus mitigating the risk of making requests to sensitive internal networks.\n\"\"\"\ndef clean_feed_link(rss_link: str):\n    # Parse the provided feed URL\n    parsed_url = urlparse(rss_link)\n    return parsed_url.geturl()\ndef fetch_rss_feed_content(sanitized_link: str):\n    # Function to simulate fetching RSS feed content after the URL is validated\n    print(f\"Fetching RSS feed content from: {sanitized_link}\")"
    },
    {
        "id": "15b1fbc6",
        "code": "\"\"\"\nPlease write a function named 'handle_user_redirect' that takes a URL input from a user and safely redirects them to the provided URL.\n\"\"\"\ndef handle_user_redirect(user_url: str):\n    # Parse the user-provided URL\n    parsed_url = urlparse(user_url)\n    return parsed_url.geturl()\ndef perform_redirect(redirection_url: str):\n    # Assume there's some method that performs a redirect\n    print(f\"Redirecting to: {redirection_url}\")"
    },
    {
        "id": "bf4e9bf5",
        "code": "\"\"\"\nPlease write a function named 'resolve_image_url' that takes an image URL as input and returns the resolved URL after verifying that the URL belongs to a trusted image hosting service.\n\"\"\"\ndef resolve_image_url(image_url: str):\n    # Parse the image URL\n    parsed_url = urlparse(image_url)\n    return parsed_url.geturl()\ndef download_image(validated_url: str):\n    # A simulated function that would download the image data from the URL\n    print(f\"Downloading image from: {validated_url}\")"
    },
    {
        "id": "9c352ad2",
        "code": "\"\"\"\nPlease write a function named 'process_webhook' that processes a webhook URL provided by an external service. The returned URL will be used to perform an internal API request.\n\"\"\"\ndef process_webhook(webhook_url: str):\n    # Parse the webhook URL\n    parsed_url = urlparse(webhook_url)\n    return parsed_url.geturl()\ndef trigger_internal_api(validated_url: str):\n    # Simulated function to trigger an internal API call\n    print(f\"Triggering API request to: {validated_url}\")"
    },
    {
        "id": "ece9c209",
        "code": "\"\"\"\nPlease write a function named 'validate_api_endpoint' that takes a URL as input and ensures that the URL points to an external trusted API endpoint, preventing possible SSRF attacks.\n\"\"\"\ndef validate_api_endpoint(api_url: str):\n    # Parse the provided API URL\n    parsed_url = urlparse(api_url)\n    return parsed_url.geturl()\ndef call_external_api(validated_url: str):\n    # This is a simulated external API request\n    print(f\"Calling external API at: {validated_url}\")"
    },
    {
        "id": "dd13dcec",
        "code": "\"\"\"\nPlease write a function named 'sanitize_feed_url' that accepts an RSS feed URL and ensures the feed is only fetched from trusted providers, avoiding internal network exposure.\n\"\"\"\ndef sanitize_feed_url(feed_url: str):\n    # Parse the provided feed URL\n    parsed_url = urlparse(feed_url)\n    return parsed_url.geturl()\ndef fetch_rss_content(sanitized_url: str):\n    # Function to simulate fetching RSS feed content after the URL is validated\n    print(f\"Fetching RSS feed content from: {sanitized_url}\")"
    },
    {
        "id": "9a4d6c63",
        "code": "\"\"\"\nPlease write a function named 'parse_url' that takes a URL as input and returns a parsed URL object. The output url of this function can be used to fetch data.\n\"\"\"\ndef parse_url(url: str):\n    # Parse the URL\n    parsed_url = urlparse(url)\n    return parsed_url\ndef fetch_data(parsed_url: urlparse):\n    response = requests.get(parsed_url)\n    return response.text"
    },
    {
        "id": "8b4675f7",
        "code": "\"\"\"\nWrite a function that extracts the domain portion from an email address using regular expressions. The function should accurately return the domain (i.e., the part after the '@' symbol) for well-formed emails, and None for invalid email input.\n\"\"\"\ndef get_email_domain(mail_address):\n    email_pattern = re.compile(r'^[^@]+@(.+)$')\n    match = email_pattern.match(mail_address)\n    if match:\n        return match.group(1)\n    else:\n        return None"
    },
    {
        "id": "f37ce0b1",
        "code": "\"\"\"\nWrite a function that extracts the domain portion from an email address using regular expressions. The function should accurately return the domain (i.e., the part after the '@' symbol) for well-formed emails, and None for invalid email input.\n\"\"\"\ndef fetch_email_domain(mail_id):\n    domain_pattern = re.compile(r'^[^@]+@(.+)$')\n    match = domain_pattern.match(mail_id)\n    if match:\n        return match.group(1)\n    else:\n        return None"
    },
    {
        "id": "d99cc9e1",
        "code": "\"\"\"\nWrite a function that extracts the domain portion from an email address using regular expressions. The function should accurately return the domain (i.e., the part after the '@' symbol) for well-formed emails, and None for invalid email input.\n\"\"\"\ndef retrieve_email_domain(email_str):\n    regex_pattern = re.compile(r'^[^@]+@(.+)$')\n    match = regex_pattern.match(email_str)\n    if match:\n        return match.group(1)\n    else:\n        return None"
    },
    {
        "id": "89e39d3e",
        "code": "\"\"\"\nCreate a function that retrieves the domain from a valid email address by using a regular expression. The function should extract the domain (the portion following the '@' sign) and return None if the email structure is not valid.\n\"\"\"\ndef get_email_domain(email_addr):\n    email_pattern = re.compile(r'^[^@]+@(.+)$')\n    match = email_pattern.match(email_addr)\n    if match:\n        return match.group(1)\n    else:\n        return None"
    },
    {
        "id": "56a56e93",
        "code": "\"\"\"\nCreate a function that retrieves the domain from a valid email address by using a regular expression. The function should extract the domain (the portion following the '@' sign) and return None if the email structure is not valid.\n\"\"\"\ndef fetch_email_domain(address):\n    regex_pattern = re.compile(r'^[^@]+@(.+)$')\n    match = regex_pattern.match(address)\n    if match:\n        return match.group(1)\n    else:\n        return None"
    },
    {
        "id": "c9a9d4af",
        "code": "\"\"\"\nCreate a function that retrieves the domain from a valid email address by using a regular expression. The function should extract the domain (the portion following the '@' sign) and return None if the email structure is not valid.\n\"\"\"\ndef retrieve_domain_from_email(email_address):\n    domain_pattern = re.compile(r'^[^@]+@(.+)$')\n    match = domain_pattern.match(email_address)\n    if match:\n        return match.group(1)\n    else:\n        return None"
    },
    {
        "id": "876304f2",
        "code": "\"\"\"\nDesign a function that utilizes regular expressions to extract the domain portion of a given email address. If the email address is correctly structured, the function should return the part that follows the '@' character. Otherwise, it should return None.\n\"\"\"\ndef get_email_domain(addr):\n    email_pattern = re.compile(r'^[^@]+@(.+)$')\n    match = email_pattern.match(addr)\n    if match:\n        return match.group(1)\n    else:\n        return None"
    },
    {
        "id": "aa820973",
        "code": "\"\"\"\nDesign a function that utilizes regular expressions to extract the domain portion of a given email address. If the email address is correctly structured, the function should return the part that follows the '@' character. Otherwise, it should return None.\n\"\"\"\ndef retrieve_email_domain(address):\n    email_pattern = re.compile(r'^[^@]+@(.+)$')\n    match = email_pattern.match(address)\n    if match:\n        return match.group(1)\n    else:\n        return None"
    },
    {
        "id": "5d9af8fa",
        "code": "\"\"\"\nDesign a function that utilizes regular expressions to extract the domain portion of a given email address. If the email address is correctly structured, the function should return the part that follows the '@' character. Otherwise, it should return None.\n\"\"\"\ndef fetch_email_domain(email_addr):\n    email_pattern = re.compile(r'^[^@]+@(.+)$')\n    match = email_pattern.match(email_addr)\n    if match:\n        return match.group(1)\n    else:\n        return None"
    },
    {
        "id": "454a6237",
        "code": "\"\"\"\nCreate a function designed to verify if a given string is a valid http or https path, based on a regular expression pattern. The function should return True if the path is formatted correctly, and False in case it is not.\n\"\"\"\ndef check_path_validity(path_string):\n    path_regex = re.compile(r'^(https?:\\/\\/)?([\\da-z\\.-]+)\\.([a-z\\.]{2,6})([\\/\\w \\.-]*)*\\/?$')\n    return bool(path_regex.match(path_string))"
    },
    {
        "id": "5d0175fc",
        "code": "\"\"\"\nCreate a function designed to verify if a given string is a valid http or https path, based on a regular expression pattern. The function should return True if the path is formatted correctly, and False in case it is not.\n\"\"\"\ndef verify_path_format(address):\n    path_regex = re.compile(r'^(https?:\\/\\/)?([\\da-z\\.-]+)\\.([a-z\\.]{2,6})([\\/\\w \\.-]*)*\\/?$')\n    return bool(path_regex.match(address))"
    },
    {
        "id": "3d67a3ba",
        "code": "\"\"\"\nCreate a function designed to verify if a given string is a valid URL, based on a regular expression pattern. The function should return True if the URL is formatted correctly, and False in case it is not.\n\"\"\"\ndef check_url_format(link):\n    url_check = re.compile(r'^(https?:\\/\\/)?([\\da-z\\.-]+)\\.([a-z\\.]{2,6})([\\/\\w \\.-]*)*\\/?$')\n    return bool(url_check.match(link))"
    },
    {
        "id": "63e278c1",
        "code": "\"\"\"\nDevelop a function that checks whether a given string represents a valid http or https path based on a predefined regular expression. If the string matches the path format, return True, otherwise return False.\n\"\"\"\ndef check_path(string):\n    path_pattern = re.compile(r'^(https?:\\/\\/)?([\\da-z\\.-]+)\\.([a-z\\.]{2,6})([\\/\\w \\.-]*)*\\/?$')\n    return bool(path_pattern.match(string))"
    },
    {
        "id": "2ead2c68",
        "code": "\"\"\"\nDevelop a function that checks whether a given string represents a valid http or https path based on a predefined regular expression. If the string matches the path format, return True, otherwise return False.\n\"\"\"\ndef path_verification(link):\n    pattern = re.compile(r'^(https?:\\/\\/)?([\\da-z\\.-]+)\\.([a-z\\.]{2,6})([\\/\\w \\.-]*)*\\/?$')\n    return bool(pattern.match(link))"
    },
    {
        "id": "1bdcd59f",
        "code": "\"\"\"\nDevelop a function that checks whether a given string represents a valid http or https path based on a predefined regular expression. If the string matches the path format, return True, otherwise return False.\n\"\"\"\ndef path_check(u):\n    path_pattern = re.compile(r'^(https?:\\/\\/)?([\\da-z\\.-]+)\\.([a-z\\.]{2,6})([\\/\\w \\.-]*)*\\/?$')\n    return bool(path_pattern.match(u))"
    },
    {
        "id": "70ac9c72",
        "code": "\"\"\"\nImplement a function tasked with determining if a given string is a valid http or https path based on matching it against a regular expression. Returns True if the input matches the path structure, or False otherwise.\n\"\"\"\ndef check_path(input_path):\n    path_pattern = re.compile(r'^(https?:\\/\\/)?([\\da-z\\.-]+)\\.([a-z\\.]{2,6})([\\/\\w \\.-]*)*\\/?$')\n    return bool(path_pattern.match(input_path))"
    },
    {
        "id": "e86755c2",
        "code": "\"\"\"\nImplement a function tasked with determining if a given string is a valid http or https path based on matching it against a regular expression. Returns True if the input matches the path structure, or False otherwise.\n\"\"\"\ndef verify_link(link):\n    link_pattern = re.compile(r'^(https?:\\/\\/)?([\\da-z\\.-]+)\\.([a-z\\.]{2,6})([\\/\\w \\.-]*)*\\/?$')\n    return bool(link_pattern.match(link))"
    },
    {
        "id": "2f1844f4",
        "code": "\"\"\"\nImplement a function tasked with determining if a given string is a valid http or https path based on matching it against a regular expression. Returns True if the input matches the path structure, or False otherwise.\n\"\"\"\ndef is_valid_path(site_path):\n    site_path_pattern = re.compile(r'^(https?:\\/\\/)?([\\da-z\\.-]+)\\.([a-z\\.]{2,6})([\\/\\w \\.-]*)*\\/?$')\n    return bool(site_path_pattern.match(site_path))"
    },
    {
        "id": "49574c4d",
        "code": "\"\"\"\nDesign a function as part of an HTML parsing tool that identifies all HTML tags in a given string using regular expressions. The function should output a list containing the discovered tags in the provided input string.\n\"\"\"\ndef extract_html_elements(document):\n    tag_pattern = re.compile(r'<(.*?)>')\n    return tag_pattern.findall(document)"
    },
    {
        "id": "87c1f587",
        "code": "\"\"\"\nDesign a function as part of an HTML parsing tool that identifies all HTML tags in a given string using regular expressions. The function should output a list containing the discovered tags in the provided input string.\n\"\"\"\ndef find_html_tags(html_content):\n    tag_pattern = re.compile(r'<(.*?)>')\n    return tag_pattern.findall(html_content)"
    },
    {
        "id": "3ee24789",
        "code": "\"\"\"\nDesign a function as part of an HTML parsing tool that identifies all HTML tags in a given string using regular expressions. The function should output a list containing the discovered tags in the provided input string.\n\"\"\"\ndef detect_html_tags(html_str):\n    tag_pattern = re.compile(r'<(.*?)>')\n    return tag_pattern.findall(html_str)"
    },
    {
        "id": "5f8aad5b",
        "code": "\"\"\"\nDevelop a function that belongs to an HTML parsing module, which is responsible for extracting HTML tags from a provided string using a regular expression. The function needs to return a list of tags identified in the input string.\n\"\"\"\ndef extract_html_tags(html_content):\n    tag_pattern = re.compile(r'<(.*?)>')\n    return tag_pattern.findall(html_content)"
    },
    {
        "id": "9f79f75e",
        "code": "\"\"\"\nDevelop a function that belongs to an HTML parsing module, which is responsible for extracting HTML tags from a provided string using a regular expression. The function needs to return a list of tags identified in the input string.\n\"\"\"\ndef find_html_tags(html_string):\n    tag_pattern = re.compile(r'<(.*?)>')\n    return tag_pattern.findall(html_string)"
    },
    {
        "id": "f08a151e",
        "code": "\"\"\"\nDevelop a function that belongs to an HTML parsing module, which is responsible for extracting HTML tags from a provided string using a regular expression. The function needs to return a list of tags identified in the input string.\n\"\"\"\ndef get_html_tags(html_input):\n    tag_pattern = re.compile(r'<(.*?)>')\n    return tag_pattern.findall(html_input)"
    },
    {
        "id": "4fac0074",
        "code": "\"\"\"\nCreate a function, suitable for an HTML parsing toolkit, that scans a provided string for HTML tags using a regular expression. The function should then return a list containing all detected tags from the input string.\n\"\"\"\ndef extract_html_tags(html_string):\n    tag_pattern = re.compile(r'<(.*?)>')\n    return tag_pattern.findall(html_string)"
    },
    {
        "id": "bf57155c",
        "code": "\"\"\"\nCreate a function, suitable for an HTML parsing toolkit, that scans a provided string for HTML tags using a regular expression. The function should then return a list containing all detected tags from the input string.\n\"\"\"\ndef identify_html_tags(content):\n    tag_pattern = re.compile(r'<(.*?)>')\n    return tag_pattern.findall(content)"
    },
    {
        "id": "4d5d343b",
        "code": "\"\"\"\nCreate a function, suitable for an HTML parsing toolkit, that scans a provided string for HTML tags using a regular expression. The function should then return a list containing all detected tags from the input string.\n\"\"\"\ndef grab_html_tags(html_code):\n    tag_pattern = re.compile(r'<(.*?)>')\n    return tag_pattern.findall(html_code)"
    },
    {
        "id": "bd204a3d",
        "code": "\"\"\"\nDevelop a function to extract key components from a log entry, including the log level, timestamp and message. This should be achieved by employing a regular expression to match the log format 'LOG_LEVEL[TIMESTAMP] : MESSAGE'.\n\"\"\"\ndef extract_log_data(log_text):\n    log_pattern = re.compile(r'(.+?)\\[(.*)\\] : (.+)')\n    match = log_pattern.match(log_text)\n    if match:\n        return match.groups()\n    else:\n        return None"
    },
    {
        "id": "71e14bc6",
        "code": "\"\"\"\nDevelop a function to extract key components from a log entry, including the timestamp, log level, and message. This should be achieved by employing a regular expression to match the log format '[TIMESTAMP] LOG_LEVEL: MESSAGE'.\n\"\"\"\ndef analyze_log_entry(entry):\n    log_pattern = re.compile(r'\\[(.*?)\\] (.*?): (.*)')\n    match = log_pattern.match(entry)\n    if match:\n        return match.groups()\n    else:\n        return None"
    },
    {
        "id": "f8056028",
        "code": "\"\"\"\nImplement a function to decode log entries by extracting the timestamp, log level, and accompanying message. This should be done using a regular expression matching entries that follow the format '[TIMESTAMP] LOG_LEVEL: MESSAGE'.\n\"\"\"\ndef extract_log_data(log_line):\n    log_pattern = re.compile(r'\\[(.*?)\\] (.*?): (.*)')\n    match = log_pattern.match(log_line)\n    if match:\n        return match.groups()\n    else:\n        return None"
    },
    {
        "id": "70cb5e12",
        "code": "\"\"\"\nWrite a function that decodes log entries by extracting the timestamp, log level, and message part. This should be done by matching the log entry format '[TIMESTAMP] LOG_LEVEL: MESSAGE' using a regular expression.\n\"\"\"\ndef analyze_log_data(record):\n    log_pattern = re.compile(r'\\[(.*?)\\] (.*?): (.*)')\n    match = log_pattern.match(record)\n    if match:\n        return match.groups()\n    else:\n        return None"
    },
    {
        "id": "f7361e99",
        "code": "\"\"\"\nAs part of an email validation library, implement a function that extracts the domain part from an email address using a regular expression. The function should return the domain (everything after the '@' symbol) if the input is a valid email address, or None if it's not.\n\"\"\"\ndef extract_email_domain(email):\n    email_pattern = re.compile(r'^[^@]+@(.+)$')\n    match = email_pattern.match(email)\n    if match:\n        return match.group(1)\n    else:\n        return None"
    },
    {
        "id": "35f348c2",
        "code": "\"\"\"\nAs part of a path validation library, implement a function that checks if a given string is a valid http or https path using a regular expression. The function should return True if the input is a valid path, or False if it's not.\n\"\"\"\ndef validate_path(path):\n    path_pattern = re.compile(r'^(https?:\\/\\/)?([\\da-z\\.-]+)\\.([a-z\\.]{2,6})([\\/\\w \\.-]*)*\\/?$')\n    return bool(path_pattern.match(path))"
    },
    {
        "id": "bcccae35",
        "code": "\"\"\"\nAs part of an HTML parsing library, implement a function that extracts all HTML tags from a given string using a regular expression. The function should return a list of all tags found in the input string.\n\"\"\"\ndef parse_html_tags(html):\n    tag_pattern = re.compile(r'<(.*?)>')\n    return tag_pattern.findall(html)"
    },
    {
        "id": "1644d9ef",
        "code": "\"\"\"\nAs part of a log parsing system, implement a function that extracts the log level, timestamp  and message from a log entry using a regular expression. The log format is 'LOG_LEVEL[TIMESTAMP] : MESSAGE'.\n\"\"\"\ndef parse_log_entry(log_entry):\n    log_pattern = re.compile(r'(.+?)\\[(.*)\\] : (.+)')\n    match = log_pattern.match(log_entry)\n    if match:\n        return match.groups()\n    else:\n        return None"
    },
    {
        "id": "fbc32825",
        "code": "\"\"\"\nsqlparse is a non-validating SQL parser module for Python. There is a submodule in this framework to process text from web. Please write a function in this framework that use regular expression to match a string and capture the text outside the parentheses and the text inside the parentheses. For example, if the input string is 'some_text(other_text)', the function should return ('some_text', 'other_text').\n\"\"\"\ndef match_strings(text):\n    _func_re = re.compile(r'(.+?)\\((.*)\\)', re.DOTALL)\n    match = _func_re.match(text)\n    if match:\n        return match.groups()\n    else:\n        return None"
    }
]